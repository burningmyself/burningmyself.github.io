
<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
        <meta name="description" content=".net,java,php,python,docker,web">
      
      
        <meta name="author" content="BurningMyself">
      
      
        <link rel="canonical" href="https://burningmyself.gitee.io/linux/linux/">
      
      
        <link rel="prev" href="../../sql/mybatis/">
      
      
        <link rel="next" href="../often/">
      
      <link rel="icon" href="../../favicon.ico">
      <meta name="generator" content="mkdocs-1.4.2, mkdocs-material-9.0.15">
    
    
      
        <title>Linux学习笔记 - BurningMyself</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.113286f1.min.css">
      
        
        <link rel="stylesheet" href="../../assets/stylesheets/palette.a0c5b2b5.min.css">
      
      

    
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("../..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="" data-md-color-accent="">
  
    
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#linux" class="md-skip">
          跳转至
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="页眉">
    <a href="../.." title="BurningMyself" class="md-header__button md-logo" aria-label="BurningMyself" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            BurningMyself
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Linux学习笔记
            
          </span>
        </div>
      </div>
    </div>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="搜索" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="查找">
        
        <button type="reset" class="md-search__icon md-icon" title="清空当前内容" aria-label="清空当前内容" tabindex="-1">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            正在初始化搜索引擎
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        <a href="https://github.com/burningmyself/burningmyself.github.io" title="前往仓库" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.3.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    burningmyself.github.io
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


<nav class="md-nav md-nav--primary" aria-label="导航栏" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="BurningMyself" class="md-nav__button md-logo" aria-label="BurningMyself" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    BurningMyself
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/burningmyself/burningmyself.github.io" title="前往仓库" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.3.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    burningmyself.github.io
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../.." class="md-nav__link">
        介绍
      </a>
    </li>
  

    
      
      
      

  
  
    
  
  
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2" checked>
      
      
      
        <label class="md-nav__link" for="__nav_2" id="__nav_2_label" tabindex="0">
          技术博文
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_2_label" aria-expanded="true">
        <label class="md-nav__title" for="__nav_2">
          <span class="md-nav__icon md-icon"></span>
          技术博文
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_1" >
      
      
      
        <label class="md-nav__link" for="__nav_2_1" id="__nav_2_1_label" tabindex="0">
          .NET
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_2_1_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_2_1">
          <span class="md-nav__icon md-icon"></span>
          .NET
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../net/c_sharp/" class="md-nav__link">
        C#新特性语法
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../net/c_docker/" class="md-nav__link">
        .Net Core Docker 部署
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../net/c_sqlserver_nginx/" class="md-nav__link">
        Docker 容器化部署 ASP.NET Core
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../net/c_core_safety/" class="md-nav__link">
        让你的ASP.NET Core应用程序更安全
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../net/c_core_study_route/" class="md-nav__link">
        ASP.NET Core开发者指南
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_2" >
      
      
      
        <label class="md-nav__link" for="__nav_2_2" id="__nav_2_2_label" tabindex="0">
          Java
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_2_2_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_2_2">
          <span class="md-nav__icon md-icon"></span>
          Java
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../java/feature/" class="md-nav__link">
        Java特性
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../java/load-class/" class="md-nav__link">
        Java类加载
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../java/orm/" class="md-nav__link">
        Orm的优缺点
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../java/bio-nio/" class="md-nav__link">
        BIO与NIO
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../java/rocketmq/rmq-1/" class="md-nav__link">
        RocketMq下载与安装
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../java/springAnnotation/" class="md-nav__link">
        Spring常用注解
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../java/javavm/" class="md-nav__link">
        Java 虚拟机
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../java/springdesign/" class="md-nav__link">
        Spring 常用设计
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../java/spring-cloud/" class="md-nav__link">
        Spring Cloud
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../java/java-simple/" class="md-nav__link">
        Java simple
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../java/java-validator/" class="md-nav__link">
        Java Validator
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../java/java-string/" class="md-nav__link">
        Java String
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../java/java-utils/" class="md-nav__link">
        Java Utils
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_3" >
      
      
      
        <label class="md-nav__link" for="__nav_2_3" id="__nav_2_3_label" tabindex="0">
          Python
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_2_3_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_2_3">
          <span class="md-nav__icon md-icon"></span>
          Python
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../python/feature/" class="md-nav__link">
        Python特性
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../python/str_joint/" class="md-nav__link">
        Python字符拼接
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../python/syntax_rule/" class="md-nav__link">
        Python语法技巧
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../python/fabric/" class="md-nav__link">
        远程部署神器 Fabric
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_4" >
      
      
      
        <label class="md-nav__link" for="__nav_2_4" id="__nav_2_4_label" tabindex="0">
          Go
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_2_4_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_2_4">
          <span class="md-nav__icon md-icon"></span>
          Go
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../go/go_base/" class="md-nav__link">
        Go基础语法
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_5" >
      
      
      
        <label class="md-nav__link" for="__nav_2_5" id="__nav_2_5_label" tabindex="0">
          PHP
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_2_5_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_2_5">
          <span class="md-nav__icon md-icon"></span>
          PHP
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../php/kj/" class="md-nav__link">
        框架
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_6" >
      
      
      
        <label class="md-nav__link" for="__nav_2_6" id="__nav_2_6_label" tabindex="0">
          Web
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_2_6_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_2_6">
          <span class="md-nav__icon md-icon"></span>
          Web
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../web/es6/" class="md-nav__link">
        es6语法
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../web/ali_js_style/" class="md-nav__link">
        阿里js样式规范
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../web/node.js/" class="md-nav__link">
        node.js文档
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../web/react/" class="md-nav__link">
        React 开发者指南
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../dart/syntax/" class="md-nav__link">
        Dart语法学习
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../web/react_interview/" class="md-nav__link">
        React 面试
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../web/js_tool_method/" class="md-nav__link">
        js 工具函数
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../web/vue_cp_react/" class="md-nav__link">
        vue与react比较
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../web/javascript/" class="md-nav__link">
        JavaScript 基础
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_7" >
      
      
      
        <label class="md-nav__link" for="__nav_2_7" id="__nav_2_7_label" tabindex="0">
          SQL
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_2_7_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_2_7">
          <span class="md-nav__icon md-icon"></span>
          SQL
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../sql/mysql_yh/" class="md-nav__link">
        MySQL优化
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../sql/mysql_yh17/" class="md-nav__link">
        MySQL优化
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../sql/mysql_log/" class="md-nav__link">
        MySQL日志
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../sql/mysql_index/" class="md-nav__link">
        MySQL索引
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../sql/mysql_pxc/" class="md-nav__link">
        MySQL PXC集群
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../sql/mysql_use/" class="md-nav__link">
        MySQL 数据库应用
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../sql/mysql_backups/" class="md-nav__link">
        MySql 备份
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../sql/sql_server_master/" class="md-nav__link">
        Sql Server 主从备份
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../sql/data_split/" class="md-nav__link">
        数据库之互联网常用分库分表方案
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../sql/mybatis/" class="md-nav__link">
        Mybatis使用心德
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
    
  
  
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_8" checked>
      
      
      
        <label class="md-nav__link" for="__nav_2_8" id="__nav_2_8_label" tabindex="0">
          Linux
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_2_8_label" aria-expanded="true">
        <label class="md-nav__title" for="__nav_2_8">
          <span class="md-nav__icon md-icon"></span>
          Linux
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
    
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          Linux学习笔记
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        Linux学习笔记
      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    一、 常用命令
  </a>
  
    <nav class="md-nav" aria-label="一、 常用命令">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#linux_1" class="md-nav__link">
    LINUX 常用操作命令和命令行编辑快捷键
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    终端快捷键：
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#gnome" class="md-nav__link">
    gnome 快捷键
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    窗口操作快捷键
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    文件浏览器
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_5" class="md-nav__link">
    关机和重启命令
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#grep" class="md-nav__link">
    grep 和管道符
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_6" class="md-nav__link">
    二、 磁盘管理
  </a>
  
    <nav class="md-nav" aria-label="二、 磁盘管理">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_7" class="md-nav__link">
    文件系统配置文件
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#linux_2" class="md-nav__link">
    linux 文件类型的颜色
  </a>
  
    <nav class="md-nav" aria-label="linux 文件类型的颜色">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#----------" class="md-nav__link">
    蓝色文件----------目录
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#----------_1" class="md-nav__link">
    白色文件----------一般性文件，如文本文件，配置文件，源码文件等
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_8" class="md-nav__link">
    文件系统操作命令
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#df" class="md-nav__link">
    df ：列出文件系统的整体磁盘使用情况
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#du" class="md-nav__link">
    du ：列出目录所占空间
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dumpe2fs" class="md-nav__link">
    dumpe2fs ：显示当前的磁盘状态
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ln" class="md-nav__link">
    ln ：连接文件（快捷方式）
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fdisk" class="md-nav__link">
    Fdisk
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#parted_2t" class="md-nav__link">
    Parted ： 2T 以上磁盘分区工具
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../often/" class="md-nav__link">
        常用命令
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../ope/" class="md-nav__link">
        实用的Linux 命令
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_9" >
      
      
      
        <label class="md-nav__link" for="__nav_2_9" id="__nav_2_9_label" tabindex="0">
          Docker
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_2_9_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_2_9">
          <span class="md-nav__icon md-icon"></span>
          Docker
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../docker/docker/" class="md-nav__link">
        Docker全科
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../docker/docker-compose/" class="md-nav__link">
        docker和docker-compose配置常用环境
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../docker/docker-jenkins/" class="md-nav__link">
        Docker部署Jenkins
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../docker/docker-phabricator/" class="md-nav__link">
        Docker部署Phabricator
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_10" >
      
      
      
        <label class="md-nav__link" for="__nav_2_10" id="__nav_2_10_label" tabindex="0">
          Tool
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_2_10_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_2_10">
          <span class="md-nav__icon md-icon"></span>
          Tool
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../tool/git/" class="md-nav__link">
        Git
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../tool/gitusual/" class="md-nav__link">
        Git动画展示
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../tool/gitquestion/" class="md-nav__link">
        Git问题处理
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../tool/gitflow/" class="md-nav__link">
        GitFlow
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../tool/gitbook/" class="md-nav__link">
        GitBook
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../tool/gitcmr/" class="md-nav__link">
        Git提交日志规范
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../tool/markdown/" class="md-nav__link">
        Markdown
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../tool/cicd/" class="md-nav__link">
        CI/CD
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../tool/mkdocs/" class="md-nav__link">
        mkdocs简单使用
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../tool/gitstudy/" class="md-nav__link">
        Git的黑魔法
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../tool/minio/" class="md-nav__link">
        MinIO 搭建使用
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../tool/cat-monitoring/" class="md-nav__link">
        Cat分布式监控
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3" >
      
      
      
        <label class="md-nav__link" for="__nav_3" id="__nav_3_label" tabindex="0">
          云架构
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_3">
          <span class="md-nav__icon md-icon"></span>
          云架构
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../cloud/native/" class="md-nav__link">
        云原生
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../cloud/virtual/" class="md-nav__link">
        虚拟化技术
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../cloud/compute/" class="md-nav__link">
        云计算
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../cloud/apprelease/" class="md-nav__link">
        应用部署容器化演进
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../cloud/containerlinux/" class="md-nav__link">
        容器技术所涉及Linux内核关键技术
      </a>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_6" >
      
      
      
        <label class="md-nav__link" for="__nav_3_6" id="__nav_3_6_label" tabindex="0">
          Docker
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_3_6_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_3_6">
          <span class="md-nav__icon md-icon"></span>
          Docker
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../cloud/docker/docker_native/" class="md-nav__link">
        容器管理工具Docker生态架构及部署
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../cloud/docker/docker_nginx/" class="md-nav__link">
        使用容器运行Nginx应用及Docker命令
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../cloud/docker/docker_image/" class="md-nav__link">
        Docker容器镜像
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../cloud/docker/docker_image_fast/" class="md-nav__link">
        Docker容器镜像加速器及本地容器镜像仓库
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../cloud/docker/docker_container_enterprice/" class="md-nav__link">
        Docker容器化部署企业级应用集群
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../cloud/docker/docker_file/" class="md-nav__link">
        Dockerfile精讲及新型容器镜像构建技术
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../cloud/docker/docker_network/" class="md-nav__link">
        Docker容器网络与通信原理深度解析
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../cloud/docker/docker_date/" class="md-nav__link">
        Docker容器数据持久化存储机制
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../cloud/docker/docker_compose/" class="md-nav__link">
        Docker容器服务编排利器Docker Compose应用实战
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../cloud/docker/docker_swarm/" class="md-nav__link">
        Docker主机集群化方案 Docker Swarm
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../cloud/docker/docker_devops/" class="md-nav__link">
        基于Docker容器DevOps应用方案 企业业务代码发布系统
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../cloud/docker/docker_container/" class="md-nav__link">
        轻量级或工业级容器管理工具
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_7" >
      
      
      
        <label class="md-nav__link" for="__nav_3_7" id="__nav_3_7_label" tabindex="0">
          Kubernetes
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_3_7_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_3_7">
          <span class="md-nav__icon md-icon"></span>
          Kubernetes
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../cloud/kubernetes/" class="md-nav__link">
        kubeadm极速部署Kubernetes
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../cloud/kubernetes/kubernetes_introduce/" class="md-nav__link">
        kubernetes介绍与集群架构
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../cloud/kubernetes/kubernetes_way/" class="md-nav__link">
        Kubernetes集群部署方式说明
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../cloud/kubernetes/kubernetes_master/" class="md-nav__link">
        kubeadm部署单Master节点kubernetes集群
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../cloud/kubernetes/kubernetes_hight/" class="md-nav__link">
        kubeadm部署高可用kubernetes集群
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../cloud/kubernetes/kubernetes_rke/" class="md-nav__link">
        使用RKE构建企业生产级Kubernetes集群
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../cloud/kubernetes/kubernetes_hight_bin1/" class="md-nav__link">
        Kubernetes高可用集群二进制部署（Runtime Docker）一
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../cloud/kubernetes/kubernetes_hight_bin2/" class="md-nav__link">
        Kubernetes高可用集群二进制部署（Runtime Docker）二
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../cloud/kubernetes/kubernetes_ui/" class="md-nav__link">
        Kubernetes集群UI及主机资源监控
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../cloud/kubernetes/kubernetes_sealos/" class="md-nav__link">
        使用sealos部署kubernetes集群并实现集群管理
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../cloud/kubernetes/kubernetes_cluster/" class="md-nav__link">
        kubernetes集群命令语法
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../cloud/kubernetes/kubernetes_core/" class="md-nav__link">
        Kubernetes核心概念
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../cloud/kubernetes/kubernetes_nginx_ingress_controller/" class="md-nav__link">
        Kubernetes集群 服务暴露 Nginx Ingress Controller
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../cloud/kubernetes/kubernetes_traefik/" class="md-nav__link">
        Kubernetes集群 服务暴露 Traefik
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../cloud/kubernetes/kubernetes_configMap_secret/" class="md-nav__link">
        Kubernetes配置与密钥管理 ConfigMap&Secret
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../cloud/kubernetes/kubernetes_harbor/" class="md-nav__link">
        Kubernetes集群使用容器镜像仓库Harbor
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../cloud/kubernetes/kubernetes_safety/" class="md-nav__link">
        Kubernetes集群安全管理
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../cloud/kubernetes/kubernetes_storage_volume/" class="md-nav__link">
        kubernetes持久化存储卷
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../cloud/kubernetes/kubernetes_storage_ceph/" class="md-nav__link">
        kubernetes存储解决方案Ceph
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../cloud/kubernetes/kubernetes_cluster_serve/" class="md-nav__link">
        Kubernetes集群公共服务
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../cloud/kubernetes/kubernetes_deploy_java/" class="md-nav__link">
        kubernetes集群java项目上云部署
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../cloud/kubernetes/kubernetes_deploy_python/" class="md-nav__link">
        kubernetes集群Python项目上云部署
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../cloud/kubernetes/kubernetes_deploy_golang/" class="md-nav__link">
        Kubernetes集群golang项目上云部署
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../cloud/kubernetes/kubernetes_logs_collect/" class="md-nav__link">
        kubernetes日志收集方案
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../cloud/kubernetes/kubernetes_ui/" class="md-nav__link">
        源监控
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../cloud/kubernetes/kubernetes_ui/" class="md-nav__link">
        源监控
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../cloud/kubernetes/kubernetes_ui/" class="md-nav__link">
        源监控
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../cloud/kubernetes/kubernetes_ui/" class="md-nav__link">
        源监控
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../cloud/kubernetes/kubernetes_ui/" class="md-nav__link">
        源监控
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../cloud/kubernetes/kubernetes_ui/" class="md-nav__link">
        源监控
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../cloud/kubernetes/kubernetes_ui/" class="md-nav__link">
        源监控
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../cloud/kubernetes/kubernetes_ui/" class="md-nav__link">
        源监控
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../cloud/kubernetes/kubernetes_ui/" class="md-nav__link">
        源监控
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../cloud/kubernetes/kubernetes_ui/" class="md-nav__link">
        源监控
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4" >
      
      
      
        <label class="md-nav__link" for="__nav_4" id="__nav_4_label" tabindex="0">
          微服务
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_4_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_4">
          <span class="md-nav__icon md-icon"></span>
          微服务
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../micro/fbs-lock/" class="md-nav__link">
        分布式锁
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../micro/design/" class="md-nav__link">
        微服务设计
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../micro/distrimsg/" class="md-nav__link">
        分布式系统与消息的投递
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../micro/ddd/" class="md-nav__link">
        基于DDD的微服务设计和开发实战
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../micro/kafka/" class="md-nav__link">
        Kafka架构原理
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../micro/redis_cluster/" class="md-nav__link">
        Redis Cluster原理
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../micro/spring-cloud-micro/" class="md-nav__link">
        分布式架构
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_5" >
      
      
      
        <label class="md-nav__link" for="__nav_5" id="__nav_5_label" tabindex="0">
          经验分析
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_5_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_5">
          <span class="md-nav__icon md-icon"></span>
          经验分析
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../exp/devops/" class="md-nav__link">
        DevOps
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../exp/micro-service/" class="md-nav__link">
        Micro-Service
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../exp/raft-gossip/" class="md-nav__link">
        Raft算法和Gossip协议
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../exp/cl/" class="md-nav__link">
        集群和负载均衡
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../exp/ai/" class="md-nav__link">
        人工智能
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../exp/code-principle/" class="md-nav__link">
        代码原则
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../exp/techbig/" class="md-nav__link">
        如何成为技术大牛
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../exp/learnweetout/" class="md-nav__link">
        程序员如何技术成长
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../exp/pt/" class="md-nav__link">
        产品与技术
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../exp/four_deep_learning/" class="md-nav__link">
        深度学习框架
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../exp/tl/" class="md-nav__link">
        在阿里做了5年技术Leader，我总结出这些套路！
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../exp/cto/" class="md-nav__link">
        CTO 技能图谱
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_6" >
      
      
      
        <label class="md-nav__link" for="__nav_6" id="__nav_6_label" tabindex="0">
          构架
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_6_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_6">
          <span class="md-nav__icon md-icon"></span>
          构架
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../framework/split/" class="md-nav__link">
        构架拆分
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../framework/fgb/" class="md-nav__link">
        分布式、高并发、多线程
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../framework/agility/" class="md-nav__link">
        如何理解敏捷开发
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../framework/fwork/" class="md-nav__link">
        走向架构师必备的技能
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../framework/data_middle/" class="md-nav__link">
        数据中台的思考与总结
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../framework/algorithm-ten/" class="md-nav__link">
        必学的 10 大算法
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_7" >
      
      
      
        <label class="md-nav__link" for="__nav_7" id="__nav_7_label" tabindex="0">
          情感
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_7_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_7">
          <span class="md-nav__icon md-icon"></span>
          情感
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../emotion/eq/" class="md-nav__link">
        情商
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../emotion/workheard/" class="md-nav__link">
        工作心得
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../emotion/lookbook/" class="md-nav__link">
        看书
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../emotion/selfdiscipline/" class="md-nav__link">
        自律
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../emotion/livefail/" class="md-nav__link">
        为什么活着失败
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../emotion/emotion/" class="md-nav__link">
        情绪管理
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../emotion/losecome/" class="md-nav__link">
        所有的失去，都会以另一种方式归来
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../emotion/threeheart/" class="md-nav__link">
        人生有这三种好心态
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../emotion/onepath/" class="md-nav__link">
        余生，学会一个人走，不管有没有人陪
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../emotion/twopath/" class="md-nav__link">
        往后余生还很精彩，别被熬夜拖垮了
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../emotion/lifetime/" class="md-nav__link">
        心态好的人，一辈子都好
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    一、 常用命令
  </a>
  
    <nav class="md-nav" aria-label="一、 常用命令">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#linux_1" class="md-nav__link">
    LINUX 常用操作命令和命令行编辑快捷键
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    终端快捷键：
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#gnome" class="md-nav__link">
    gnome 快捷键
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    窗口操作快捷键
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    文件浏览器
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_5" class="md-nav__link">
    关机和重启命令
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#grep" class="md-nav__link">
    grep 和管道符
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_6" class="md-nav__link">
    二、 磁盘管理
  </a>
  
    <nav class="md-nav" aria-label="二、 磁盘管理">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_7" class="md-nav__link">
    文件系统配置文件
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#linux_2" class="md-nav__link">
    linux 文件类型的颜色
  </a>
  
    <nav class="md-nav" aria-label="linux 文件类型的颜色">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#----------" class="md-nav__link">
    蓝色文件----------目录
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#----------_1" class="md-nav__link">
    白色文件----------一般性文件，如文本文件，配置文件，源码文件等
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_8" class="md-nav__link">
    文件系统操作命令
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#df" class="md-nav__link">
    df ：列出文件系统的整体磁盘使用情况
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#du" class="md-nav__link">
    du ：列出目录所占空间
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dumpe2fs" class="md-nav__link">
    dumpe2fs ：显示当前的磁盘状态
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ln" class="md-nav__link">
    ln ：连接文件（快捷方式）
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fdisk" class="md-nav__link">
    Fdisk
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#parted_2t" class="md-nav__link">
    Parted ： 2T 以上磁盘分区工具
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  

  
  


<h1 id="linux">Linux 学习笔记<a class="headerlink" href="#linux" title="Permanent link">&para;</a></h1>
<h2 id="_1">一、 常用命令<a class="headerlink" href="#_1" title="Permanent link">&para;</a></h2>
<h4 id="linux_1">LINUX 常用操作命令和命令行编辑快捷键<a class="headerlink" href="#linux_1" title="Permanent link">&para;</a></h4>
<h4 id="_2">终端快捷键：<a class="headerlink" href="#_2" title="Permanent link">&para;</a></h4>
<div class="highlight"><pre><span></span><code>Ctrl + a/Home 切换到命令行开始
Ctrl + e/End 切换到命令行末尾
Ctrl + l 清除屏幕内容，效果等同于clear
Ctrl + u 清除剪切光标之前的内容
Ctrl + k 剪切清除光标之后的内容
Ctrl + y 粘贴刚才所删除的字符
Ctrl + r 在历史命令中查找 （这个非常好用，输入关键字就调出以前的命令了）
Ctrl + c 终止命令
ctrl + o 重复执行命令
Ctrl + d 退出shell，logout
Ctrl + z 转入后台运行,但在当前用户退出后就会终止
Ctrl + t 颠倒光标所在处及其之前的字符位置，并将光标移动到下一个字符
Alt + t 交换当前与以前单词的位置
Alt + d 剪切光标之后的词
Ctrl+w 剪切光标所在处之前的一个词（以空格、标点等为分隔符）
Ctrl+（x u） 按住Ctrl的同时再先后按x和u，撤销刚才的操作
Ctrl+s 锁住终端
Ctrl+q 解锁终端
!! 重复执行最后一条命令
history 显示你所有执行过的编号+历史命令。这个可以配合!编辑来执行某某命令
!$ 显示系统最近的一条参数
最后这个比较有用，比如我先用cat /etc/sysconfig/network-scripts/ifconfig-eth0，然后我想用vim编辑。
一般的做法是先用↑ 显示最后一条命令，然后用Home移动到命令最前，删除cat，然后再输入vim命
令。其实完全可以用vim !$来代替。
</code></pre></div>
<h4 id="gnome">gnome 快捷键<a class="headerlink" href="#gnome" title="Permanent link">&para;</a></h4>
<div class="highlight"><pre><span></span><code>Alt + F1 类似Windows下的Win键，在GNOME中打开&quot;应用程序&quot;菜单(Applications)
Alt + F2 类似Windows下的Win + R组合键，在GNOME中运行应用程序
Ctrl + Alt + D 类似Windows下的Win + D组合键，显示桌面
Ctrl + Alt + L 锁定桌面并启动屏幕保护程序
Alt + Tab 同Windows下的Alt + Tab组合键，在不同程序窗口间切换
PrintScreen 全屏抓图
Alt + PrintScreen 当前窗口抓图
Ctrl + Alt + → / ← 在不同工作台间切换
Ctrl + Alt + Shift + → / ← 移动当前窗口到不同工作台
Ctrl+Alt+Fn 终端N或模拟终端N(n和N为数字 1 －6)
</code></pre></div>
<div class="highlight"><pre><span></span><code>Ctrl+Alt+F7 返回桌面
</code></pre></div>
<h4 id="_3">窗口操作快捷键<a class="headerlink" href="#_3" title="Permanent link">&para;</a></h4>
<div class="highlight"><pre><span></span><code>Alt + F4 关闭窗口
Alt + F5 取消最大化窗口 (恢复窗口原来的大小)
Alt + F7 移动窗口 (注: 在窗口最大化的状态下无效)
Alt + F8 改变窗口大小 (注: 在窗口最大化的状态下无效)
Alt + F9 最小化窗口
Alt + F10 最大化窗口
Alt + 空格键 打开窗口的控制菜单 (点击窗口左上角图标出现的菜单）
</code></pre></div>
<h4 id="_4">文件浏览器<a class="headerlink" href="#_4" title="Permanent link">&para;</a></h4>
<div class="highlight"><pre><span></span><code>Ctrl+N 新建窗口
Ctrl + Shift + W 关闭所有文件浏览器
Ctrl + 1/2 改变文件夹视图查看方式，图标视图/列表视图
Alt + → / ← 后退/前进
Alt + ↑/↓ 移动到父文件夹/选择的文件夹
Alt + Home 直接移动到主文件夹
F9 开关显示隐藏Nautilus侧边栏
Ctrl+H 显示隐藏文件（切换键）
Shift+Ctrl+N 新建文件夹， 很有用
Alt + Enter 查看选择文件/文件夹的属性，代替单击右键选择属性
Ctrl+Page Up 上一个标签
Ctrl+Page Down 下一个标签
Alt+N 切换到第N个标签（N为数字）
</code></pre></div>
<h4 id="_5">关机和重启命令<a class="headerlink" href="#_5" title="Permanent link">&para;</a></h4>
<p>Shutdown
Reboot
Halt
poweroff</p>
<h4 id="grep">grep 和管道符<a class="headerlink" href="#grep" title="Permanent link">&para;</a></h4>
<div class="highlight"><pre><span></span><code>昨天的时候leader给我出了道问题：
找出文件夹下包含 “aaa” 同时不包含 “bbb”的文件，然后把他们重新生成一下。要求只能用一行命令。
我对Linux 是个白痴，工作了之后才开始接触的，会用的命令只有那几个常用的。这个问题对我来说就有
点难度，我只是大概知道查找文件用 grep ，其他的就不知道了。不过没关系，用Google ，查找到 grep
的完整用法：
1 、grep -l ‘boss’ * 显示所有包含boss的文件名。
2 、grep -n ‘boss’ file在匹配行之前加行号。
3 、grep -i ‘boss’ file显示匹配行，boss不区分大小写。
4 、grep -v ‘boss’ file显示所有不匹配行。
5 、grep -q ‘boss’ file找到匹配行，但不显示，但可以检查grep的退出状态。（ 0 为匹配成功）
6 、grep -c ‘boss’ file只显示匹配行数（包括 0 ）。
</code></pre></div>
<div class="highlight"><pre><span></span><code>7 、grep “$boss” file扩展变量boss的值再执行命令。
8 、ps -ef|grep “^*user1′′ 搜索user1的命令，即使它前面有零个或多个空格。
9 、ps -e|grep -E ‘grant_server|commsvr|tcpsvr|dainfo’ 查找多个字符串的匹配（grep -E相当于egrep）
（来源：蓝森林）
了解了grep的参数之后，问题就解决了一半了，因为可以搜索出符合条件的文件了。不过光有grep 还是
不行，因为要把搜索出来的文件名作为参数传给 generate 命令。OK，接下来该管道符出场了。
即使是像我这样对Linux只是有一点了解的人也经常用到管道符，比如“|”，示例： ls -a | more 。但是对
于管道符的具体意义和它做了什么我就不知道了，没关系，Google 一下，找到一些资料：
利用 Linux 所提供的管道符 “|” 将两个命令隔开，管道符左边命令的输出就会作为管道符右边命令的输入。
连续使用管道意味着第一个命令的输出会作为第二个命令的输入，第二个命令的输出又会作为第三个命
令的输入，依此类推。
所以查找的时候可以这样写：
grep -rl “aaa” * | grep -v “bbb”
这样右边的命令就可以从前面的结果中筛选了。然后还有 generate 命令，因为生成文件的命令格式是这
样的：
generate 文件名
不过如果直接使用 generate grep -rl “aaa” * | grep -v “bbb” 的话会出错，因为命令会从左向右执行，这条
命令就会把grep作为一个文件名来看待。怎么办呢？这个时候就要使用 · (键盘上数字键 1 旁边的那个符
号，和“~”在一个按键上)来做命令替换了，用 · 把后面的 grep 命令包起来就好了，这样：
generate ·grep -rl “aaa” * | grep -v “bbb”·
然后就搞定了。
工作一段时间之后，越来越喜欢Linux的哲学了，它有很多命令，看起来功能都不是那么强劲，但是如果
你开动脑筋把这些命令组合起来的话，就能实现 很多让你意想不到的功能，有时候你忍不住惊呼：实在
是太coooool了！ 这对于像我这种被Windows的傻瓜式操作惯坏了的人来说，是个福音，以后要多多开
动生锈了的大脑。如果单纯使用电脑的话，还是Windows好 用 ，但 是对于程序员，最好还是多玩玩 Linux。
BTW，现在也越来越喜欢使用VIM 了，虽然刚开始用的时候就觉得它是个记事本~囧~~ 以前总听说“真正
的牛人编码都是用记事本编写的”，当时就觉得这些人实在太厉害了，代码提示和自动补全都不用，现在
想想，可能是外行看到他们使用灵活+强 大的VIM或者 EMACS 了吧。^_^
我的补充:
查找包含logField又包含open的文件：
用grep &quot;logFileId&quot; *.tbc|grep &quot;open&quot;
</code></pre></div>
<h2 id="_6">二、 磁盘管理<a class="headerlink" href="#_6" title="Permanent link">&para;</a></h2>
<h4 id="_7">文件系统配置文件<a class="headerlink" href="#_7" title="Permanent link">&para;</a></h4>
<p>/etc/filesystems：系统指定的测试挂载文件系统类型
/proc/filesystems：Linux系统已经加载的文件系统类型
/lib/modules/2.6.18-274.el5/kernel/fs/ 文件系统类型的驱动所在目录
/etc/fstab
/etc/mtab</p>
<h4 id="linux_2">linux 文件类型的颜色<a class="headerlink" href="#linux_2" title="Permanent link">&para;</a></h4>
<p>linux文件颜色的含义：蓝色代表目录绿色代表可执行文件 红色表示压缩文件 浅蓝色表示链接文件 灰
色表示其他文件 红色闪烁表示链接的文件有问题了 黄色表示设备文件</p>
<h5 id="----------">蓝色文件----------目录<a class="headerlink" href="#----------" title="Permanent link">&para;</a></h5>
<h5 id="----------_1">白色文件----------一般性文件，如文本文件，配置文件，源码文件等<a class="headerlink" href="#----------_1" title="Permanent link">&para;</a></h5>
<p>浅蓝色文件----------链接文件，主要是使用ln命令建立的文件
绿色文件----------可执行文件，可执行的程序
红色文件-----------压缩文件或者包文件
Linux下用字符表示的文件类型</p>
<ul>
<li>：普通文件
d：目录文件
l：链接文件
b：块设备文件
c：字符设备文件
p：管道文件</li>
</ul>
<h4 id="_8">文件系统操作命令<a class="headerlink" href="#_8" title="Permanent link">&para;</a></h4>
<h4 id="df">df ：列出文件系统的整体磁盘使用情况<a class="headerlink" href="#df" title="Permanent link">&para;</a></h4>
<p>[root@centos57 ~]# df -h
文件系统 容量 已用 可用 已用% 挂载点
/dev/mapper/VolGroup00-LogVol
16G 4.2G 11G 28% /
/dev/sda1 99M 13M 81M 14% /boot
tmpfs 1005M 0 1005M 0% /dev/shm
[root@centos57 ~]# df -i
文件系统 Inode (I)已用 (I)可用 (I)已用% 挂载点
/dev/mapper/VolGroup00-LogVol
4186112 154441 4031671 4% /
/dev/sda1 26104 36 26068 1% /boot
tmpfs 257210 1 257209 1% /dev/shm
.host:/ 0 0 0 - /mnt/hgfs</p>
<h4 id="du">du ：列出目录所占空间<a class="headerlink" href="#du" title="Permanent link">&para;</a></h4>
<p>du -sh 显示当前目录大小
du –sh / 显示/目录下的所有目录大小</p>
<h4 id="dumpe2fs">dumpe2fs ：显示当前的磁盘状态<a class="headerlink" href="#dumpe2fs" title="Permanent link">&para;</a></h4>
<h4 id="ln">ln ：连接文件（快捷方式）<a class="headerlink" href="#ln" title="Permanent link">&para;</a></h4>
<p>ln –sf 源文件 目标文件
不加任何参数就进行连接，就是hard link，加 上 -s就是Symbolic link，hard link不支持目录和跨文件系统。</p>
<h4 id="fdisk">Fdisk<a class="headerlink" href="#fdisk" title="Permanent link">&para;</a></h4>
<p>Fdisk不支持大于2T的磁盘
Fdisk –l 显示系统中的所有分区内容
<strong>[root@centos57 ~]# fdisk -l</strong>
Disk /dev/sda: 21.4 GB, 21474836480 bytes
255 heads, 63 sectors/track, 2610 cylinders 总扇区数，可以和下面的最后扇区数比较，看剩余</p>
<p>Units = cylinders of 16065 * 512 = 8225280 bytes
Device Boot Start End Blocks Id System
/dev/sda1 * 1 13 104391 83 Linux
/dev/sda2 14 2610 20860402+ 8e Linux LVM
<strong>[root@centos57 ~]# fdisk /dev/sda</strong></p>
<h4 id="parted_2t">Parted ： 2T 以上磁盘分区工具<a class="headerlink" href="#parted_2t" title="Permanent link">&para;</a></h4>
<p>支持大于2T的磁盘 ，2T以下的最好还是用Fdisk来分区。
[root@centos57 aixi]# parted /dev/hda print
Model: VMware Virtual IDE Hard Drive (ide)
Disk /dev/hda: 2147MB
Sector size (logical/physical): 512B/512B
Partition Table: msdos
Number Start End Size Type File system 标志
1 32.3kB 101MB 101MB 主分区 ext
<strong>2</strong> 101MB 357MB 256MB 主分区 linux-swap</p>
<h1 id="parted_devhda_rm_2_2">parted /dev/hda rm <strong>2</strong> 删除第 <strong>2</strong> 个分区<a class="headerlink" href="#parted_devhda_rm_2_2" title="Permanent link">&para;</a></h1>
<p><strong># parted /dev/hda mkpart primary ext3 120MB 200MB</strong> 创建分区， <strong>primary</strong> 代表主分区，还可以是
<strong>extended</strong> 扩展分区， <strong>logical</strong> 逻辑分区 <strong>;ext3</strong> 代表分区类型， <strong>120MB</strong> 是开始位置，最好是接上一分区的结束位
置， <strong>200M</strong> 是结束位置</p>
<h4 id="partprobe">partprobe : 更新分区表 / 磁盘<a class="headerlink" href="#partprobe" title="Permanent link">&para;</a></h4>
<p>用于重读分区表，当出现删除文件后,出现仍然占用空间。可以partprobe在不重启的情况下重读分区</p>
<h1 id="partprobe_1">partprobe<a class="headerlink" href="#partprobe_1" title="Permanent link">&para;</a></h1>
<p>这个命令执行完毕之后不会输出任何返回信息，你可以使用mke2fs命令在新的分区上创建文件系统。</p>
<h4 id="mkfs">Mkfs: 磁盘格式化<a class="headerlink" href="#mkfs" title="Permanent link">&para;</a></h4>
<p><strong>Mkfs –t</strong> 文件系统格式 设备文件名（盘符）
[root@centos57 ~]# mkfs -t ext3 /dev/hda</p>
<h4 id="e2label">e2label ：设置磁盘卷标<a class="headerlink" href="#e2label" title="Permanent link">&para;</a></h4>
<p>e2label 设备名称 新label名称，可以用dumpe2fs查看卷标
[root@centos57 ~]# e2label /dev/hda1 aixi</p>
<h4 id="mount">Mount: 挂载磁盘<a class="headerlink" href="#mount" title="Permanent link">&para;</a></h4>
<h5 id="_9">命令格式：<a class="headerlink" href="#_9" title="Permanent link">&para;</a></h5>
<p>mount [-t vfstype] [-o options] device dir
<strong>mount –o remount,rw,auto /</strong> 重新挂载
<strong>mount –n –o remount,rw /</strong> 重新挂载根目录，设置为可读写
其中：</p>
<ol>
<li>-t vfstype 指定文件系统的类型，通常不必指定。mount 会自动选择正确的类型。常用类型有：
光盘或光盘镜像：iso
DOS fat16文件系统：msdos
Windows 9x fat32文件系统：vfat
Windows NT ntfs文件系统：ntfs
Mount Windows文件网络共享：smbfs</li>
</ol>
<p>UNIX(LINUX) 文件网络共享：nfs</p>
<ol>
<li>-o options 主要用来描述设备或档案的挂接方式。常用的参数有：
loop：用来把一个文件当成硬盘分区挂接上系统
ro：采用只读方式挂接设备
rw：采用读写方式挂接设备
iocharset：指定访问文件系统所用字符集
3.device 要挂接(mount)的设备。
4.dir设备在系统上的挂接点(mount point)。</li>
</ol>
<p>挂接光盘镜像文件</p>
<p>1 、从光盘制作光盘镜像文件。将光盘放入光驱，执行下面的命令。</p>
<h1 id="cp_devcdrom_homesunkymydiskiso">cp /dev/cdrom /home/sunky/mydisk.iso 或<a class="headerlink" href="#cp_devcdrom_homesunkymydiskiso" title="Permanent link">&para;</a></h1>
<h1 id="dd_ifdevcdrom_ofhomesunkymydiskiso">dd if=/dev/cdrom of=/home/sunky/mydisk.iso<a class="headerlink" href="#dd_ifdevcdrom_ofhomesunkymydiskiso" title="Permanent link">&para;</a></h1>
<p>注：执行上面的任何一条命令都可将当前光驱里的光盘制作成光盘镜像文件/home/sunky/mydisk.iso
2 、将文件和目录制作成光盘镜像文件，执行下面的命令。</p>
<h1 id="mkisofs_-r_-j_-v_mydisk_-o_homesunkymydiskiso_homesunky_mydir">mkisofs -r -J -V mydisk -o /home/sunky/mydisk.iso /home/sunky/ mydir<a class="headerlink" href="#mkisofs_-r_-j_-v_mydisk_-o_homesunkymydiskiso_homesunky_mydir" title="Permanent link">&para;</a></h1>
<p>注：这条命令将/home/sunky/mydir目录下所有的目录和文件制作成光盘镜像文件
/home/sunky/mydisk.iso，光盘卷标为：mydisk
3 、光盘镜像文件的挂接(mount)</p>
<h1 id="mkdir_mntvcdrom">mkdir /mnt/vcdrom<a class="headerlink" href="#mkdir_mntvcdrom" title="Permanent link">&para;</a></h1>
<p>注：建立一个目录用来作挂接点(mount point)
<strong>#mount -o loop -t iso9660 /home/sunky/mydisk.iso /mnt/vcdrom</strong>
注：使用/mnt/vcdrom就可以访问盘镜像文件mydisk.iso里的所有文件了。</p>
<h5 id="_10">挂接移动硬盘<a class="headerlink" href="#_10" title="Permanent link">&para;</a></h5>
<p>对linux系统而言，USB接口的移动硬盘是当作SCSI设备对待的。插入移动硬盘之前，应先用fdisk –l 或
more /proc/partitions查看系统的硬盘和硬盘分区情况。
[root at pldyrouter /]# fdisk -l
Disk /dev/sda: 73 dot 4 GB, 73407820800 bytes
255 heads, 63 sectors/track, 8924 cylinders
Units = cylinders of 16065 * 512 = 8225280 bytes
Device Boot Start End Blocks Id System
/dev/sda1 1 4 32098+ de Dell Utility
/dev/sda2 * 5 2554 20482875 7 HPFS/NTFS
/dev/sda3 2555 7904 42973875 83 Linux
/dev/sda4 7905 8924 8193150 f Win95 Ext'd (LBA)
/dev/sda5 7905 8924 8193118+ 82 Linux swap
在这里可以清楚地看到系统有一块SCSI硬盘/dev/sda和它的四个磁盘分区/dev/sda1 -- /dev/sda4,
/dev/sda5是分区/dev/sda4的逻辑分区。接好移动硬盘后，再用fdisk –l 或 more /proc/partitions查看系统
的硬盘和硬盘分区情况
[root at pldyrouter /]# fdisk -l
Disk /dev/sda: 73 dot 4 GB, 73407820800 bytes
255 heads, 63 sectors/track, 8924 cylinders
Units = cylinders of 16065 * 512 = 8225280 bytes</p>
<p>Device Boot Start End Blocks Id System
/dev/sda1 1 4 32098+ de Dell Utility
/dev/sda2 * 5 2554 20482875 7 HPFS/NTFS
/dev/sda3 2555 7904 42973875 83 Linux
/dev/sda4 7905 8924 8193150 f Win95 Ext'd (LBA)
/dev/sda5 7905 8924 8193118+ 82 Linux swap
Disk /dev/sdc: 40.0 GB, 40007761920 bytes
255 heads, 63 sectors/track, 4864 cylinders
Units = cylinders of 16065 * 512 = 8225280 bytes
Device Boot Start End Blocks Id System
/dev/sdc1 1 510 4096543+ 7 HPFS/NTFS
/dev/sdc2 511 4864 34973505 f Win95 Ext'd (LBA)
/dev/sdc5 511 4864 34973473+ b Win95 FAT
大家应该可以发现多了一个SCSI硬盘/dev/sdc和它的两个磁盘分区/dev/sdc1?、/dev/sdc2,其中/dev/sdc
是/dev/sdc2分区的逻辑分区。我们可以使用下面的命令挂接/dev/sdc1和/dev/sdc5。</p>
<h1 id="mkdir_-p_mntusbhd">mkdir -p /mnt/usbhd<a class="headerlink" href="#mkdir_-p_mntusbhd" title="Permanent link">&para;</a></h1>
<h1 id="mkdir_-p_mntusbhd_1">mkdir -p /mnt/usbhd<a class="headerlink" href="#mkdir_-p_mntusbhd_1" title="Permanent link">&para;</a></h1>
<p>注：建立目录用来作挂接点(mount point)</p>
<h1 id="mount_-t_ntfs_devsdc1_mntusbhd">mount -t ntfs /dev/sdc1 /mnt/usbhd<a class="headerlink" href="#mount_-t_ntfs_devsdc1_mntusbhd" title="Permanent link">&para;</a></h1>
<h1 id="mount_-t_vfat_devsdc5_mntusbhd">mount -t vfat /dev/sdc5 /mnt/usbhd<a class="headerlink" href="#mount_-t_vfat_devsdc5_mntusbhd" title="Permanent link">&para;</a></h1>
<p>注：对ntfs格式的磁盘分区应使用-t ntfs 参数，对fat32格式的磁盘分区应使用-t vfat参数。若汉字
文件名显示为乱码或不显示，可以使用下面的命令格式。</p>
<h1 id="mount_-t_ntfs_-o_iocharsetcp936_devsdc1_mntusbhd">mount -t ntfs -o iocharset=cp936 /dev/sdc1 /mnt/usbhd<a class="headerlink" href="#mount_-t_ntfs_-o_iocharsetcp936_devsdc1_mntusbhd" title="Permanent link">&para;</a></h1>
<h1 id="mount_-t_vfat_-o_iocharsetcp936_devsdc5_mntusbhd">mount -t vfat -o iocharset=cp936 /dev/sdc5 /mnt/usbhd<a class="headerlink" href="#mount_-t_vfat_-o_iocharsetcp936_devsdc5_mntusbhd" title="Permanent link">&para;</a></h1>
<p>linux系统下使用fdisk分区命令和mkfs文件系统创建命令可以将移动硬盘的分区制作成linux系统所特
有的ext2、ext3格式。这样，在linux下使用就更方便了。使用下面的命令直接挂接即可。</p>
<h1 id="mount_devsdc1_mntusbhd">mount /dev/sdc1 /mnt/usbhd<a class="headerlink" href="#mount_devsdc1_mntusbhd" title="Permanent link">&para;</a></h1>
<h5 id="u">挂接 U 盘<a class="headerlink" href="#u" title="Permanent link">&para;</a></h5>
<p>和USB接口的移动硬盘一样对linux系统而言U盘也是当作SCSI设备对待的。使用方法和移动硬盘完全
一样。插入U盘之前，应先用fdisk –l 或 more /proc/partitions查看系统的硬盘和硬盘分区情况。
[root at pldyrouter root]# fdisk -l
Disk /dev/sda: 73 dot 4 GB, 73407820800 bytes
255 heads, 63 sectors/track, 8924 cylinders
Units = cylinders of 16065 * 512 = 8225280 bytes
Device Boot Start End Blocks Id System
/dev/sda1 1 4 32098+ de Dell Utility
/dev/sda2 * 5 2554 20482875 7 HPFS/NTFS
/dev/sda3 2555 7904 42973875 83 Linux
/dev/sda4 7905 8924 8193150 f Win95 Ext'd (LBA)
/dev/sda5 7905 8924 8193118+ 82 Linux swap
插入U盘后，再用fdisk –l 或 more /proc/partitions查看系统的硬盘和硬盘分区情况。
[root at pldyrouter root]# fdisk -l
Disk /dev/sda: 73 dot 4 GB, 73407820800 bytes</p>
<p>255 heads, 63 sectors/track, 8924 cylinders
Units = cylinders of 16065 * 512 = 8225280 bytes
Device Boot Start End Blocks Id System
/dev/sda1 1 4 32098+ de Dell Utility
/dev/sda2 * 5 2554 20482875 7 HPFS/NTFS
/dev/sda3 2555 7904 42973875 83 Linux
/dev/sda4 7905 8924 8193150 f Win95 Ext'd (LBA)
/dev/sda5 7905 8924 8193118+ 82 Linux swap
Disk /dev/sdd: 131 MB, 131072000 bytes
9 heads, 32 sectors/track, 888 cylinders
Units = cylinders of 288 * 512 = 147456 bytes
Device Boot Start End Blocks Id System
/dev/sdd1 * 1 889 127983+ b Win95 FAT
Partition 1 has different physical/logical endings:
phys=(1000, 8, 32) logical=(888, 7, 31)
系统多了一个SCSI硬盘/dev/sdd和一个磁盘分区/dev/sdd1,/dev/sdd1就是我们要挂接的U盘。</p>
<h1 id="mkdir_-p_mntusb">mkdir -p /mnt/usb<a class="headerlink" href="#mkdir_-p_mntusb" title="Permanent link">&para;</a></h1>
<p>注：建立一个目录用来作挂接点(mount point)</p>
<h1 id="mount_-t_vfat_devsdd1_mntusb">mount -t vfat /dev/sdd1 /mnt/usb<a class="headerlink" href="#mount_-t_vfat_devsdd1_mntusb" title="Permanent link">&para;</a></h1>
<p>注：现在可以通过/mnt/usb来访问U盘了, 若汉字文件名显示为乱码或不显示，可以使用下面的命令。</p>
<h1 id="mount_-t_vfat_-o_iocharsetcp936_devsdd1_mntusb">mount -t vfat -o iocharset=cp936 /dev/sdd1 /mnt/usb<a class="headerlink" href="#mount_-t_vfat_-o_iocharsetcp936_devsdd1_mntusb" title="Permanent link">&para;</a></h1>
<p>挂接 <strong>Windows</strong> 文件共享</p>
<p>Windows网络共享的核心是SMB/CIFS，在linux下要挂接(mount)windows的磁盘共享，就必须安装和使
用samba 软件包。现在流行的linux发行版绝大多数已经包含了samba软件包，如果安装linux系统时未安
装samba请首先安装samba。当然也可以到 <a href="http://www.samba.org网站下载......新的版本是3.0.10版。">http://www.samba.org网站下载......新的版本是3.0.10版。</a>
当windows系统共享设置好以后，就可以在linux客户端挂接(mount)了，具体操作如下：</p>
<h1 id="mkdir_p_mntsamba">mkdir –p /mnt/samba<a class="headerlink" href="#mkdir_p_mntsamba" title="Permanent link">&para;</a></h1>
<p>注：建立一个目录用来作挂接点(mount point)</p>
<h1 id="mount_-t_smbfs_-o_usernameadministratorpasswordpldy123_1014013323c_mntsamba">mount -t smbfs -o username=administrator,password=pldy123 //10.140.133.23/c$ /mnt/samba<a class="headerlink" href="#mount_-t_smbfs_-o_usernameadministratorpasswordpldy123_1014013323c_mntsamba" title="Permanent link">&para;</a></h1>
<p>注：administrator 和 pldy123 是ip地址为10.140.133.23 windows计算机的一个用户名和密码，c$是这
台计算机的一个磁盘共享
如此就可以在linux系统上通过/mnt/samba来访问windows系统磁盘上的文件了。以上操作在redhat as
server 3、redflag server 4.1、suse server 9以及windows NT 4.0、windows 2000、windows xp、windows 2003
环境下测试通过。</p>
<p>挂接 <strong>UNIX</strong> 系统 <strong>NFS</strong> 文件共享</p>
<p>类似于windows的网络共享，UNIX(Linux)系统也有自己的网络共享，那就是NFS(网络文件系统)，下面
我们就以SUN Solaris2.8和REDHAT as server 3 为例简单介绍一下在linux下如何mount nfs网络共享。
在linux客户端挂接(mount)NFS磁盘共享之前，必须先配置好NFS服务端。
1 、Solaris系统NFS服务端配置方法如下：
(1)修改 /etc/dfs/dfstab, 增加共享目录
share -F nfs -o rw /export/home/sunky
(2)启动nfs服务</p>
<h1 id="etcinitdnfsserver_start">/etc/init.d/nfs.server start<a class="headerlink" href="#etcinitdnfsserver_start" title="Permanent link">&para;</a></h1>
<h5 id="3nfs">(3)NFS服务启动以后，也可以使用下面的命令增加新的共享<a class="headerlink" href="#3nfs" title="Permanent link">&para;</a></h5>
<h1 id="share_exporthomesunky">share /export/home/sunky<a class="headerlink" href="#share_exporthomesunky" title="Permanent link">&para;</a></h1>
<h1 id="share_exporthomesunky_1">share /export/home/sunky<a class="headerlink" href="#share_exporthomesunky_1" title="Permanent link">&para;</a></h1>
<p>注：/export/home/sunky和/export/home/sunky1是准备共享的目录
2 、linux系统NFS服务端配置方法如下：
(1)修改 /etc/exports,增加共享目录
/export/home/sunky 10.140.133.23(rw)
/export/home/sunky1 <em>(rw)
/export/home/sunky2 linux-client(rw)
注：/export/home/目录下的sunky、sunky1、sunky2是准备共享的目录，10.140.133.23、</em>、 linux-client
是被允许挂接此共享linux客户机的IP地址或主机名。如果要使用主机名linux-client必须在服务端主机
/etc/hosts文件里增加linux-client主机ip定义。格式如下：
10.140.133.23 linux-client
(2)启动与停止NFS服务
/etc/rc.d/init.d/portmap start (在R E D H AT中PORTMAP是默认启动的)
/etc/rc.d/init.d/nfs start 启动NFS服务
/etc/rc.d/init.d/nfs stop 停止NFS服务
注：若修改/etc/export文件增加新的共享，应先停止NFS服务，再启动NFS服务方能使新增加的共享
起作用。使用命令exportfs -rv也可以达到同样的效果。
3 、linux客户端挂接(mount)其他linux系统或UNIX系统的NFS共享</p>
<h1 id="mkdir_p_mntnfs">mkdir –p /mnt/nfs<a class="headerlink" href="#mkdir_p_mntnfs" title="Permanent link">&para;</a></h1>
<p>注：建立一个目录用来作挂接点(mount point)</p>
<h1 id="mount_-t_nfs_-o_rw_101401339exporthomesunky_mntnfs">mount -t nfs -o rw 10.140.133.9:/export/home/sunky /mnt/nfs<a class="headerlink" href="#mount_-t_nfs_-o_rw_101401339exporthomesunky_mntnfs" title="Permanent link">&para;</a></h1>
<p>注：这里我们假设10.140.133.9是NFS服务端的主机IP地址，当然这里也可以使用主机名，但必须
在本机/etc/hosts文件里增加服务端ip定义。/export/home/sunky为服务端共享的目录。
如此就可以在linux客户端通过/mnt/nfs来访问其它linux系统或UNIX系统以NFS方式共享出来的文件
了。以上操作在 redhat as server 3、redflag server4.1、suse server 9以及Solaris 7、Solaris 8、Solaris 9 for
x86&amp;sparc环境下测试通过。
权限问题：
假设 server 端的使用者 jack, user id 为 1818, gid 为 1818, client 端也有一个使用者 jack，但 是 uid 及 gid
是 1818 。client 端的 jack 希望能完全读写 server 端的 /home/jack 这个目录。server 端的 /etc/exports
是
这样写的：
/home/jack *(rw,all_squash,anonuid=1818,anongid=1818)
这个的配置文件的意思是，所有 client 端的使用者存取 server 端 /home/jack 这
目录时，都会 map 成 server 端的 jack (uid,gid=1818)。我 mount 的结果是</p>
<ol>
<li>client 端的 root 可以完全存取该目录, 包括读、写、杀......等</li>
<li>client 端的 jack (uid,gid=1818) 我可以做：
rm -rf server_jack/*
cp something server_jack/
mkdir server_jack/a</li>
</ol>
<h4 id="umount">umount ：将文件设备卸载<a class="headerlink" href="#umount" title="Permanent link">&para;</a></h4>
<p>[root@centos57 ~]# umount /dev/hda1 用设备文件名来卸载
[root@centos57 ~]# umount /aixi 用挂载点来卸载</p>
<p>umount: /aixi: device is busy 如果提示设备忙，不急可以使用如下命令卸载
<strong>#</strong> umount -l /mnt/hda 1 选项 – l 并不是马上umount，而是在该目录空闲后再umount。
如果比较急，可用如下命令：
<strong>#</strong> umount -f /mnt/hda 1 -f代表强制 卸载
如果还不行，可使用fuser -m –v /dev/hda1来查询是哪些程序在占用，结束这些程序进程即可卸载
[root@centos57 aixi]# sync &amp;&amp; fuser -m /dev/hda1 –k 使用这条命令后一定可以卸载</p>
<h4 id="_11">交换分区<a class="headerlink" href="#_11" title="Permanent link">&para;</a></h4>
<h5 id="64g_32">交换分区最大容量为64G，最多只能建 32 个,<a class="headerlink" href="#64g_32" title="Permanent link">&para;</a></h5>
<h5 id="_12">创建交换分区<a class="headerlink" href="#_12" title="Permanent link">&para;</a></h5>
<h1 id="fdisk_devhdanptid_82_pw">fdisk /dev/hdan+容量pt(修改系统ID)分区号 82 pw<a class="headerlink" href="#fdisk_devhdanptid_82_pw" title="Permanent link">&para;</a></h1>
<h1 id="mkswap_devhda2_swap">mkswap /dev/hda2（以上划分的分区号） 构建swap格式<a class="headerlink" href="#mkswap_devhda2_swap" title="Permanent link">&para;</a></h1>
<h1 id="swapon_devhda2_swap">swapon /dev/hda2 加载即完成增加swap<a class="headerlink" href="#swapon_devhda2_swap" title="Permanent link">&para;</a></h1>
<h1 id="swapon_s_swap">swapon –s 显示目前使用的Swap设备<a class="headerlink" href="#swapon_s_swap" title="Permanent link">&para;</a></h1>
<p>创建交换文件</p>
<h1 id="dd_ifdevhda1_ofaixiswap_bs1m_count64">dd if=/dev/hda1 of=/aixi/swap bs=1M count=64 创建大文件<a class="headerlink" href="#dd_ifdevhda1_ofaixiswap_bs1m_count64" title="Permanent link">&para;</a></h1>
<h1 id="mkswap_aixiswap">mkswap /aixi/swap<a class="headerlink" href="#mkswap_aixiswap" title="Permanent link">&para;</a></h1>
<h1 id="swapon_aixiswap">swapon /aixi/swap 完成<a class="headerlink" href="#swapon_aixiswap" title="Permanent link">&para;</a></h1>
<p>取消交换分区或者交换文件</p>
<h1 id="swapon_s_swap_1">swapon –s 显示目前使用的Swap设备<a class="headerlink" href="#swapon_s_swap_1" title="Permanent link">&para;</a></h1>
<h1 id="swapoff_aixiswap">swapoff /aixi/swap<a class="headerlink" href="#swapoff_aixiswap" title="Permanent link">&para;</a></h1>
<h1 id="swapoff_devhda">swapoff /dev/hda<a class="headerlink" href="#swapoff_devhda" title="Permanent link">&para;</a></h1>
<h1 id="free_m">free –m查看<a class="headerlink" href="#free_m" title="Permanent link">&para;</a></h1>
<h2 id="_13">三、 用户管理<a class="headerlink" href="#_13" title="Permanent link">&para;</a></h2>
<h4 id="_14">用户和用户组操作命令<a class="headerlink" href="#_14" title="Permanent link">&para;</a></h4>
<h4 id="id">Id<a class="headerlink" href="#id" title="Permanent link">&para;</a></h4>
<h4 id="finger">Finger<a class="headerlink" href="#finger" title="Permanent link">&para;</a></h4>
<h4 id="pwck">Pwck<a class="headerlink" href="#pwck" title="Permanent link">&para;</a></h4>
<p>检查/etc/passwd配置文件内的信息与实际主文件夹是否存在，还可比较/etc/passwd和/etc/shadow的信
息是否一致，另外如果/etc/passwd中的数据字段错误也会提示。</p>
<h4 id="grpck">Grpck<a class="headerlink" href="#grpck" title="Permanent link">&para;</a></h4>
<p>和pwck功能相近，这是检查用户组的。</p>
<h4 id="groups">Groups<a class="headerlink" href="#groups" title="Permanent link">&para;</a></h4>
<h4 id="newgrp">newgrp<a class="headerlink" href="#newgrp" title="Permanent link">&para;</a></h4>
<h4 id="useradd">useradd<a class="headerlink" href="#useradd" title="Permanent link">&para;</a></h4>
<h4 id="usermod">usermod<a class="headerlink" href="#usermod" title="Permanent link">&para;</a></h4>
<p>usermod 不仅能改用户的SHELL类型，所归属的用户组，也能改用户密码的有效期，还能改登录名。usermod 如此看来就
是能做到用户帐号大转移；比如我把用户A改为新用户B；</p>
<p>usermod [-u uid [-o]] [-g group] [-G group,...]
[-d 主目录 [-m]] [-s shell] [-c 注释] [-l 新名称]
[-f 失效日] [-e 过期日] [- p 密码] [- L|-U] 用户名
usermod 命令会参照你命令列上指定的部份修改系统帐号档。下列为usermod可选用的参数。
-c comment
更新用户帐号password档中的注解栏，一般是使用chfn(1)来修改。
-d home_dir
更新用户新的登入目录。如果给定-m选项，用户旧目录会搬到新的目录去，如旧目录不存在则建个新的。
-e expire_date 加上用户帐号停止日期。日期格式为MM/DD/YY.
-f inactive_days 帐号过期几日后永久停权。当值为 0 时帐号则立刻被停权。而当值为- 1 时则关闭此功能。预设值为- 1 。
-g initial_group 更新用户新的起始登入用户组。用户组名须已存在。用户组ID必须参照既有的的用户组。用户组ID预设
值为 1 。
-G group,[...] 定义用户为一堆groups的成员。每个用户组使用","区格开来，不可以夹杂空白字元。用户组名同-g选项的
限制。如果用户现在的用户组不再此列，则将用户由该用户组中移除。
-l login_name 变更用户login时的名称为login_name。其它不变。特别是，用户目录名应该也会跟着更动成新的登入名。
-s shell 指定新登入shell。如此栏留白，系统将选用系统预设shell。
-u uid用户ID值。必须为唯一的ID值，除非用-o选项。数字不可为负值。预设为最小不得小于/etc/login.defs中定义的
UID_MIN值。 0 到UID_MIN值之间是传统上保留给系统帐号使用。用户目录树下所有的档案目录其userID会自动改变。放在
用户目录外的档案则要自行手动更动。
警告:usermod不允许你改变正在线上的用户帐号名称。当usermod用来改变userID,必须确认这名user没在电脑上执行任何
程序。你需手动更改用户的crontab档。也需手动更改用户的at工作档。采用NISserver须在server上更动相关的NIS设
定。
举个简单的例子，我们在前面说了关于useradd的工具，而usermod 工具和useradd的参数差不多；两者不同之处在于
useradd是添加，usermod 是修改；</p>
<p>[root@localhost ~]# usermod -d /opt/linuxfish -m -l fishlinux -U linuxfish
注：把linuxfish 用户名改为fishlinux ，并且把其家目录转移到 /opt/linuxfish ；
[root@localhost ~]# ls -la /opt/linuxfish/ 注：查看用户fishlinux的家目录下的文件及属主；
总用量 48
drwxr-xr-x 3 fishlinux linuxfish 4096 11月 5 16:.
drwxrwxrwx 29 root root 4096 11月 5 16: ..
-rw-r--r-- 1 fishlinux linuxfish 24 11月 5 16:46 .bash_logout
-rw-r--r-- 1 fishlinux linuxfish 191 11月 5 16:46 .bash_profile
-rw-r--r-- 1 fishlinux linuxfish 124 11月 5 16:46 .bashrc
-rw-r--r-- 1 fishlinux linuxfish 5619 11月 5 16:46 .canna
-rw-r--r-- 1 fishlinux linuxfish 438 11月 5 16:46 .emacs</p>
<p>-rw-r--r-- 1 fishlinux linuxfish 120 11月 5 16:46 .gtkrc
drwxr-xr-x 3 fishlinux linuxfish 4096 11月 5 16:46 .kde
-rw-r--r-- 1 fishlinux linuxfish 0 11月 5 16:46 mydoc.txt
-rw-r--r-- 1 fishlinux linuxfish 658 11月 5 16:46 .zshrc
[root@localhost ~]# more /etc/passwd |grep fishlinux 注：查看有关fishlinux的记录；
fishlinux<img alt="❌" class="emojione" src="https://cdnjs.cloudflare.com/ajax/libs/emojione/2.2.7/assets/png/274c.png" title=":x:" />512:512::/opt/linuxfish:/bin/bash
通过上面的例子，我们发现文件的用户组还没有变，如果您想改变为fishlinux用户组，如果想用通过 usermod来修改，就要
先添加fishlinux用户组；然后用usermod -g 来修改 ，也可以用chown -R fishlinux:fishlinux /opt/finshlinux 来改；</p>
<p>警告： usermod 最好不要用它来改用户的密码，因为他在/etc/shadow中显示的是明口令；修改用户的口令最好用passwd ；</p>
<p>[root@localhost ~]# usermod -p 123456 fishlinux 注：修改fishlinux的口令是 123456 ；
[root@localhost ~]# more /etc/shadow |grep fishlinux 注：查询/etc/shadow文件中fishlinux的口令；我们看到明显
是没有加密；
fishlinux:123456:13092:0:99999:7:::</p>
<h4 id="userdel">userdel<a class="headerlink" href="#userdel" title="Permanent link">&para;</a></h4>
<p>userdel很简单，只有一个参数可选 -r ；如果加参数-r ，表示在删除用户的同时，一并把用户的家目录及本地邮件存储的目
录或文件也一同删除；比如我们现在有两个用户bnnb和lanhaitun，其家目录都位于/home目录中，现在我们来删除这两个
用户；</p>
<p>[root@localhost ~]# userdel bnnb 注：删除用户bnnb，但不删除其家目录及文件；
[root@localhost ~]# ls -ld /home/bnnb 注：查看其家目录是否存在；
drwxr-xr-x 14 501 501 4096 8 月 29 16:33 /home/bnnb 注：存在；
[root@localhost ~]# ls -ld /home/lanhaitun 注：查看lanhaitun家目录是否存在；
drwx------ 4 lanhaitun lanhaitun 4096 11月 5 14:50 /home/lanhaitun 注：存在；
[root@localhost ~]# userdel -r lanhaitun 注：删除用户lanhaitun，其家目录及文件一并删除；
[root@localhost ~]# ls -ld /home/lanhaitun 注：查看是否在删除lanhaitun 用户的同时，也一并把其家目录和文件一
同删除；
ls: /home/lanhaitun: 没有那个文件或目录 注：已经删除；
警告： 请不要轻易用-r参数；他会删除用户的同时删除用户所有的文件和目录，切记；如果用户目录下有重要的文件，在删
除前请备份；</p>
<p>其实也有最简单的办法，但这种办法有点不安全，也就是直接在/etc/passwd中删除您想要删除用户的记录；但最好不要这样
做，/etc/passwd 是极为重要的文件，可能您一不小心会操作失误；</p>
<h4 id="groupadd">Groupadd<a class="headerlink" href="#groupadd" title="Permanent link">&para;</a></h4>
<h4 id="groupmod">groupmod<a class="headerlink" href="#groupmod" title="Permanent link">&para;</a></h4>
<h4 id="groupdel">groupdel 是用来删除用户组的；<a class="headerlink" href="#groupdel" title="Permanent link">&para;</a></h4>
<p>语法格式：groupdel 用户组</p>
<p>比如：</p>
<p>[root@localhost ~]# groupdel lanhaitun</p>
<h4 id="passwd">passwd<a class="headerlink" href="#passwd" title="Permanent link">&para;</a></h4>
<p>passwd 作为普通用户和超级权限用户都可以运行，但作为普通用户只能更改自己的用户密码，但前提是没有被root用户锁
定；如果root用户运行passwd ，可以设置或修改任何用户的密码；</p>
<p>passwd 命令后面不接任何参数或用户名，则表示修改当前用户的密码；请看下面的例子；</p>
<p>[root@localhost ~]# passwd 注：没有加任何用户，我是用root用户来执行的passwd 表示修改root用户的密码；下面
也有提示；
Changing password for user root.
New UNIX password: 注：请输入新密码；
Retype new UNIX password: 注：验证新密码；
passwd: all authentication tokens updated successfully. 注：修改root密码成功；
如果是普通用户执行passwd 只能修改自己的密码；</p>
<p>如果新建用户后，要为新用户创建密码，则用 passwd 用户名 ，注意要以root用户的权限来创建；</p>
<p>[root@localhost ~]# passwd beinan 注：更改或创建beinan用户的密码；
Changing password for user beinan.
New UNIX password: 注：请输入新密码；
Retype new UNIX password: 注：再输入一次；
passwd: all authentication tokens updated successfully. 注：成功；
普通用户如果想更改自己的密码，直接运行passwd即可；比如当前操作的用户是beinan；</p>
<p>[beinan@localhost ~]$ passwd
Changing password for user beinan. 注：更改beinan用户的密码；
(current) UNIX password: 注：请输入当前密码；
New UNIX password: 注：请输入新密码；
Retype new UNIX password: 注：确认新密码；
passwd: all authentication tokens updated successfully. 注：更改成功；</p>
<h4 id="passwd_1">passwd 几个比较重要的参数；<a class="headerlink" href="#passwd_1" title="Permanent link">&para;</a></h4>
<p>[root@localhost beinan]# passwd --help
Usage: passwd [OPTION...] <accountName>
-k, --keep -tokens keep non-expired authentication tokens
注：保留即将过期的用户在期满后能仍能使用；
-d, --delete delete the password for the named account (root only)
注：删除用户密码，仅能以root权限操作；
-l, --lock lock the named account (root only)
注：锁住用户无权更改其密码，仅能通过root权限操作；
-u, --unlock unlock the named account (root only)
注：解除锁定；
-f, --force force operation
注：强制操作；仅root权限才能操作；
-x, --maximum=DAYS maximum password lifetime (root only) 注：两次密码修正的最大天数，后面接数字；仅能
root权限操作；
-n, --minimum=DAYS minimum password lifetime (root only) 注：两次密码修改的最小天数，后面接数字，仅能
root权限操作；</p>
<p>-w, --warning=DAYS number of days warning users receives before 注：在距多少天提醒用户修改密码；仅能
root权限操作；
password expiration (root only)
-i, --inactive=DAYS number of days after password expiration when an 注：在密码过期后多少天，用户被禁
掉，仅能以root操作；
account becomes disabled (root only)
-S, --status report password status on the named account (root 注：查询用户的密码状态，仅能root
用户操作；
only)
--stdin read new tokens from stdin (root only)
比如我们让某个用户不能修改密码，可以用-l 参数来锁定：</p>
<p>[root@localhost ~]# passwd -l beinan 注：锁定用户beinan不能更改密码；
Locking password for user beinan.
passwd: Success 注：锁定成功；
[beinan@localhost ~]# su beinan 注：通过su切换到beinan用户；
[beinan@localhost ~]$ passwd 注：beinan来更改密码；
Changing password for user beinan.
Changing password for beinan
(current) UNIX password: 注：输入beinan的当前密码；
passwd: Authentication token manipulation error 注：失败，不能更改密码；
再来一例：</p>
<p>[root@localhost ~]# passwd -d beinan 注：清除beinan用户密码；
Removing password for user beinan.
passwd: Success 注：清除成功；
[root@localhost ~]# passwd -S beinan 注：查询beinan用户密码状态；
Empty password. 注：空密码，也就是没有密码；
注意： 当我们清除一个用户的密码时，登录时就无需密码；这一点要加以注意；</p>
<h4 id="chage">chage 修改用户密码有效期限的命令；<a class="headerlink" href="#chage" title="Permanent link">&para;</a></h4>
<p>chage 用语法格式：</p>
<p>chage [-l] [ -m 最小天数] [- M 最大天数] [-W 警告] [-I 失效日] [-E 过期日] [-d 最后日] 用户
前面已经说的好多了，这个只是一笔带过吧，知道有这个命令就行，自己实践实践再说，大体和psswd有些参数的用法差不
多；</p>
<h4 id="id_uid_gid_gid">id 工具 : 查询用户所对应的 UID 和 GID 及 GID 所对应的用户组；<a class="headerlink" href="#id_uid_gid_gid" title="Permanent link">&para;</a></h4>
<p>id 工具是用来查询用户信息，比如用户所归属的用户组，UID 和GID等；id 用法极为简单；我们举个例子说明一下；
语法格式： id [参数] [用户名]
至于有哪些参数，自己查一下 id --help 或man id ；如 果id后面不接任何参数和任何用户，默认显示当前操作用户的用户名、
所归属的用户组、UID和GID等；</p>
<p>实例一：不加任何参数和用户名；</p>
<p>[beinan@localhost ~]$ id</p>
<p>uid=500(beinan) gid=500(beinan) groups=500(beinan)
注解：在没有加任何参数的情况下，查询的是当前操作用户的用户名、UID 、GID 和所处的主用户组和附属用户组；在本例
中，用户名是beinan，UID是500,所归属的主用户组是beinan，GID是 500 ；
实例二： id 后面接用户名；
如果我们想查询系统中用户的UID和GID 相应的内容，可以直接接用户名，但用户名必须是真实的 ，能在/etc/passwd中查
到的；
[beinan@localhost ~]$ id linuxsir
uid=505(linuxsir) gid=502(linuxsir) groups=502(linuxsir),0(root),500(beinan)
注解：查询用户linuxsir 的信息，用户linuxsir ，UID 为 505 ，所归属的主用户组是linuxsir，主用户组的GID是 502 ；同时
linuxsir用户也是GID为 0 的root用户组成员，也是GID为 500 用户组beinan的成员；
这个例子和实例一在用户组方面有所不同，我们在 《Linux 用户（user）和用户组（group）管理概述》 中有提到；用户和
用户组的对应关系，可以是一对一、一对多、多对一、或多对多的交叉关系，请参考之；另外您还需要掌握《用户（user）
和用户组（group）配置文件详解》一文；</p>
<h4 id="2_finger_shell">2 、finger 工具：用来查询用户信息，侧重用户家目录、登录SHELL等；<a class="headerlink" href="#2_finger_shell" title="Permanent link">&para;</a></h4>
<p>finger 工具侧重于用户信息的查询；查询的内容包括用户名（也被称为登录名Login），家目录，用户真实的名字（Name）... ...
办公地址、办公电话；也包括登录终端、写状态、空闭时间等；
我们最常用finger 来查询用户家目录、用户真实名、所用SHELL 类型、以及办公地址和电话，这是以参数 -l 长格式输出的；
而修改用户的家目录、真实名字、办公地址及办公电话，我们一般要能过chfn命令进行；
语法格式：
finger [参数选项] [用户名］
-l 采用长格式（默认），显示由-s选项所包含的所有信息，以及主目录、办公地址、办公电话、登录SHELL、邮件状
态、.plan、.project和.forward；
-m 禁止对用户真实名字进行匹配；
-p 把.plan和.project文件中的内容省略；
-s 显示短格式，用户名（也被称为登录名Login）、真实名字（NAME）、在哪个终端登录（Tty）、写状态、空闲时间（Idle）、
登录时间（Login Time）、办公地点、办公电话等；
至于finger 有哪些参数，您可以通过 finger --help 或man finger 来获取，我们在本文中以实例讲述最常用的参数；
实例一：不接任何参数，也不指定查询用户名；默认为加了-s参数；</p>
<p>[beinan@localhost ~]$ finger
Login Name Tty Idle Login Time Office Office Phone
beinan beinan sun tty1 1:39 Nov 2 08:
linuxsir linuxsir open tty2 2 Nov 2 10:03 linuxsir o +1-389- 866- 771
等价命令
[beinan@localhost ~]$ finger -s
注解：不加任何参数，也没有指定查询哪个用户，finger 会以默认以短格-s 来输出登录本机的所有用户的用户名（也被称为
登录名Login）、真实名字（NAME）、在哪个终端登录（Tty）、写状态、空闲时间（Idle）、登录时间（Login Time）、办公地
点、办公电话等；
在这个例子中，有beinan用户登录，真实名字是beinan sun （这个名字是用户的真实名字，如果在添加用户时没有设置，
是不会显示的），在tty1终端登录，空闭时间是 1 分 39 秒，登录时间是Nov /2/08:27 ，没有办公室名称，没有办公电话；
请对照本例中beinan用户记录的解说，我们来看看本例中的 linuxsir用户信息；应该不难。
关于写状态，如果在Tty 后面 没有任何输出，表示正在写入，如果有*出现，表示没有写入或被禁止，比如下面的例子，ftp
用户没有通过终端登录系统，因为Tty是*，同时Tty后面还有一个* ，表示禁止写入或没有写入状态(当用户没有登录时）；
[beinan@localhost ~]$ finger -s ftp</p>
<p>Login Name Tty Idle Login Time Office Office Phone
ftp FTP User * * No logins
我们可以以短格式的来查询某个用户信息以短格式输出，比如下面的例子；
[beinan@localhost ~]$ finger -s beinan
实例二：关于长格式的用户信息的输出 -l 参数的实例；
finger -l 如果不加用户名的情况下，可以列出所有通过tty登录的用户信息；如果您想查询某个用户，就直接指定用户，可以
指定一个或多个；什么是tty登录？如果您在全屏文本界面操作的话，您可以通过按CTRL+F2或CTRL+F3 或CTRL+F4等，
以几个不同的用户登录到主机上，您就会看到，每个用户都有不同的tty；
[beinan@localhost ~]$ finger -l
[beinan@localhost ~]$ finger -l beinan linuxsir 注：可以同时查询几个用户信息，以长格式输出；
[beinan@localhost ~]$ finger beinan
Login: beinan Name: beinan sun
Directory: /home/beinan Shell: /bin/bash
On since Wed Nov 2 08:27 (CST) on tty1 2 hours 29 minutes idle
On since Wed Nov 2 10:50 (CST) on pts/0 from :0.
No mail.
No Plan.
在本例中，所查询的用户是beinan，真实名字是beinan sun ，家目录位于 /home/beinan ，所用SHELL类型是bash ；然
后就是通过哪个终端登录的，登录时间，是不是有mail ，有Plan 等；
实例三：参数组合的例子；
[beinan@localhost ~]$ finger -lp beinan
Login: beinan Name: beinan sun
Directory: /home/beinan Shell: /bin/bash
On since Wed Nov 2 08:27 (CST) on tty1 2 hours 36 minutes idle
On since Wed Nov 2 10:50 (CST) on pts/0 from :0.
No mail.
注解：查询beinan用户信息，以长格式输出，并且不输出.Plan和.Project的内容；
实例四： finger -s 和w 及who的比较；
对于finger 就说这么多吧，极为简单的工具，当用到-s 参数时，您最好和w和who工具对照，看看finger -s 和w 及who
的输出有什么异同，w和who是查询哪些用户登录主机的；而finger -s 呢，无论是登录还是不登录的用户都可以查；但所查
到的内容侧重有所不同；自己看看例子；
[beinan@localhost ~]$ finger -s
Login Name Tty Idle Login Time Office Office Phone
beinan beinan sun tty1 3:03 Nov 2 08:
beinan beinan sun pts/0 Nov 2 10:50 (:0.0)
linuxsir linuxsir open tty2 1:26 Nov 2 10:03 linuxsir o +1-389- 866- 771
[beinan@localhost ~]$ w
11:30:36 up 3:04, 3 users, load average: 0.30, 0.15, 0.
USER TTY FROM LOGIN@ IDLE JCPU PCPU WHAT
beinan tty1 - 08:27 3:03m 2:52 0.00s /bin/sh /usr/X11R6/bin/startx
linuxsir tty2 - 10:03 1:26m 0.01s 0.01s -bash
beinan pts/0 :0.0 10:50 0.00s 0.16s 0.00s w
[beinan@localhost ~]$ who
beinan tty1 Nov 2 08:</p>
<p>linuxsir tty2 Nov 2 10:
beinan pts/0 Nov 2 10:50 (:0.0)</p>
<h4 id="3_w_who_users">3 、查询登录主机的用户工具：w 、who 、users<a class="headerlink" href="#3_w_who_users" title="Permanent link">&para;</a></h4>
<p>w、who和users工具，是查询已登录当前主机的用户；另外finger -s 也同样能查询；侧重点不一样；请自己对比着看；毕
竟简单，这里只是介绍 ；
[beinan@localhost ~]$ w
12:09:56 up 3:43, 7 users, load average: 0.16, 0.10, 0.
USER TTY FROM LOGIN@ IDLE JCPU PCPU WHAT
beinan tty1 - 08:27 3:42m 3:09 0.00s /bin/sh /usr/X11R6/bin/startx
linuxsir tty2 - 10:03 2:06m 0.01s 0.01s -bash
beinan pts/0 :0.0 11:36 1:09 0.15s 0.15s bash
beinan pts/1 :0.0 11:37 1:12 0.21s 0.21s bash
beinan pts/2 :0.0 12:02 6:52 0.09s 0.09s bash
beinan pts/3 :0.0 12:05 12.00s 0.11s 0.06s ssh <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#120;&#109;&#98;&#110;&#110;&#98;&#100;&#108;&#64;&#108;&#105;&#110;&#117;&#120;&#115;&#105;&#114;&#46;&#111;&#114;&#103;">&#120;&#109;&#98;&#110;&#110;&#98;&#100;&#108;&#64;&#108;&#105;&#110;&#117;&#120;&#115;&#105;&#114;&#46;&#111;&#114;&#103;</a> -p 17007
beinan pts/4 :0.0 12:06 0.00s 0.21s 0.00s w
[beinan@localhost ~]$ who
beinan tty1 Nov 2 08:
linuxsir tty2 Nov 2 10:
beinan pts/0 Nov 2 11:36 (:0.0)
beinan pts/1 Nov 2 11:37 (:0.0)
beinan pts/2 Nov 2 12:02 (:0.0)
beinan pts/3 Nov 2 12:05 (:0.0)
beinan pts/4 Nov 2 12:06 (:0.0)
[beinan@localhost ~]$ users
beinan beinan beinan beinan beinan beinan linuxsir</p>
<h4 id="4_groups">4 、groups 用户所归属的用户组查询；<a class="headerlink" href="#4_groups" title="Permanent link">&para;</a></h4>
<p>groups 用法很简单，就是查询用户所归属哪个或哪些用户组；
语法格式： groups 用户名
实例：
[beinan@localhost ~]$ groups beinan 注：查询beinan所归属的用户组；
beinan : beinan 注：beinan 是beinan用户组下的成员；
[beinan@localhost ~]$ groups linuxsir 注：查询linuxsir用户所归属的用户组；
linuxsir : linuxsir root beinan 注：linuxsir用户是linuxsir用户组、beinan用户组、root用户组成员；
groups 主要是查询用户所归属的用户组名，最好和id命令相对比；这样对这两个工具都有所了解</p>
<h4 id="_15">相关配置文件<a class="headerlink" href="#_15" title="Permanent link">&para;</a></h4>
<p>/etc/passwd
/etc/shadow
/etc/gshadow
/etc/group</p>
<h4 id="linux_3">Linux 用户密码策略<a class="headerlink" href="#linux_3" title="Permanent link">&para;</a></h4>
<p>Linux用户密码的有效期,是否可以修改密码可以通过login.defs文件控制.对login.defs文件修只影响后续
建立的用户,如果要改变以前建立的用户的有效期等可以使用chage命令.</p>
<p>Linux用户密码的复杂度可以通过pam pam_cracklib module或pam_passwdqc module控制,两者不能同时
使用. 个人感觉pam_passwdqc更好用.
/etc/login.defs密码策略
PASS_MAX_DAYS 99999 #密码的最大有效期, 99999:永久有期
PASS_MIN_DAYS 0 #是否可修改密码,0可修改,非 0 多少天后可修改
PASS_MIN_LEN 5 #密码最小长度,使用pam_cracklib module,该参数不再有效
PASS_WARN_AGE 7 #密码失效前多少天在用户登录时通知用户修改密码
pam_cracklib主要参数说明:
tretry=N:重试多少次后返回密码修改错误
difok=N:新密码必需与旧密码不同的位数
dcredit=N: N &gt;= 0:密码中最多有多少个数字;N &lt; 0密码中最少有多少个数字.
lcredit=N:小宝字母的个数
ucredit=N大宝字母的个数
credit=N:特殊字母的个数
minclass=N:密码组成(大/小字母,数字,特殊字符)
pam_passwdqc主要参数说明:
mix:设置口令字最小长度，默认值是mix=disabled。
max:设置口令字的最大长度，默认值是max=40。
passphrase:设置口令短语中单词的最少个数，默认值是passphrase=3，如果为 0 则禁用口令短语。
atch:设置密码串的常见程序，默认值是match=4。
similar:设置当我们重设口令时，重新设置的新口令能否与旧口令相似，它可以是similar=permit允
许相似或similar=deny不允许相似。
random:设置随机生成口令字的默认长度。默认值是random=42。设为 0 则禁止该功能。
enforce:设置约束范围，enforce=none表示只警告弱口令字，但不禁止它们使用；enforce=users将
对系统上的全体非根用户实行这一限制；enforce=everyone将对包括根用户在内的全体用户实行这
一限制。
non-unix:它告诉这个模块不要使用传统的getpwnam函数调用获得用户信息，
retry:设置用户输入口令字时允许重试的次数，默认值是retry=</p>
<p>密码复杂度通过/etc/pam.d/system-auth实施
如:
要使用pam_cracklib将注释去掉,把pam_passwdqc.so注释掉即可.</p>
<h1 id="password_requisite_libsecurityisapam_cracklibso_retry3_difok">password requisite /lib/security/$ISA/pam_cracklib.so retry=3 difok=<a class="headerlink" href="#password_requisite_libsecurityisapam_cracklibso_retry3_difok" title="Permanent link">&para;</a></h1>
<p>password requisite /lib/security/<span class="arithmatex"><span class="MathJax_Preview">ISA/pam_passwdqc.so min=disabled,24,12,8,7 passphrase=
password sufficient /lib/security/</span><script type="math/tex">ISA/pam_passwdqc.so min=disabled,24,12,8,7 passphrase=
password sufficient /lib/security/</script></span>ISA/pam_unix.so nullok use_authtok md5 shadow</p>
<h1 id="password_requisite_libsecurityisapam_cracklibso_retry3_difok_1">password requisite /lib/security/$ISA/pam_cracklib.so retry=3 difok=<a class="headerlink" href="#password_requisite_libsecurityisapam_cracklibso_retry3_difok_1" title="Permanent link">&para;</a></h1>
<p>新密码至少有一位与原来的不同
PASS_MIN_DAYS参数则设定了在本次密码修改后，下次允许更改密码之前所需的最少天数。
PASS_WARN_AGE的设定则指明了在口令失效前多少天开始通知用户更改密码（一般在用户刚刚登陆系统时
就会收到警告通知）。
你也会编辑/etc/default/useradd文件，寻找INACTIVE和EXPIRE两个关键词：
INACTIVE=
EXPIRE=</p>
<h5 id="_16">这会指明在口令失效后多久时间内，如果口令没有进行更改，则将账户更改为失效状态。在本例中，<a class="headerlink" href="#_16" title="Permanent link">&para;</a></h5>
<h5 id="14_expire-">这个时间是 14 天。而EXPIRE的设置则用于为所有新用户设定一个密码失效的明确时间（具体格式为“年份-<a class="headerlink" href="#14_expire-" title="Permanent link">&para;</a></h5>
<h5 id="-">月份-日期”）。<a class="headerlink" href="#-" title="Permanent link">&para;</a></h5>
<h5 id="_17">显然，上述这些设定更改之后，只能影响到新建立的用户。要想修改目前已存在的用户具体设置，<a class="headerlink" href="#_17" title="Permanent link">&para;</a></h5>
<p>需要使用chage工具。</p>
<h1 id="chage_-m_60_joe">chage -M 60 joe<a class="headerlink" href="#chage_-m_60_joe" title="Permanent link">&para;</a></h1>
<p>这条命令将设置用户joe的PASS_MAX_DAYS为 60 ，并修改对应的shadow文件。
你可以使用chage -l的选项，列出当前的账户时效情况，而使用-m选项是设置PASS_MIN_DAYS，用-W
则是设置PASS_WARN_AGE，等等。chage工具可以让你修改特定账户的所有密码时效状态。
注意，chage仅仅适用于本地系统的账户，如果你在使用一个类似LDAP这样的认证系统时，该工具
会失效。如果你在使用LDAP作为认证，而你又打算使用chage，那么，哪怕仅仅是试图列出用户密码的时
效信息，你也会发现chage根本不起作用。
制定一项策略，定义多长时间一个密码必须进行更改，然后强制执行该策略，是非常不错的一个做
法。在解雇了某个雇员后，口令时效策略会保证该雇员不可能在被解雇 3 个月后发现他的口令依然可用。即
使系统管理员忽略了删除他的帐号，该帐号也会因密码时效策略而被自动锁定。当然，这一点并不能成为不
及时删除该雇员帐号的理由，但是这个策略的确提供了一层额外的安全防护，尤其是在过去常常忽视及时清
理帐号的情况下。</p>
<h4 id="acl">ACL 权限设置<a class="headerlink" href="#acl" title="Permanent link">&para;</a></h4>
<p>ACL是Access Control List 的缩写，主要用于在提供传统的owner、group、others的read、write、execute
权限之外进行细部权限设置。</p>
<h4 id="acl_1">启动 ACL<a class="headerlink" href="#acl_1" title="Permanent link">&para;</a></h4>
<h5 id="acl_2">让 / 目录支持 ACL ：<a class="headerlink" href="#acl_2" title="Permanent link">&para;</a></h5>
<div class="highlight"><pre><span></span><code>#mount –o remount ,acl /
#mount |grep / //查看是否有挂载
开机启动 ACL ：
将要启动ACL的分区写入/etc/fstab中：
#vi /etc/fstab
/dev/hda5 / ext3 default,acl 1 2
</code></pre></div>
<h4 id="acl_3">ACL 相关命令<a class="headerlink" href="#acl_3" title="Permanent link">&para;</a></h4>
<p><strong>Getfacl :</strong> 取得某个文件 <strong>/</strong> 目录的 <strong>ACL</strong> 权限；
<strong>Setfacl :</strong> 设置某个文件 <strong>/</strong> 目录的 <strong>ACL</strong> 权限；
setfacl [-bkndRLPvh] [{-m|-x} acl_spec] [{-M|-X} acl_file] file ...
setfacl --restore=file
描述
setfacl用来在命令行里设置ACL。在命令行里，一系列的命令跟随以一系列的文件名。
选项-m和-x后边跟以acl规则。多条acl规则以逗号(,)隔开。选项-M和-X用来从文件或标准输入读取
acl规则。
选项--set和--set-file用来设置文件或目录的acl规则，先前的设定将被覆盖。
选项-m(--modify)和-M(--modify-file)选项修改文件或目录的acl规则。
选项-x(--remove)和-X(--remove-file)选项删除acl规则。
当使用-M，-X选项从文件中读取规则时，setfacl接受getfacl命令输出的格式。每行至少一条规则，以#
开始的行将被视为注释。</p>
<p>当在不支持ACLs的文件系统上使用setfacl命令时，setfacl将修改文件权限位。如果acl规则并不完全匹
配文件权限位，setfacl将会修改文件权限位使其尽可能的反应acl规则，并会向standard error发送错误消息，
以大于 0 的状态返回。
权限
文件的所有者以及有CAP_FOWNER的用户进程可以设置一个文件的acl。（在目前的linux系统上，root
用户是唯一有CAP_FOWNER能力的用户）
选项
-b, --remove-all
删除所有扩展的acl规则，基本的acl规则(所有者，群组，其他）将被保留。
-k,--remove-default
删除缺省的acl规则。如果没有缺省规则，将不提示。
-n，--no-mask
不要重新计算有效权限。setfacl默认会重新计算ACL mask，除非mask被明确的制定。
--mask
重新计算有效权限，即使ACL mask被明确指定。
-d，--default
设定默认的acl规则。
--restore=file
从文件恢复备份的acl规则（这些文件可由getfacl -R产生）。通过这种机制可以恢复整个目录树的acl
规则。此参数不能和除--test以外的任何参数一同执行。
--test
测试模式，不会改变任何文件的acl规则，操作后的acl规格将被列出。
-R，--recursive
递归的对所有文件及目录进行操作。
-L，--logical
跟踪符号链接，默认情况下只跟踪符号链接文件，跳过符号链接目录。
-P，--physical
跳过所有符号链接，包括符号链接文件。
--version
输出setfacl的版本号并退出。
--help
输出帮助信息。
--
标识命令行参数结束，其后的所有参数都将被认为是文件名</p>
<p>-
如果文件名是-，则setfacl将从标准输入读取文件名。
ACL规则
setfacl命令可以识别以下的规则格式。
[d[efault]:] [u[ser]:]uid [:perms]
指定用户的权限，文件所有者的权限（如果uid没有指定）。
[d[efault]:] g[roup]:gid [:perms]
指定群组的权限，文件所有群组的权限（如果gid未指定）
[d[efault]:] m[ask][:] [:perms]
有效权限掩码</p>
<p>[d[efault]:] o[ther] [:perms]
其他的权限
恰当的acl规则被用在修改和设定的操作中。
对于uid和gid，可以指定一个数字，也可指定一个名字。
perms域是一个代表各种权限的字母的组合：读-r 写-w 执行-x，执行只适合目录和一些可执行的文件。
pers域也可设置为八进制格式。
自动创建的规则
最初的，文件目录仅包含 3 个基本的acl规则。为了使规则能正常执行，需要满足以下规则。
<em>3个基本规则不能被删除。
*任何一条包含指定的用户名或群组名的规则必须包含有效的权限组合。
*任何一条包含缺省规则的规则在使用时，缺省规则必须存在。
用法举例如下：
acl 全称 Access Control Lists 翻译成中文叫"访问控制列表",
传统的 Linux 文件系统的权限控制是通过 user、group、other 与 r(读)、w(写)、x(执行) 的不同组合来
实现的。随着应用的发展，这些权限组合已不能适应现时复杂的文件系统权限控制要求。 例如，目录 /data
的权限为：drwxr-x---，所有者与所属组均为 root，在不改变所有者的前提下，要求用户 tom 对该目录有完
全访问权限 (rwx).考虑以下 2 种办法 (这里假设 tom 不属于 root group)
(1) 给 /data 的 other 类别增加 rwx permission，这样由于 tom 会被归为 other 类别，那么他也将拥
有 rwx 权限。
(2) 将 tom 加入到 root group，为 root group 分配 rwx 权限，那么他也将拥有 rwx 权限。
以上 2 种方法其实都不合适，所以传统的权限管理设置起来就力不从心了。
为了解决这些问题，Linux 开发出了一套新的文件系统权限管理方法，叫文件访问控制列表 (Access
Control Lists, ACL)。简单地来说，ACL 就是可以设置特定用户或者用户组对于一个文件的操作权限。
ACL 有两种，一种是存取 ACL (access ACLs)，针对文件和目录设置访问控制列表。一种是默认 ACL (default
ACLs)，只能针对目录设置。如果目录中的文件没有设置 ACL，它就会使用该目录的默认 ACL.
首先我来讲一下getfacl ( 显示文件或目录的 ACL)
在我的电脑里首先有一个用户叫NEU.我们学校的简称.同时还有一个用户,software,我的专业名称.
我以neu用户进行操作,在其目录下建立一个文件fileofneu.
可以看到它的初始权限为-rw-rw-r--然后我把这个文件权限进行下修改.使用的命令为chmod,修改后的文
件权限为-rw-rw----现在这个文件的权限就不允许其它用户访问了.
然后切换到sofeware用户,来证实这个文件的不可访问性.
下面我们就通过getfacl命令来查看.这时候得进入neu用户下操作了.其命令格式很简单:getfacl fileofneu
权限一目了然.不多介绍了,下面就要用Setfacl来进行修改了.使其在对于其它用户的权限里,只对
software用户只读只写.
**setfacl -m u:softeware:rw- fileofneu
setfacl -R -m u:softeware:rw- fileofneu (-R*</em> 一定要在 <strong>-m</strong> 前面，表示目录下所有文件）
<strong>setfacl -x u:softeware fileofneu</strong> （去掉单个权限）
<strong>setfacl -b</strong> （去掉所有 <strong>acl</strong> 权限）
如果我们希望在一个目录中新建的文件和目录都使用同一个预定的ACL，那么我们可以使用默认(Default)
ACL。在对一个目录设置了默认的ACL以后，每个在目录中创建的文件都会自动继承目录的默认ACL作为自
己的ACL。用setfacl的-d选项就可以做到这一点：
[root@FC3-vm mnt]# setfacl -d --set g:testg1:rwx dir1
[root@FC3-vm mnt]# getfacl dir1</p>
<p>然后用getfacl命令来进行查看.我们就可以看到多了一行user:software:rw- 这说明其对用户software开
放了读写的权限.
为了证实其可用性,再切换到software用户下访问这个文件,发现与前面不同的是,这回可以读写了.
今天就讲这一个吧,讲多了,大家也记不住.
对了,刚才我进行了一下这个操作,发现进不去,原来是我没有给software用户授与访问/home/neu这个目
录的进入的权力,所以,我们还得应用 setfacl命令来使得software用户拥有进入这个目录的权力.其操作与上
面基本一致。</p>
<h4 id="_18">用户身份切换<a class="headerlink" href="#_18" title="Permanent link">&para;</a></h4>
<h4 id="su">Su<a class="headerlink" href="#su" title="Permanent link">&para;</a></h4>
<h5 id="_19">命令作用<a class="headerlink" href="#_19" title="Permanent link">&para;</a></h5>
<p><div class="highlight"><pre><span></span><code>su的作用是变更为其它使用者的身份，超级用户除外，需要键入该使用者的密码。
使用方式
su [-fmp] [-c command] [-s shell] [--help] [--version] [-] [USER [ARG]]
参数说明
-f ， – fast：不必读启动文件（如 csh.cshrc 等），仅用于csh或tcsh两种Shell。
-l ， – login：加了这个参数之后，就好像是重新登陆一样，大部分环境变量(例如HOME、SHELL
和USER等)都是以该使用者(USER)为主，并且工作目录也会改变。如果没有指定USER，缺省情况是root。
-m， -p ，–preserve-environment：执行su时不改变环境变数。
-c command：变更账号为USER的使用者，并执行指令（command）后再变回原来使用者。
</code></pre></div>
- help 显示说明文件
- version 显示版本资讯
USER：欲变更的使用者账号，
ARG: 传入新的Shell参数。
例子
<strong>su -c ls root</strong> 变更帐号为 <strong>root</strong> 并在执行 <strong>ls</strong> 指令后退出变回原使用者。
<strong>[user1@centos6 ~]$ su - root -c "head -n 3 /etc/passwd"</strong> 对于命令参数要加上引号
su [用户名]
a&gt;在root用户下, 输入 su 普通用户. 则切换至普通用户, 从root切换到变通用户不需要密码
b&gt;在普通用户下, 输入 su [用户名]
提示 password:
输入用户的PASSWORD, 则切换至该用户</p>
<h4 id="sudo">Sudo<a class="headerlink" href="#sudo" title="Permanent link">&para;</a></h4>
<p>/etc/sudoers 谁能作什么的一个列表，Sudo能用需要在这个文件中定义</p>
<h1 id="visudo_allallall">visudo 增加如下，加%代表用户组，ALL=(ALL)表示登录者的来源主机名，最后的ALL代表可执行<a class="headerlink" href="#visudo_allallall" title="Permanent link">&para;</a></h1>
<p>的命令。NOPASSWD代表不需要密码直接可运行Sudo,限制多命令一定要写绝对路径，用逗号分开，多行用
‘\’，用！代表不能执行
%aixi ALL=(ALL) NOPASSWD: ALL
%aixi ALL=(ALL) NOPASSWD: /bin/ls,/bin/mkdir,/bin/rmdir,\
/usr/bin/who,!/usr/bin/passwd root</p>
<h4 id="_20">查询用户命令<a class="headerlink" href="#_20" title="Permanent link">&para;</a></h4>
<h4 id="w">W<a class="headerlink" href="#w" title="Permanent link">&para;</a></h4>
<h5 id="_21">可显示开机多久，当前登录的所有用户，平均负载<a class="headerlink" href="#_21" title="Permanent link">&para;</a></h5>
<h4 id="who">Who<a class="headerlink" href="#who" title="Permanent link">&para;</a></h4>
<h5 id="_22">显示当前登录的所有用户<a class="headerlink" href="#_22" title="Permanent link">&para;</a></h5>
<h4 id="last">Last<a class="headerlink" href="#last" title="Permanent link">&para;</a></h4>
<h5 id="_23">显示每个用户最后的登录时间<a class="headerlink" href="#_23" title="Permanent link">&para;</a></h5>
<h4 id="lastlog">Lastlog<a class="headerlink" href="#lastlog" title="Permanent link">&para;</a></h4>
<h5 id="_24">显示每个用户最后的登录时间<a class="headerlink" href="#_24" title="Permanent link">&para;</a></h5>
<h2 id="_25">四、 文件权限<a class="headerlink" href="#_25" title="Permanent link">&para;</a></h2>
<h4 id="1">1 、文件类型<a class="headerlink" href="#1" title="Permanent link">&para;</a></h4>
<p><div class="highlight"><pre><span></span><code>Linux广泛的被很多用户所接受，它强大的功能受到很多人喜欢，Linux文件一般是用一些相关的应
用程序创建，比如图像工具、文档工具、归档工具... .... 或 cp工具等。Linux文件的删除方式是用rm 命
令。
Linux文件类型和Linux文件的文件名所代表的意义是两个不同的概念。我们通过一般应用程序而创建的
比如file.txt、file.tar.gz ，这些文件虽然要用不同的程序来打开，但放在Linux文件类型中衡量的话，大
多是常规文件（也被称为普通文件）。
Linux文件类型常见的有：普通文件、目录、字符设备文件、块设备文件、符号链接文件等；现在我们
进行一个简要的说明；
1 普通文件
</code></pre></div>
1. [root@localhost ~]# ls -lh install.log
2. -rw-r--r-- 1 root root 53K 03 -16 08:54 install.log
我 们用 ls -lh 来查看某个文件的属性，可以看到有类似 -rw-r--r-- ，值得注意的是第一个符号是 - ，
这样的文件在Linux中就是普通文件。这些文件一般是用一些相关的应用程序创建，比如图像工具、文
档工具、归档工具... .... 或 cp工具等。这类文件的删除方式是用rm 命令；
2 目录
1. [root@localhost ~]# ls -lh
2. 总计 14M
3. -rw-r--r-- 1 root root 2 03-27 02:00 fonts.scale
4. -rw-r--r-- 1 root root 53K 03- 16 08:54 install.log
5. -rw-r--r-- 1 root root 14M 03 -16 07:53 kernel-6.15-1.2025_FC5.i686.rpm
6. drwxr-xr-x 2 1000 users 4.0K 04 -04 23:30 mkuml-2004.07.17
7. drwxr-xr-x 2 root root 4.0K 04 -19 10:53 mydir
8. drwxr-xr-x 2 root root 4.0K 03 -17 04:25 Public
当 我们在某个目录下执行，看到有类似 drwxr-xr-x ，这样的文件就是目录，目录在Linux是一个比较
特殊的文件。注意它的第一个字符是d。创建目录的命令可以用 mkdir 命令，或cp命令，cp可以把一
个目录复制为另一个目录。删除用rm 或rmdir命令。
3 字符设备或块设备文件</p>
<p>如时您进入/dev目录，列一下文件，会看到类似如下的；</p>
<ol>
<li>[root@localhost ~]# ls -la /dev/tty</li>
<li>crw-rw-rw- 1 root tty 5, 0 04- 19 08:29 /dev/tty</li>
<li>[root@localhost ~]# ls -la /dev/hda1</li>
<li>brw-r----- 1 root disk 3, 1 2006-04-19 /dev/hda1
我们看到/dev/tty的属性是 crw-rw-rw- ，注意前面第一个字符是 c ，这表示字符设备文件。比如猫等
串口设备
我们看到 /dev/hda1 的属性是 brw-r----- ，注意前面的第一个字符是b，这表示块设备，比如硬盘，光
驱等设备；
这个种类的文件，是用mknode来创建，用rm来删除。目前在最新的Linux发行版本中，我们一般不
用自己来创建设备文件。因为这些文件是和内核相关联的。
4 套接口文件
当我们启动MySQL服务器时，会产生一个mysql.sock的文件。</li>
<li>[root@localhost ~]# ls -lh /var/lib/mysql/mysql.sock</li>
<li>srwxrwxrwx 1 mysql mysql 0 04-19 11:12 /var/lib/mysql/mysql.sock
注意这个文件的属性的第一个字符是 s。我们了解一下就行了。
5 符号链接文件</li>
<li>[root@localhost ~]# ls -lh setup.log</li>
<li>lrwxrwxrwx 1 root root 11 04 -19 11:18 setup.log - <strong>&gt;</strong> install.log
当我们查看文件属性时，会看到有类似 lrwxrwxrwx,注意第一个字符是l，这类文件是链接文件。是通过
ln -s 源文件名 新文件名。上面是一个例子，表示setup.log是install.log的软链接文件。怎么理解呢？
这和Windows操作系统中的快捷方式有点相似。
符号链接文件的创建方法举例；</li>
<li>[root@localhost ~]# ls -lh kernel-6.15-1.2025_FC5.i686.rpm</li>
<li>-rw-r--r-- 1 root root 14M 03- 16 07:53 kernel-6.15-1.2025_FC5.i686.rpm</li>
<li>[root@localhost ~]# ln -s kernel-6.15-1.2025_FC5.i686.rpm kernel.rpm</li>
<li>[root@localhost ~]# ls -lh kernel*</li>
<li>-rw-r--r-- 1 root root 14M 03- 16 07:53 kernel-6.15-1.2025_FC5.i686.rpm</li>
<li>lrwxrwxrwx 1 root root 33 04 -19 11:27 kernel.rpm - <strong>&gt;</strong> kernel-6.15-1.2025_FC5</li>
</ol>
<h4 id="2">2 、文件权限<a class="headerlink" href="#2" title="Permanent link">&para;</a></h4>
<p>Linux系统是一个典型的多用户系统，不同的用户处于不同的地位。为了保护系统的安全性，Linux
系统对不同用户访问同一文件的权限做了不同的规定。
对于一个Linux系统中的文件来说，它的权限可以分为三种：读的权限、写的权限和执行的权限，
分别用r、w和x表示。不同的用户具有不同的读、写和执行的权限。
对于一个文件来说，它都有一个特定的所有者，也就是对文件具有所有权的用户。同时，由于在
Linux系统中，用户是按组分类的，一个用户属于一个或多个组。文件所有者以外的用户又可以分为文
件所有者的同组用户和其它用户。因此，Linux系统按文件所有者、文件所有者同组用户和其它用户三
类规定不同的文件访问权限。
权限的概念
Linux文件系统安全模型是通过给系统中的文件赋予两个属性来起作用的，这两个赋予每个文件的
属性称为所有者(ownership)和访问权限(access rights)。Linux下的每一个文件必须严格地属于一个用户和
一个组。
下图是在我机器上的/root目录下运行ls -l命令的情况。</p>
<p><div class="highlight"><pre><span></span><code>-rw-r--r--
这些符号用来描述文件的访问权限类别，也就是常说的文件权限。这些访问权限指导Linux根据文
件的用户和组所有权来处理所有访问文件的用户请求。总共有 10 种权限属性，因此一个权限列表总是
10 个字符的长度。它的格式遵循下列规则：
◆ 第 1 个字符表示一种特殊的文件类型。其中字符可为d(表示该文件是一个目录)、b(表示该文件
是一个系统设备，使用块输入/输出与外界交互，通常为一个磁盘)、c(表示该文件是一个系统设备，使
用连续的字符输入/输出与外界交互，如串口和声音设备)，“.”表示该文件是一个普通文件，没有特殊
属性。
◆ 2 ～ 4 个字符用来确定文件的用户(user)权限， 5 ～ 7 个字符用来确定文件的组(group)权限， 8 ～ 10
个字符用来确定文件的其它用户(other user，既不是文件所有者，也不是组成员的用户)的权限。其中，
2 、 5 、 8 个字符是用来控制文件的读权限的，该位字符为r表示允许用户、组成员或其它人可从该文件
中读取数据。短线“-”则表示不允许该成员读取数据。与此类似， 3 、 6 、 9 位的字符控制文件的写权
限，该位若为w表示允许写，若为“-”表示不允许写。 4 、 7 、 10 位的字符用来控制文件的制造权限，
该位若为x表示允许执行，若为“-”表示不允许执行。
任何列在/etc/passwd文件中的用户都可以是一个文件的所有者，也称为该文件的用户。同样任何
列在/etc/group文件中的组都可以是文件组的所有者，也简称为文件的组。
drwxrwxr-- 2 root root 4096 2月 11 10:36 guo
因为guo的第 1 个位置的字符是d，所以由此知道guo是一个目录。第 2 至 4 位置上的属性是rwx，
表示用户root拥有权限列表显示guo中所有的文件、创建新文件或者删除guo中现有的文件，或者将
guo作为当前工作目录。第 5 至 7 个位置上的权限是rwx，表示root组的成员拥有和root一样的权限。
第 8 至 10 位上的权限仅是r--，表示不是root的用户及不属于root组的成员只有对guo目录列表的权
限。这些用户不能创建或者删除guo中的文件、执行junk中的可执行文件，或者将junk作为他们的当
前工作目录。
</code></pre></div>
<div class="highlight"><pre><span></span><code>-rwxr-xr-- 1 user admin 20480 11月 11 09:23 Readme.txt
在该项中，第 1 个位置是短线“-”，表示该文件是一个普通文件，没有特殊属性。该文件对任何人
都可读，只对user可写，user和admin的组成员可以执行该文件。
另外需要注意的是，当用户访问一个文件时，权限检查是从左到右的。假设上述的readme.txt文件
具有以下权限：
-r--rw-r--
那么即使user是属于admin组的一个成员，也不能对该文件进行写操作，因为已经被左边的写权
限设置拒绝了。
</code></pre></div></p>
<h3 id="r_wx">一般文件权限读（R）， 写 (W)，执行（X）权限比较简单。一般材料上面都<a class="headerlink" href="#r_wx" title="Permanent link">&para;</a></h3>
<h3 id="suidsgidstick_bit">有介绍。这里介绍一下一些特殊的文件权限——SUID，SGID，Stick bit。<a class="headerlink" href="#suidsgidstick_bit" title="Permanent link">&para;</a></h3>
<h3 id="usrbinpasswdtmp">如果你检查一下/usr/bin/passwd和/tmp/的文件权限你就会发现和普<a class="headerlink" href="#usrbinpasswdtmp" title="Permanent link">&para;</a></h3>
<h3 id="_26">通的文件权限有少许不同，如下图所示：<a class="headerlink" href="#_26" title="Permanent link">&para;</a></h3>
<p>这里就涉及到SUID和Stick bit。</p>
<p>SUID和SGID</p>
<p>我们首先来谈一下passwd程序特殊的地方。大家都知道，Linux把用户的密码信息存放
在/etc/shadow里面，该文件属性如下：</p>
<p>可以看到Shadow
的只有所有者可读写，所有者是root，所以该文件对普通用户是不可读写的。但是普通用户调
用passwd程序是可以修改自己的密码的，这又是为什么呢？难道普通用户可以读写shadow
文件？难道Linux有漏洞？当然不是啦。password可以修改shadow文件的原因是他设置了
SUID文件权限。</p>
<p>SUID文件权限作用于可执行文件。一般的可执行文件在执行期的所有者是当前用户，比
如当前系统用户是simon，simon运行程序 a.out，a.out执行期的所有者应该是simon。但是
如果我们给可执行文件设置了SUID权限，则该程序的执行期所有者，就是该文件所有者。还
以 前面的a.out为例，假如a.out设置了SUID，并且其所有者是root，系统当前用户是simon，
当simon运行a.out的时 候，a.out在运行期的所有者就是root，这 时 a.out可以存取只有root
权限才能存取的资源，比如读写shadow文件。当a.out执行结束 的时候当前用户的权限又回
到了simon的权限了。</p>
<p>passwd就是设置了SUID权限，并且passwd的所有者是root，所以所有的用户都可以
执行他，在passwd运行期，程序获得临时的root权限，这时其可以存取shadow文件。当passwd
运行完成，当前用户又回到普通权限。</p>
<p>同理，设置程序的SGID，可以使程序运行期可以临时获得所有者组的权限。在团队开发
的时候，这个文件权限比较有用，一般系统用SUID比较多。</p>
<p>SGID可以用于目录，当目录设置了SGID之后，在该目录下面建立的所有文件和目录都
具有和该目录相同的用户组。</p>
<p>Stick bit(粘贴位)</p>
<p>对程序，该权限告诉系统在程序完成后在内存中保存一份运行程序的备份，如该程序常
用，可为系统节省点时间，不用每次从磁盘加载到内存。Linux当前对文件没有实现这个功能，
一些其他的UNIX系统实现了这个功能。</p>
<p>Stick bit可以作用于目录，在设置了粘贴位的目录下面的文件和目录，只有所有者和root
可以删除他。现在我们可以回头去看看/tmp/目录的情况，这个目录 设置了粘贴位。所以说，
并且所有人都可以对该目录读写执行（ 777 ），这样意味着所有人都可以在/tmp/下面创建临时</p>
<p>目录。因为设置Stick bit只有所有者和root才能删除目录。这样普通用户只能删除属于自己
的文件，而不能删除其他人的文件。如下图所示：</p>
<p>设置SUID，SGID，Stick bit</p>
<p>前面介绍过SUID与SGID的功能，那么，如何打开文件使其成为具有SUID与SGID的
权限呢？这就需要使用数字更改权限了。现在应该知道，使用数字 更改权限的方式为“ 3 个数
字”的组合，那么，如果在这 3 个数字之前再加上一个数字，最前面的数字就表示这几个属性
了（注：通常我们使用chmod xyz filename的方式来设置filename的属性时，则是假设没有
SUID、SGID及Sticky bit）。
4 为SUID
2 为SGID
1 为Sticky bit
假设要将一个文件属性改为“-rwsr-xr-x”，由于s在用户权限中，所以是SUID，因此，在
原先的 755 之前还要加上 4 ，也就是使用“chmod 4755 filename”来设置。</p>
<p>SUID也可以用“chmod u+s filename”来设置，“chmod u-s filename”来取消SUID设
置；同样，SGID可以用“chmod g+s filename”，“chmod g-s filename”来取消SGID设置。</p>
<p>一般来说，使用过Linux的同学都知道，Linux文件的权限有rwx，所有者、所有组、其它用户的rwx权限
是彼此独立的。为此，经常会听到如果某个web文件需要被修改的话，需要加上 777 的权限，这就是让所有
用户可写。</p>
<p>但仔细一想，这样的权限未免有些想得比较天真，没有考滤特殊情况。例如/tmp目录默认权限是 777 ，
而且有些文件也是允许所有用户访问修改的，那么是不 是任何一个用户都可以将这些删除呢？再如
/etc/shadow保存的是用户密码文件，默认情况下它的权限是 640 ，那么只有shadow的 owner(root)才能修
改它，按照常规理解，这是不可理解的，因为每个用户都可能修改密码，也就是会修改这个文件。</p>
<p>为了把这些情况解释清楚，需要引入Linux特殊文件权限的概念。Linux特殊文件权限有三个玩意：
sticky bit、SGID、SUID，以下一一道来。</p>
<p>sticky bit</p>
<p>sticky bit只对目录有效，使目录下的文件，只有文件拥有者才能删除（如果他不属于owner，仅属于
group或者other，就算他有w权限，也不能删除文件）。</p>
<p>加sticky bit的方法：</p>
<p>chmod o+t /tmp或者</p>
<p>chmod 1777 /tmp</p>
<p>查看是否加了sticky bit，用ls -l，可以看到有类似这样的权限：“-rwxrwxrwt”，t就代表已经加
上了sticky bit，而且生效了，如果显示的是“-rwxrwxrwT”，说明也已经加上了sticky bit，但没有生
效（因为本来other就没有写的权限）。</p>
<p>看看/tmp目录的权限，就是drwxrwxrwt吧</p>
<p>SGID(The Set GroupID )</p>
<p>加上SGID的文件，表示运行这个程序时，是临时以这个文件的拥有组的身份运行的；加上SGID的文件
夹，表示在这个目录下创建的文件属于目录所有的组，而不是创建人所在的组，在这个目录下创建的目录继
承本目录的SGID。</p>
<p>加SGID的方法：</p>
<p>chmod g+s /tmp或</p>
<p>chmod 2777 /tmp</p>
<p>查看是否加了SGID，用ls -l，可以看到类似这样的权限“drwxrwsrwx”，s就代表已经加上了SGID，
而且生效，如果显示“drwxrwSrwx”，说明已经加上了SGID，但没有生效（因为本来group就没有执行的
权限）。</p>
<p>SUID(The Set UserID)</p>
<p>SUID与SGID是一样的，惟一不同的是，运行时是以这个文件的拥有者身份来运行。</p>
<p>加SUID的方法：</p>
<p>chmod o+s /tmp或</p>
<p>chmod 4777 /tmp</p>
<p>同样的，加了SUID的文件权限有这类似这两种： “drwsrwxrwx”、“drwSrwxrwx”。</p>
<p>看看passwd命令的权限：ll /usr/bin/passwd，是"-rwsr-x-rx"，终于知道为什么执行passwd时，可
以修改/etc/shadow文件了吧</p>
<p>SUID：置于 u 的 x 位，原位置有执行权限，就置为 s，没有了为 S.
SGID：置于 g 的 x 位，原位置有执行权限，就置为 s，没有了为 S.
STICKY：粘滞位，置于 o 的 x 位，原位置有执行权限，就置为 t ，否则为T.</p>
<h4 id="3">3 、超级权限控制<a class="headerlink" href="#3" title="Permanent link">&para;</a></h4>
<h4 id="linuxrootroot">在Linux操作系统中，root的权限是最高的，也被称为超级权限的拥有者。普通用户无法执行的操作，root用户都能完<a class="headerlink" href="#linuxrootroot" title="Permanent link">&para;</a></h4>
<p>成，所以也被称之为超级管理用户。
在系统中，每个文件、目录和进程，都归属于某一个用户，没有用户许可其它普通用户是无法操作的，但对root除外。root
用户的特权性还表现在root可以超越任何用户和用户组来对文件或目录进行读取、修改或删除（在系统正常的许可范围内）；
对可执行程序的执行、终止；对硬件设备的添加、创建和移除等；也可以对文件和目录进行属主和权限进行修改，以适合系
统管理的需要（因为root是系统中权限最高的特权用户）；</p>
<h4 id="31">3.1 、对超级用户和普通用户的理解<a class="headerlink" href="#31" title="Permanent link">&para;</a></h4>
<h4 id="311">3.1.1、什么是超级用户；<a class="headerlink" href="#311" title="Permanent link">&para;</a></h4>
<p>在所有Linux系统中，系统都是通过UID来区分用户权限级别的，而UID为 0 的用户被系统约定为是具有超级权限。超级用
户具有在系统约定的最高权限满园内操作，所以说超级用户可以完成系统管理的所有工具；我们可以通过/etc/passwd 来查得
UID为 0 的用户是root，而且只有root对应的UID为 0 ，从这一点来看，root用户在系统中是无可替代的至高地位和无限制
权限。root用户在系统中就是超级用户；</p>
<p>3.1. 2 、理解 UID 和用户的对应关系</p>
<p>当系统默认安装时，系统用户和UID 是一对一的对关系，也就是说一个UID 对应一个用户。我们知道用户身份是通过UID 来
确认的，我们在 《用户（user）和用户组（group）配置文件详解》中的UID 的解说中有谈到“UID 是确认用户权限的标识，
用户登录系统所处的角色是通过UID 来实现的，而非用户名；把几个用户共用一个UID 是危险的，比如我们把普通用户的
UID 改为 0 ，和root共用一个UID ，这事实上就造成了系统管理权限的混乱。如果我们想用root权限，可以通过su或sudo
来实现；切不可随意让一个用户和root分享同一个UID ；”</p>
<p>在系统中，能不能让UID 和用户是一对多的关系？是可以的，比如我们可以把一个UID为 0 这个值分配给几个用户共同使用，
这就是UID 和用户的一对多的关系。但这样做的确有点危险；相同UID的用户具有相同的身份和权限。比如我们在系统中把
beinan这个普通用户的UID改为 0 后，事实上这个普通用户就具有了超级权限，他的能力和权限和root用户一样；用户beinan
所有的操作都将被标识为root的操作，因为beinan的UID为0,而UID为 0 的用户是root ，是不是有点扰口？也可以理解为
UID为 0 的用户就是root ，root用户的UID就是 0 ；</p>
<p>UID和用户的一对一的对应关系 ，只是要求管理员进行系统管理时，所要坚守的准则，因为系统安全还是第一位的。所以我
们还是把超级权限保留给root这唯一的用户是最好的选择；</p>
<p>如果我们不把UID的 0 值的分享给其它用户使用，只有root用户是唯一拥有UID=0的话，root用户就是唯一的超级权限用户；</p>
<h4 id="31_3">3.1. 3 、普通用户和伪装用户<a class="headerlink" href="#31_3" title="Permanent link">&para;</a></h4>
<p>与超级用户相对的就是普通用户和虚拟（也被称为伪装用户），普通和伪装用户都是受限用户；但为了完成特定的任务，普
通用户和伪装用户也是必须的；Linux是一个多用户、多任务的操作系统，多用户主要体现在用户的角色的多样性，不同的用
户所分配的权限也不同；这也是Linux系统比Windows系统更为安全的本质所在，即使是现在最新版本的Windows 2003 ，
也无法抹去其单用户系统的烙印；</p>
<h4 id="32">3.2. 超级用户（权限）在系统管理中的作用<a class="headerlink" href="#32" title="Permanent link">&para;</a></h4>
<p>超级权限用户（UID为 0 的用户）到底在系统管理中起什么作用呢？主要表现在以下两点；</p>
<h4 id="32_1">3.2. 1 、对任何文件、目录或进程进行操作；<a class="headerlink" href="#32_1" title="Permanent link">&para;</a></h4>
<p>但值得注意的是这种操作是在系统最高许可范围内的操作；有些操作就是具有超级权限的root也无法完成；</p>
<p>比如/proc 目录，/proc 是用来反应系统运行的实时状态信息的，因此即便是root也无能为力；它的权限如下</p>
<p>[root@localhost ~]# pwd
/root
[root@localhost ~]# cd /
[root@localhost /]# ls -ld /proc/
dr- xr-xr-x 134 root root 0 2005-10-27 /proc/
就是这个目录，只能是读和执行权限，但绝对没有写权限的；就是我们把/proc 目录的写权限打开给root，root用户也是不能
进行写操作；</p>
<p>[root@localhost ~]# chmod 755 /proc
[root@localhost /]# ls -ld /proc/
drwxr-xr-x 134 root root 0 2005-10-27 /proc/
[root@localhost /]# cd /proc/
[root@localhost proc]# mkdir testdir
mkdir: 无法创建目录‘testdir’: 没有那个文件或目录</p>
<h4 id="32_2">3.2. 2 、对于涉及系统全局的系统管理；<a class="headerlink" href="#32_2" title="Permanent link">&para;</a></h4>
<p>硬件管理、文件系统理解、用户管理以及涉及到的系统全局配置等等......如果您执行某个命令或工具时，提示您无权限，大多
是需要超级权限来完成；</p>
<p>比如用adduser来添加用户，这个只能用通过超级权限的用户来完成；</p>
<h3 id="32_3">3.2. 3 、超级权限的不可替代性；<a class="headerlink" href="#32_3" title="Permanent link">&para;</a></h3>
<p>由于超级权限在系统管理中的不可缺少的重要作用，为了完成系统管理任务，我们必须用到超级权限；在一般情况下，为了
系统安全，对于一般常规级别的应用，不需要root用户来操作完成，root用户只是被用来管理和维护系统之用；比如系统日
志的查看、清理，用户的添加和删除......</p>
<p>在不涉及系统管理的工作的环境下，普通用户足可以完成，比如编写一个文件，听听音乐；用gimp 处理一个图片等...... 基
于普通应用程序的调用，大多普通用户就可以完成；</p>
<p>当我们以普通权限的用户登录系统时，有些系统配置及系统管理必须通过超级权限用户完成，比如对系统日志的管理，添加
和删除用户。而如何才能不直接以root登录，却能从普通用户切换到root用户下才能进行操作系统管理需要的工作，这就涉
及到超级权限管理的问题；</p>
<p>获取超级权限的过程，就是切换普通用户身份到超级用户身份的过程；这个过程主要是通过su和sudo 来解决；</p>
<h4 id="33_su">3.3 、使用 su 命令临时切换用户身份；<a class="headerlink" href="#33_su" title="Permanent link">&para;</a></h4>
<h4 id="33_1_su">3.3. 1 、su 的适用条件和威力<a class="headerlink" href="#33_1_su" title="Permanent link">&para;</a></h4>
<p>su命令就是切换用户的工具，怎么理解呢？比如我们以普通用户beinan登录的，但要添加用户任务，执行useradd ，beinan
用户没有这个权限，而这个权限恰恰由root所拥有。解决办法无法有两个，一是退出beinan用户，重新以root用户登录，
但这种办法并不是最好的；二是我们没有必要退出beinan用户，可以用su来切换到root下进行添加用户的工作，等任务完
成后再退出root。我们可以看到当然通过su 切换是一种比较好的办法；</p>
<p>通过su可以在用户之间切换，如果超级权限用户root向普通或虚拟用户切换不需要密码，什么是权力？这就是！而普通用户
切换到其它任何用户都需要密码验证；</p>
<h4 id="33_2_su">3.3. 2 、su 的用法：<a class="headerlink" href="#33_2_su" title="Permanent link">&para;</a></h4>
<p>su [OPTION选项参数] [用户]
-, -l, --login 登录并改变到所切换的用户环境；</p>
<p>-c, --commmand=COMMAND 执行一个命令，然后退出所切换到的用户环境；
至于更详细的，请参看man su ；</p>
<h4 id="33_3_su">3.3. 3 、su 的范例：<a class="headerlink" href="#33_3_su" title="Permanent link">&para;</a></h4>
<p>su 在不加任何参数，默认为切换到root用户，但没有转到root用户家目录下，也就是说这时虽然是切换为root用户了，但
并没有改变root登录环境；用户默认的登录环境，可以在/etc/passwd 中查得到，包括家目录，SHELL定义等；</p>
<p>[beinan@localhost ~]$ su
Password:
[root@localhost beinan]# pwd
/home/beinan
su 加参数 - ，表示默认切换到root用户，并且改变到root用户的环境；</p>
<p>[beinan@localhost ~]$ pwd
/home/beinan
[beinan@localhost ~]$ su -
Password:
[root@localhost ~]# pwd
/root
su 参数 - 用户名</p>
<p>[beinan@localhost ~]$ su - root 注：这个和su - 是一样的功能；
Password:
[root@localhost ~]# pwd
/root
[beinan@localhost ~]$ su - linuxsir 注：这是切换到 linuxsir用户
Password: 注：在这里输入密码；
[linuxsir@localhost ~]$ pwd 注：查看用户当前所处的位置；
/home/linuxsir
[linuxsir@localhost ~]$ id 注：查看用户的UID和GID信息，主要是看是否切换过来了；
uid=505(linuxsir) gid=502(linuxsir) groups=0(root),500(beinan),502(linuxsir)
[linuxsir@localhost ~]$
[beinan@localhost ~]$ su - -c ls 注：这是su的参数组合，表示切换到root用户，并且改变到root环境，然后列出
root家目录的文件，然后退出root用户；
Password: 注：在这里输入root的密码；
anaconda-ks.cfg Desktop install.log install.log.syslog testgroup testgroupbeinan testgrouproot
[beinan@localhost ~]$ pwd 注：查看当前用户所处的位置；
/home/beinan
[beinan@localhost ~]$ id 注：查看当前用户信息；
uid=500(beinan) gid=500(beinan) groups=500(beinan)</p>
<h4 id="33_4_su">3.3. 4 、su的优缺点；<a class="headerlink" href="#33_4_su" title="Permanent link">&para;</a></h4>
<p>su 的确为管理带来方便，通过切换到root下，能完成所有系统管理工具，只要把root的密码交给任何一个普通用户，他都
能切换到root来完成所有的系统管理工作；</p>
<p>但通过su切换到root后，也有不安全因素；比如系统有 10 个用户，而且都参与管理。如果这 10 个用户都涉及到超级权限
的运用，做为管理员如果想让其它用户通过su来切换到超级权限的root，必须把root权限密码都告诉这 10 个用户；如果这</p>
<p>10 个用户都有root权限，通过root权限可以做任何事，这在一定程度上就对系统的安全造成了威协；想想Windows吧，简
直就是恶梦；</p>
<p>“没有不安全的系统，只有不安全的人”，我们绝对不能保证这 10 个用户都能按正常操作流程来管理系统，其中任何一人对系
统操作的重大失误，都可能导致系统崩溃或数据损失；</p>
<p>所以su 工具在多人参与的系统管理中，并不是最好的选择，su只适用于一两个人参与管理的系统，毕竟su并不能让普通用
户受限的使用；</p>
<p>超级用户root密码应该掌握在少数用户手中，这绝对是真理！所以集权而治的存在还是有一定道理的；</p>
<h4 id="34_sudo_su_su">3.4 、 sudo 授权许可使用的 su ，也是受限制的 su<a class="headerlink" href="#34_sudo_su_su" title="Permanent link">&para;</a></h4>
<h4 id="341_sudo">3.4.1. sudo 的适用条件；<a class="headerlink" href="#341_sudo" title="Permanent link">&para;</a></h4>
<p>由于su 对切换到超级权限用户root后，权限的无限制性，所以su并不能担任多个管理员所管理的系统。如果用su 来切换
到超级用户来管理系统，也不能明确哪些工作是由哪个管理员进行的操作。特别是对于服务器的管理有多人参与管理时，最
好是针对每个管理员的技术特长和管理范围，并且有针对性的下放给权限，并且约定其使用哪些工具来完成与其相关的工作，
这时我们就有必要用到 sudo。</p>
<p>通过sudo，我们能把某些超级权限有针对性的下放，并且不需要普通用户知道root密码，所以sudo 相对于权限无限制性的
su来说，还是比较安全的，所以sudo 也能被称为受限制的su ；另外sudo 是需要授权许可的，所以也被称为授权许可的
su；</p>
<p>sudo 执行命令的流程是当前用户切换到root（或其它指定切换到的用户），然后以root（或其它指定的切换到的用户）身份
执行命令，执行完成后，直接退回到当前用户；而这些的前提是要通过sudo的配置文件/etc/sudoers来进行授权；</p>
<h4 id="34_2_sudo_etcsudoers">3.4. 2 、从编写 sudo 配置文件/etc/sudoers开始；<a class="headerlink" href="#34_2_sudo_etcsudoers" title="Permanent link">&para;</a></h4>
<p>sudo的配置文件是/etc/sudoers ，我们可以用他的专用编辑工具visodu ，此工具的好处是在添加规则不太准确时，保存退
出时会提示给我们错误信息；配置好后，可以用切换到您授权的用户下，通过sudo -l 来查看哪些命令是可以执行或禁止的；</p>
<p>/etc/sudoers 文件中每行算一个规则，前面带有#号可以当作是说明的内容，并不执行；如果规则很长，一行列不下时，可以
用\号来续行，这样看来一个规则也可以拥有多个行；</p>
<p>/etc/sudoers 的规则可分为两类；一类是别名定义，另一类是授权规则；别名定义并不是必须的，但授权规则是必须的；</p>
<h4 id="34_3_etcsudoers">3.4. 3 、/etc/sudoers 配置文件中别名规则<a class="headerlink" href="#34_3_etcsudoers" title="Permanent link">&para;</a></h4>
<p>别名规则定义格式如下：</p>
<p>Alias_Type NAME = item1, item2, ...
或</p>
<p>Alias_Type NAME = item1, item2, item3 : NAME = item4, item5
别名类型（Alias_Type）：别名类型包括如下四种</p>
<p>Host_Alias 定义主机别名；</p>
<p>User_Alias 用户别名，别名成员可以是用户，用户组（前面要加%号）</p>
<p>Runas_Alias 用来定义runas别名，这个别名指定的是“目的用户”，即sudo 允许切换至的用户；</p>
<p>Cmnd_Alias 定义命令别名；</p>
<p>NAME 就是别名了，NMAE的命名是包含大写字母、下划线以及数字，但必须以一个大写字母开头，比如SYNADM、SYN_ADM
或SYNAD0是合法的，sYNAMDA或1SYNAD是不合法的；</p>
<p>item 按中文翻译是项目，在这里我们可以译成成员，如果一个别名下有多个成员，成员与成员之间，通过半角,号分隔；成员
在必须是有效并事实存在的。什么是有效的呢？比如主机名，可以通过w查看用户的主机名（或ip地址），如果您只是本地
机操作，只通过hostname 命令就能查看；用户名当然是在系统中存在的，在/etc/paswd中必须存在；对于定义命令别名，
成员也必须在系统中事实存在的文件名（需要绝对路径）；</p>
<p>item成员受别名类型 Host_Alias、User_Alias、Runas_Alias、Cmnd_Alias 制约，定义什么类型的别名，就要有什么类型的
成员相配。我们用Host_Alias定义主机别名时，成员必须是与主机相关相关联，比如是主机名（包括远程登录的主机名）、
ip地址（单个或整段）、掩码等；当用户登录时，可以通过w命令来查看登录用户主机信息；用User_Alias和Runas_Alias
定义时，必须要用系统用户做为成员；用Cmnd_Alias 定义执行命令的别名时，必须是系统存在的文件，文件名可以用通配
符表示，配置Cmnd_Alias时命令需要绝对路径；</p>
<p>其中 Runas_Alias 和User_Alias 有点相似，但与User_Alias 绝对不是同一个概念，Runas_Alias 定义的是某个系统用户
可以sudo 切换身份到Runas_Alias 下的成员；我们在授权规则中以实例进行解说；</p>
<p>别名规则是每行算一个规则，如果一个别名规则一行容不下时，可以通过\来续行；同一类型别名的定义，一次也可以定义几
个别名，他们中间用:号分隔，</p>
<p>Host_Alias HT01=localhost,st05,st04,10,0,0,4,255.255.255.0,192.168.1.0/24 注：定义主机别名HT01，通过=号列
出成员
Host_Alias HT02=st09,st10 注：主机别名HT02，有两个成员；
Host_Alias HT01=localhost,st05,st04,10,0,0,4,255.255.255.0,192.168.1.0/24:HT02=st09,st 10 注：上面的两条对
主机的定义，可以通过一条来实现，别名之间用:号分割；
注：我们通过Host_Alias 定义主机别名时，项目可以是主机名、可以是单个ip（整段ip地址也可以），也可以是网络掩码；
如果是主机名，必须是多台机器的网络中，而且这些机器得能通过主机名相互通信访问才有效。那什么才算是通过主机名相
互通信或访问呢？比如 ping 主机名，或通过远程访问主机名来访问。在我们局域网中，如果让计算机通过主机名访问通信，
必须设置/etc/hosts，/etc/resolv.conf ，还要有DNS做解析，否则相互之间无法通过主机名访问；在设置主机别名时，如果
项目是中某个项目是主机名的话，可以通过hostname 命令来查看本地主机的主机名，通过w命令查来看登录主机是来源，
通过来源来确认其它客户机的主机名或ip地址；对于主机别名的定义，看上去有点复杂，其实是很简单。</p>
<p>如果您不明白Host_Alias 是怎么回事，也可以不用设置主机别名，在定义授权规则时通过ALL来匹配所有可能出现的主机情
况。如果您把主机方面的知识弄的更明白，的确需要多多学习。</p>
<p>User_Alias SYSAD=beinan,linuxsir,bnnnb,lanhaitun 注：定义用户别名，下有四个成员；要在系统中确实在存在的；
User_Alias NETAD=beinan,bnnb 注：定义用户别名NETAD ，我想让这个别名下的用户来管理网络，所以取了NETAD的
别名；
User_Alias WEBMASTER=linuxsir 注：定义用户别名WEBMASTER，我想用这个别名下的用户来管理网站；
User_Alias SYSAD=beinan,linuxsir,bnnnb,lanhaitun:NETAD=beinan,bnnb:WEBMASTER=linuxsir 注：上面三行的别名
定义，可以通过这一行来实现，请看前面的说明，是不是符合？
Cmnd_Alias USERMAG=/usr/sbin/adduser,/usr/sbin/userdel,/usr/bin/passwd [A-Za-z]*,/bin/chown,/bin/chmod
注意：命令别名下的成员必须是文件或目录的绝对路径；
Cmnd_Alias DISKMAG=/sbin/fdisk,/sbin/parted
Cmnd_Alias NETMAG=/sbin/ifconfig,/etc/init.d/network
Cmnd_Alias KILL = /usr/bin/kill
Cmnd_Alias PWMAG = /usr/sbin/reboot,/usr/sbin/halt
Cmnd_Alias SHELLS = /usr/bin/sh, /usr/bin/csh, /usr/bin/ksh, \
/usr/local/bin/tcsh, /usr/bin/rsh, \
/usr/local/bin/zsh
注：这行定义命令别名有点长，可以通过  号断行；</p>
<p>Cmnd_Alias SU = /usr/bin/su,/bin,/sbin,/usr/sbin,/usr/bin
在上面的例子中，有KILL和PWMAG的命令别名定义，我们可以合并为一行来写，也就是等价行；</p>
<p>Cmnd_Alias KILL = /usr/bin/kill:PWMAG = /usr/sbin/reboot,/usr/sbin/halt 注：这一行就代表了KILL和PWMAG
命令别名，把KILL和PWMAG的别名定义合并在一行写也是可以的；
Runas_Alias OP = root, operator
Runas_Alias DBADM=mysql:OP = root, operator 注：这行是上面两行的等价行；至于怎么理解Runas_Alias ，我们必须
得通过授权规则的实例来理解；</p>
<h4 id="34_4_etcsudoers">3.4. 4 、/etc/sudoers中的授权规则：<a class="headerlink" href="#34_4_etcsudoers" title="Permanent link">&para;</a></h4>
<p>授权规则是分配权限的执行规则，我们前面所讲到的定义别名主要是为了更方便的授权引用别名；如果系统中只有几个用户，
其实下放权限比较有限的话，可以不用定义别名，而是针对系统用户直接直接授权，所以在授权规则中别名并不是必须的；</p>
<p>授权规则并不是无章可寻，我们只说基础一点的，比较简单的写法，如果您想详细了解授权规则写法的，请参看man sudoers</p>
<p>授权用户 主机=命令动作
这三个要素缺一不可，但在动作之前也可以指定切换到特定用户下，在这里指定切换的用户要用( )号括起来，如果不需要密
码直接运行命令的，应该加NOPASSWD:参数，但这些可以省略；举例说明；</p>
<p>实例一：</p>
<p>beinan ALL=/bin/chown,/bin/chmod
如果我们在/etc/sudoers 中添加这一行，表示beinan 可以在任何可能出现的主机名的系统中，可以切换到root用户下执行
/bin/chown 和/bin/chmod 命令，通过sudo -l 来查看beinan 在这台主机上允许和禁止运行的命令；</p>
<p>值得注意的是，在这里省略了指定切换到哪个用户下执行/bin/shown 和/bin/chmod命令；在省略的情况下默认为是切换到root
用户下执行；同时也省略了是不是需要beinan用户输入验证密码，如果省略了，默认为是需要验证密码。</p>
<p>为了更详细的说明这些，我们可以构造一个更复杂一点的公式；</p>
<p>授权用户 主机=[(切换到哪些用户或用户组)] [是否需要密码验证] 命令1,[(切换到哪些用户或用户组)] [是否需要密码验证]
[命令2],[(切换到哪些用户或用户组)] [是否需要密码验证] [命令3]......</p>
<p>注解：</p>
<p>凡是[ ]中的内容，是可以省略；命令与命令之间用,号分隔；通过本文的例子，可以对照着看哪些是省略了，哪些地方需要有
空格；</p>
<p>在[(切换到哪些用户或用户组)] ，如果省略，则默认为root用户；如果是ALL ，则代表能切换到所有用户；注意要切换到的
目的用户必须用()号括起来，比如(ALL)、(beinan)</p>
<p>实例二：</p>
<p>beinan ALL=(root) /bin/chown, /bin/chmod
如果我们把第一个实例中的那行去掉，换成这行；表示的是beinan 可以在任何可能出现的主机名的主机中，可以切换到root
下执行 /bin/chown ，可以切换到任何用户招执行/bin/chmod 命令，通过sudo -l 来查看beinan 在这台主机上允许和禁止运
行的命令；</p>
<p>实例三：</p>
<p>beinan ALL=(root) NOPASSWD: /bin/chown,/bin/chmod</p>
<p>如果换成这个例子呢？表示的是beinan 可以在任何可能出现的主机名的主机中，可以切换到root下执行 /bin/chown ，不需
要输入beinan用户的密码；并且可以切换到任何用户下执行/bin/chmod 命令，但执行chmod时需要beinan输入自己的密
码；通过sudo -l 来查看beinan 在这台主机上允许和禁止运行的命令；</p>
<p>关于一个命令动作是不是需要密码，我们可以发现在系统在默认的情况下是需要用户密码的，除非特加指出不需要用户需要
输入自己密码，所以要在执行动作之前加入NOPASSWD: 参数；</p>
<p>有可能有的弟兄对系统管理的命令不太懂，不知道其用法，这样就影响了他对 sudoers定义的理解，下面我们再举一个最简
单，最有说服务力的例子；</p>
<p>实例四：</p>
<p>比如我们想用beinan普通用户通过more /etc/shadow文件的内容时，可能会出现下面的情况；</p>
<p>[beinan@localhost ~]$ more /etc/shadow
/etc/shadow: 权限不够
这时我们可以用sudo more /etc/shadow 来读取文件的内容；就就需要在/etc/soduers中给beinan授权；</p>
<p>于是我们就可以先su 到root用户下通过visudo 来改/etc/sudoers ；（比如我们是以beinan用户登录系统的）</p>
<p>[beinan@localhost ~]$ su
Password: 注：在这里输入root密码
下面运行visodu；
[root@localhost beinan]# visudo 注：运行visudo 来改 /etc/sudoers
加入如下一行，退出保存；退出保存，在这里要会用vi，visudo也是用的vi编辑器；至于vi的用法不多说了；</p>
<p>beinan ALL=/bin/more 表示beinan可以切换到root下执行more 来查看文件；
退回到beinan用户下，用exit命令；</p>
<p>[root@localhost beinan]# exit
exit
[beinan@localhost ~]$
查看beinan的通过sudo能执行哪些命令？</p>
<p>[beinan@localhost ~]$ sudo -l
Password: 注：在这里输入beinan用户的密码
User beinan may run the following commands on this host: 注：在这里清晰的说明在本台主机上，beinan用户可以以
root权限运行more ；在root权限下的more ，可以查看任何文本文件的内容的；
(root) /bin/more
最后，我们看看是不是beinan用户有能力看到/etc/shadow文件的内容；</p>
<p>[beinan@localhost ~]$ sudo more /etc/shadow
beinan 不但能看到 /etc/shadow文件的内容，还能看到只有root权限下才能看到的其它文件的内容，比如；</p>
<p>[beinan@localhost ~]$ sudo more /etc/gshadow
对于beinan用户查看和读取所有系统文件中，我只想把/etc/shadow 的内容可以让他查看；可以加入下面的一行；</p>
<p>beinan ALL=/bin/more /etc/shadow
题外话：有的弟兄会说，我通过su 切换到root用户就能看到所有想看的内容了，哈哈，对啊。但咱们现在不是在讲述sudo
的用法吗？如果主机上有多个用户并且不知道root用户的密码，但又想查看某些他们看不到的文件，这时就需要管理员授权
了；这就是sudo的好处；</p>
<p>实例五：练习用户组在/etc/sudoers中写法；</p>
<p>如果用户组出现在/etc/sudoers 中，前面要加%号，比如%beinan ，中间不能有空格；</p>
<p>%beinan ALL=/usr/sbin/<em>,/sbin/</em>
如果我们在 /etc/sudoers 中加上如上一行，表示beinan用户组下的所有成员，在所有可能的出现的主机名下，都能切换到
root用户下运行 /usr/sbin和/sbin目录下的所有命令；</p>
<p>实例六：练习取消某类程序的执行；</p>
<p>取消程序某类程序的执行，要在命令动作前面加上!号； 在本例中也出现了通配符的*的用法；</p>
<p>beinan ALL=/usr/sbin/<em>,/sbin/</em>,!/usr/sbin/fdisk 注：把这行规则加入到/etc/sudoers中；但您得有beinan这个用
户组，并且beinan也是这个组中的才行；
本规则表示beinan用户在所有可能存在的主机名的主机上运行/usr/sbin和/sbin下所有的程序，但fdisk 程序除外；</p>
<p>[beinan@localhost ~]$ sudo -l</p>
<p>Password: 注：在这里输入beinan用户的密码；</p>
<p>User beinan may run the following commands on this host:</p>
<p>(root) /usr/sbin/*</p>
<p>(root) /sbin/*</p>
<p>(root) !/sbin/fdisk</p>
<p>[beinan@localhost ~]$ sudo /sbin/fdisk -l</p>
<p>Sorry, user beinan is not allowed to execute '/sbin/fdisk -l' as root on localhost.</p>
<p>注：不能切换到root用户下运行fdisk 程序；</p>
<p>实例七：别名的运用的实践；</p>
<p>假如我们就一台主机localhost，能通过hostname 来查看，我们在这里就不定义主机别名了，用ALL来匹配所有可能出现的
主机名；并且有beinan、linuxsir、lanhaitun 用户；主要是通过小例子能更好理解；sudo虽然简单好用，但能把说的明白的
确是件难事；最好的办法是多看例子和man soduers ；</p>
<p>User_Alias SYSADER=beinan,linuxsir,%beinan
User_Alias DISKADER=lanhaitun
Runas_Alias OP=root
Cmnd_Alias SYDCMD=/bin/chown,/bin/chmod,/usr/sbin/adduser,/usr/bin/passwd [A-Za- z]*,!/usr/bin/passwd
root
Cmnd_Alias DSKCMD=/sbin/parted,/sbin/fdisk 注：定义命令别名DSKCMD，下有成员parted和fdisk ；
SYSADER ALL= SYDCMD,DSKCMD
DISKADER ALL=(OP) DSKCMD
注解：</p>
<p>第一行：定义用户别名SYSADER 下有成员 beinan、linuxsir和beinan用户组下的成员，用户组前面必须加%号；</p>
<p>第二行：定义用户别名 DISKADER ，成员有lanhaitun</p>
<p>第三行：定义Runas用户，也就是目标用户的别名为OP，下有成员root</p>
<p>第四行：定义SYSCMD命令别名，成员之间用,号分隔，最后的!/usr/bin/passwd root 表示不能通过passwd 来更改root密
码；</p>
<p>第五行：定义命令别名DSKCMD，下有成员parted和fdisk ；</p>
<p>第六行： 表示授权SYSADER下的所有成员，在所有可能存在的主机名的主机下运行或禁止 SYDCMD和DSKCMD下定义
的命令。更为明确遥说，beinan、linuxsir和beinan用户组下的成员能以root身份运行 chown 、chmod 、adduser、passwd，
但不能更改root的密码；也可以以root身份运行 parted和fdisk ，本条规则的等价规则是；</p>
<p>beinan,linuxsir,%beinan ALL=/bin/chown,/bin/chmod,/usr/sbin/adduser,/usr/bin/passwd
[A- Za-z]*,!/usr/bin/passwd root,/sbin/parted,/sbin/fdisk
第七行：表示授权DISKADER 下的所有成员，能以OP的身份，来运行 DSKCMD ，不需要密码；更为明确的说 lanhaitun
能以root身份运行 parted和fdisk 命令；其等价规则是：</p>
<p>lanhaitun ALL=(root) /sbin/parted,/sbin/fdisk
可能有的弟兄会说我想不输入用户的密码就能切换到root并运行SYDCMD和DSKCMD 下的命令，那应该把把NOPASSWD:
加在哪里为好？理解下面的例子吧，能明白的；</p>
<p>SYSADER ALL= NOPASSWD: SYDCMD, NOPASSWD: DSKCMD</p>
<h4 id="34_5_etcsudoers">3.4. 5 、/etc/sudoers中其它的未尽事项；<a class="headerlink" href="#34_5_etcsudoers" title="Permanent link">&para;</a></h4>
<p>在授权规则中，还有 NOEXEC:和EXEC的用法，自己查man sudoers 了解；还有关于在规则中通配符的用法，也是需要了
解的。这些内容不多说了，毕竟只是一个入门性的文档。soduers配置文件要多简单就有多简单，要多难就有多难，就看自己
的应用了。</p>
<h4 id="34_6_sudo">3.4. 6 、sudo的用法；<a class="headerlink" href="#34_6_sudo" title="Permanent link">&para;</a></h4>
<p>我们在前面讲的/etc/sudoers 的规则写法，最终的目的是让用户通过sudo读取配置文件中的规则来实现匹配和授权，以便替
换身份来进行命令操作，进而完成在其权限下不可完成的任务；</p>
<p>我们只说最简单的用法；更为详细的请参考man sudo</p>
<p>sudo [参数选项] 命令</p>
<p>-l 列出用户在主机上可用的和被禁止的命令；一般配置好/etc/sudoers后，要用这个命令来查看和测试是不是配置正确的；</p>
<p>-v 验证用户的时间戳；如果用户运行sudo 后，输入用户的密码后，在短时间内可以不用输入口令来直接进行sudo 操作；
用-v 可以跟踪最新的时间戳；</p>
<p>-u 指定以以某个用户执行特定操作；</p>
<p>-k 删除时间戳，下一个sudo 命令要求用求提供密码；</p>
<p>举列：</p>
<p>首先我们通过visudo 来改/etc/sudoers 文件，加入下面一行；</p>
<p>beinan,linuxsir,%beinan ALL=/bin/chown,/bin/chmod,/usr/sbin/adduser,/usr/bin/passwd
[A- Za-z]*,!/usr/bin/passwd root,/sbin/parted,/sbin/fdisk
然后列出beinan用户在主机上通过sudo 可以切换用户所能用的命令或被禁止用的命令；</p>
<p>[beinan@localhost ~]$ sudo -l 注：列出用户在主机上能通过切换用户的可用的或被禁止的命令；
Password: 注：在这里输入您的用户密码；
User beinan may run the following commands on this host:
(root) /bin/chown 注：可以切换到root下用chown命令；
(root) /bin/chmod 注：可以切换到root下用chmod命令；
(root) /usr/sbin/adduser 注：可以切换到root下用adduser命令；
(root) /usr/bin/passwd [A-Za-z]* 注：可以切换到root下用 passwd 命令；</p>
<p>(root) !/usr/bin/passwd root 注：可以切换到root下，但不能执行passwd root 来更改root密码；
(root) /sbin/parted 注：可以切换到 root下执行parted ；
(root) /sbin/fdisk 注：可以切换到root下执行 fdisk ；
通过上面的sudo -l 列出可用命令后，我想通过chown 命令来改变/opt目录的属主为beinan ；</p>
<p>[beinan@localhost ~]$ ls -ld /opt 注：查看/opt的属主；
drwxr-xr-x 26 root root 4096 10月 27 10:09 /opt 注：得到的答案是归属root用户和root用户组；
[beinan@localhost ~]$ sudo chown beinan:beinan /opt 注：通过chown 来改变属主为beinan用户和beinan用户组；
[beinan@localhost ~]$ ls -ld /opt 注：查看/opt属主是不是已经改变了；
drwxr-xr-x 26 beinan beinan 4096 10月 27 10:09 /opt
我们通过上面的例子发现beinan用户能切换到root后执行改变用户口令的passwd命令；但上面的sudo -l 输出又明文写着
不能更改root的口令；也就是说除了root的口令，beinan用户不能更改外，其它用户的口令都能更改。下面我们来测试；</p>
<p>对于一个普通用户来说，除了更改自身的口令以外，他不能更改其它用户的口令。但如果换到root身份执行命令，则可以更
改其它用户的口令；</p>
<p>比如在系统中有linuxsir这个用户, 我们想尝试更改这个用户的口令，</p>
<p>[beinan@localhost ~]$ passwd linuxsir 注：不通过sudo 直接运行passwd 来更改linuxsir用户的口令；
passwd: Only root can specify a user name. 注：失败，提示仅能通过 root来更改；
[beinan@localhost ~]$ sudo passwd linuxsir 注：我们通过/etc/sudoers 的定义，让beinan切换到root下执行 passwd
命令来改变linuxsir的口令；
Changing password for user linuxsir.
New UNIX password: 注：输入新口令；
Retype new UNIX password: 注：再输入一次；
passwd: all authentication tokens updated successfully. 注：改变成功；</p>
<h3 id="_27">后记：<a class="headerlink" href="#_27" title="Permanent link">&para;</a></h3>
<p>本文是用户管理的文档的重要组成部份，我计划在明天开始写用户管理控制工具，比如 useradd、userdel、usermod ，也就
是管理用户的工具介绍；当然我还会写用户查询工具等与用户管理相关的</p>
<h4 id="4">4 、权限命令<a class="headerlink" href="#4" title="Permanent link">&para;</a></h4>
<h4 id="41_chmod">4.1 、 chmod<a class="headerlink" href="#41_chmod" title="Permanent link">&para;</a></h4>
<p>文件或者目录的用户能够使用chmod命令修改文件的权限。Chmod命令有两种方式：一种是字符方
式，使用字符来修改文件的权限；另外一种是数字方式，使用 3 个数字的组合来修改文件的权限。
使用方式 : chmod [-cfvR] [--help] [--version] mode file...
说明 : Linux/Unix 的档案调用权限分为三级 : 档案拥有者、群组、其他。利用 chmod 可以借以控制档
案如何被他人所调用。
参数 :
mode : 权限设定字串，格式如下 : [ugoa...][[+-=][rwxX]...][,...]，其中
u 表示该档案的拥有者，g 表示与该档案的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表
示这三者皆是。
+ 表示增加权限、- 表示取消权限、= 表示唯一设定权限。
r 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该档案是个子目录或者该档案已经被设定
过为可执行。
-c : 若该档案权限确实已经更改，才显示其更改动作</p>
<p>-f : 若该档案权限无法被更改也不要显示错误讯息
-v : 显示权限变更的详细资料
-R : 对目前目录下的所有档案与子目录进行相同的权限变更(即以递回的方式逐个变更)
--help : 显示辅助说明
--version : 显示版本
范例 :
将档案 file1.txt 设为所有人皆可读取 : chmod ugo+r file1.txt
将档案 file1.txt 设为所有人皆可读取 : chmod a+r file1.txt
将档案 file1.txt 与 file2.txt 设为该档案拥有者，与其所属同一个群体者可写入，但其他以外的人则不
可写入 : chmod ug+w,o-w file1.txt file2.txt
将 ex1.py 设定为只有该档案拥有者可以执行 : chmod u+x ex1.py
将目前目录下的所有档案与子目录皆设为任何人可读取 : chmod -R a+r *
数字方式的基本语法是：chmod nnn 文件
其中第 1 、 2 、 3 个n分别表示用户、组成员和所有其它用户。各个位置上的n要么是一个 0 ，或者是一
个由赋予权限的相关值相加得到的单个阿拉伯数字之和。这些数字的意义如表 1 所示。
值 表示的意义
4 表示文件或者目录的读权限
2 表示文件或者目录的写权限
1 表示文件或者目录的执行权限
很显然，当使用数字方式时，这 3 个数字必须为 0 至 7 中的一个。
若要rwx属性则4+2+1=7；
若要rw-属性则4+2=6；
若要r-x属性则4+1=7。
范例：
chmod a=rwx file 和 chmod 777 file 效果相同
chmod ug=rwx,o=x file 和 chmod 771 file 效果相同
若用chmod 4755 filename可使此程序具有root的权限</p>
<h4 id="42_umask">4.2 、 umask<a class="headerlink" href="#42_umask" title="Permanent link">&para;</a></h4>
<h5 id="_28">很显然，系统中各种文件的权限设置对特定用户的数据安全有很大影响。但是要求用户逐一明确设<a class="headerlink" href="#_28" title="Permanent link">&para;</a></h5>
<p>置系统中每个文件的权限也是不现实的，为此，需要使用umask命令，该命令可以为用户账号中新文
件的创建进行缺省设置。系统管理员必须要为你设置一个合理的u m a s k值，以确保你创建的文件具有
所希望的缺省权限，防止其他非同组用户对你的文件具有写权限。具体来说，umask是用来设置权限掩
码的，权限掩码由 3 个数字组成，将现有的存取权限减掉权限掩码后，即可产生建立文件时默认的权限。
语 法：umask [-S][权限掩码]
补充说明：umask可用来设定[权限掩码]。[权限掩码]是由 3 个八进制的数字所组成，将现有的存
取权限减掉权限掩码后，即可产生建立文件时预设的权限。
参 数：
-S 以文字的方式来表示权限掩码。
登录之后，可以按照个人的偏好使用u m a s k命令来改变文件创建的缺省权限。相应的改变直到退
出该s h e l l或使用另外的u m a s k命令之前一直有效。一般来说，u m a s k命令是在/ e t c / p r o f i l e
文件中设置的，每个用户在登录时都会引用这个文件，所以如果希望改变所有用户的u m a s k，可以在
该文件中加入相应的条目。如果希望永久性地设置自己的u m a s k值，那么就把它放在自己$ H O M E
目录下的. p r o f i l e或. b a s h _ p r o f i l e文件中。
如何计算umask值</p>
<p>u m a s k命令允许你设定文件创建时的缺省模式，对应每一类用户(文件属主、同组用户、其他用
户)存在一个相应的u m a s k值中的数字。对于文件来说，这一数字的最大值分别是 6 。系统不允许你
在创建一个文本文件时就赋予它执行权限，必须在创建后用c h m o d命令增加这一权限。目录则允许
设置执行权限，这样针对目录来说， u m a s k中各个数字最大可以到 7 。该命令的一般形式为：
umask nnn
其中n n n为u m a s k置0 0 0 - 7 7 7。
计算u m a s k值：可以有几种计算u m a s k值的方法，通过设置u m a s k值，可以为新创建的文
件和目录设置缺省权限。
例如，对于u m a s k值0 0 2，相应的文件和目录缺省创建权限是什么呢？
第一步，我们首先写下具有全部权限的模式，即7 7 7 (所有用户都具有读、写和执行权限)。
第二步，在下面一行按照u m a s k值写下相应的位，在本例中是0 0 2。
第三步，在接下来的一行中记下上面两行中没有匹配的位。这就是目录的缺省创建权限。稍加练习
就能够记住这种方法。
第四步，对于文件来说，在创建时不能具有文件权限，只要拿掉相应的执行权限比特即可。
这就是上面的例子，其中u m a s k值为0 0 2：
1) 文件的最大权限rwx rwx rwx (777)
2) umask值为0 0 2 - - - - - - -w-
3) 目录权限rwx rwx r-x (775) 这就是目录创建缺省权限
4) 文件权限rw- rw- r-- (664) 这就是文件创建缺省权限
系统默认的umask码是 0022 也就是：目录 755(rwx,rx,rx) ，文件：644(rw,r,r) 。
umask码的换算
0022 + 0755 = 0777 对应默认目录权限 反之 0777 - 0755 = 0022
0022 + 0644 +0111 = 0777 对应默认文件权限 反之 0777 - 0111 - 0644 = 0022
哈哈~~ 简单吧！假如我们要将默认目录权限设置为 744 那么对应的umask 是 0777 - 0744 =
0033 ，然后执行umask 0033命令就将umask码改成 0033 了。
下面是另外一个例子，假设这次u m a s k值为0 2 2：
1) 文件的最大权限rwx rwx rwx (777)
2 ) u m a s k值为0 2 2 - - - -w- -w-
3) 目录权限rwx r-x r-x (755) 这就是目录创建缺省权限
4) 文件权限rw- r-- r-- (644) 这就是文件创建缺省权限
下面是常用的u m a s k值及对应的文件和目录权限
umask值 目录 文件
0 2 2 7 5 5 6 4 4
0 2 7 7 5 0 6 4 0
0 0 2 7 7 5 6 6 4
0 0 6 7 7 1 6 6 0
0 0 7 7 7 0 6 6 0
如果想知道当前的umask 值，可以使用u m a s k命令：如果想要改变u m a s k值，只要使用u m a
s k命令设置一个新的值即可：
$ umask 002
确认一下系统是否已经接受了新的u m a s k值：在使用u m a s k命令之前一定要弄清楚到底希望
具有什么样的文件/目录创建缺省权限。否则可能会得到一些非常奇怪的结果；例如，如果将u m a s k
值设置为6 0 0，那么所创建的文件/目录的缺省权限就是0 6 6！除非你有特殊需要，否则没有必要去管
他，系统默认的值“ 022 ”umask是用的掩码，至于掩码的概念，从基础学吧，这里不说了。</p>
<div class="highlight"><pre><span></span><code>linux中的文件/目录许可是用 4 位八进制数表示的。其中第一个八进制数用来表示特殊许可设置，
第二个数字用来设置文件所有者的许可，第三个数字用来设置组许可，第四个数字用来设置所有人的许
可。
例如，root的权限为 777 ，若权限掩码设为 022 ，那么两都相减后可得 755 。下面是在我的系统更
改umask的一些情况：
[root@linuxserver root]# umask
022
上述命令显示表示我的系统的umask值为 022 。
[root@linuxserver root]# umask -S
u=rwx,g=rx,o=rx
当umask值为 022 时，默认情况下各用户的权限。注意这里的参数“S”是大写。
[root@linuxserver root]# umask 177
[root@linuxserver root]# umask -S
u=rw,g=,o=
上述两行命令把umask值改为 177 ，结果只有文件所有者具有读写文件的权限，其它用户不能访问
该文件。这显然是一种非常安全的状态。
</code></pre></div>
<h4 id="43_chown">4.3 、 chown<a class="headerlink" href="#43_chown" title="Permanent link">&para;</a></h4>
<p>chown 命令用途更改与文件关联的所有者或组。
语法chown[ -f ] [ -h] [ -R ] Owner [ :Group ] { File ... | Directory ... }
描述chown命令将 File 参数指定的文件的所有者更改为 Owner 参数指定的用户。Owner 参数的值可
以是可在 /etc/passwd 文件中找到的用户标识或登录名。还可以选择性地指定组。Group 参数的值可以是可
在 /etc/group 文件中找到的组标识或组名。
只有 root 用户可以更改文件的所有者。只在您是 root 用户或拥有该文件的情况下才可以更改文件的
组。如果拥有文件但不是 root 用户，则只可以将组更改为您是其成员的组。
虽然 -H、-L 和 -P 标志是互斥的，指定不止一个也不认为是错误。指定的最后一个标志确定命令拟稿
将演示的操作。
参数：
-f 禁止除用法消息之外的所有错误消息。
-h 更改遇到的符号链接的所有权，而非符号链接指向的文件或目录的所有权。 当遇到符号链接而您未
指定 -h 标志时，chown 命令更改链接指向的文件或目录的所有权，而非链接本身的所有权。如果指定
-R 标志，chown 命令递归地降序指定的目录。-H 如果指定了 -R 选项，并且引用类型目录的文件的符
号链接在命令行上指定，chown 变量会更改由符号引用的目录的用户标识（和组标识，如果已指定）
和所有在该目录下的文件层次结构中的所有文件。
-L 如果指定了 -R 选项，并且引用类型目录的文件的符号在命令行上指定或在遍历文件层次结构期间遇
到，chown 命令会更改由符号链接引用的目录的用户标识（和组标识，如果已指定）和在该目录之下
的文件层次结构中的所有文件。
-P 如果指定了 -R 选项并且符号链接在命令行上指定或者在遍历文件层次结构期间遇到，则如果系统
支持该操作，则 chown 命令会更改符号链接的所有者标识（和组标识，如果已指定）。chown 命令不
会执行至文件层次结构的任何其它部分的符号链接。
-R 递归地降序目录，更改每个文件的所有权。当遇到符号链接并且链接指向目录时，更改该目录的所
有权，但不进一步遍历目录。不过 -h、-H、-L or -P 标志也未指定，则当遇到符号链接并且该链接指向
到目录时，该目录的组所有权更改但不会进一步遍历目录。 安全性访问控制：此程序应该作为“可信计
算基”中的正常用户程序安装。退出状态该命令返回以下出口值： 0 命令执行成功并已执行所有请求的
更改。 &gt;0 发生错误。</p>
<h5 id="_29">示例：<a class="headerlink" href="#_29" title="Permanent link">&para;</a></h5>
<p>要更改文件 program.c 的所有者： chown jim program.cprogram.c的用户访问权限现在应用到 jim。作
为所有者，jim 可以使用 chmod命令允许或拒绝其他用户访问 program.c。
要将目录 /tmp/src 中所有文件的所有者和组更改为用户 john 和组 build： chown -R john:build
/tmp/src文件
将档案 file1.txt 的拥有者设为 users 群体的使用者 jessie :
chown jessie:users file1.txt
将目前目录下的所有档案与子目录的拥有者皆设为 users 群体的使用者 lamport :
chmod -R lamport:users *</p>
<h4 id="44_chgrp">4.4 、 chgrp<a class="headerlink" href="#44_chgrp" title="Permanent link">&para;</a></h4>
<h5 id="_30">功能说明：变更文件或目录的所属群组。<a class="headerlink" href="#_30" title="Permanent link">&para;</a></h5>
<p>语 法：chgrp [-cfhRv][--help][--version][所属群组][文件或目录...] 或 chgrp [-cfhRv][--help][--reference=&lt;参
考文件或目录&gt;][--version][文件或目录...]
补充说明：在UNIX系统家族里，文件或目录权限的掌控以拥有者及所属群组来管理。您可以使用chgrp指
令去变更文件与目录的所属群组，设置方式采用群组名称或群组识别码皆可。
参 数：
-c或--changes 效果类似"-v"参数，但仅回报更改的部分。
-f或--quiet或--silent 不显示错误信息。
-h或--no-dereference 只对符号连接的文件作修改，而不更动其他任何相关文件。
-R或--recursive 递归处理，将指定目录下的所有文件及子目录一并处理。
-v或--verbose 显示指令执行过程。
--help 在线帮助。
--reference=&lt;参考文件或目录&gt; 把指定文件或目录的所属群组全部设成和参考文件或目录的所属群组相
同。
--version 显示版本信息。
范例：
[root@linux ~]# chgrp users install.log
[root@linux ~]#ls –l
-rw-r--r-- 1 root users 28490 Jun 25 08:53 install.log
[root@linux ~]#chgrp testing install.log
chgrp:invalid group name ‘testing’ &lt;==出现错误信息～找不到这个用户组名～
发现了吗？文件的用户组被改成了users了，但要改成testing的时候，就会发生错误。注意，出现错误信
息后，要检查错误信息的内容。</p>
<h2 id="_31">五、 目录结构<a class="headerlink" href="#_31" title="Permanent link">&para;</a></h2>
<h5 id="_32">目录结构及主要内容“/”根目录部分有以下子目录：<a class="headerlink" href="#_32" title="Permanent link">&para;</a></h5>
<div class="highlight"><pre><span></span><code>◆/usr 目录包含所有的命令、程序库、文档和其它文件。这些文件在正常操作中不会被改变的。这个
目录也包含你的Linux发行版本的主要的应用程序，譬如，Netscape。
◆/var 目录包含在正常操作中被改变的文件：假脱机文件、记录文件、加锁文件、临时文件和页格式
化文件等。这个目录中存放着那些不断在扩充着的东西，为了保持/usr的相对稳定，那些经常被修改的
目录可以放在这个目录下，实际上许多系统管理员都是这样干的。顺带说一下系统的日志文件就在
/var/log目录中。
</code></pre></div>
<p>◆/home 目录包含用户的文件：参数设置文件、个性化文件、文档、数据、EMAIL、缓存数据等。这个
目录在系统省级时应该保留。
◆/proc 目录整个包含虚幻的文件。它们实际上并不存在磁盘上，也不占用任何空间。（用ls –l 可以
显示它们的大小）当查看这些文件时，实际上是在访问存在内存中的信息，这些信息用于访问系统
◆/bin 系统启动时需要的执行文件（二进制），这些文件可以被普通用户使用。
◆/sbin 系统执行文件（二进制），这些文件不打算被普通用户使用。（普通用户仍然可以使用它们，但
要指定目录。）
◆/etc 操作系统的配置文件目录。
◆/root 系统管理员（也叫超级用户或根用户）的Home目录。
◆/dev 设备文件目录。LINUX下设备被当成文件，这样一来硬件被抽象化，便于读写、网络共享以及
需要临时装载到文件系统中。正常情况下，设备会有一个独立的子目 录。这些设备的内容会出现在独
立的子目录下。LINUX没有所谓的驱动符。
◆/lib 根文件系统目录下程序和核心模块的共享库。
◆/boot 用于自举加载程序（LILO或GRUB）的文件。当计算机启动时（如果有多个操作系统，有可能
允许你选择启动哪一个操作系统），这些文件首先被装载。这个目录也会包含LINUX核（压缩文件vmlinuz），
但LINUX核也可以存在别处，只要配置LILO并且LILO知道LINUX核在哪儿。
◆/opt 可选的应用程序，譬如，REDHAT 5.2下的KDE （REDHAT 6 .0下，KDE放在其它的XWINDOWS应
用程序中，主执行程序在/usr/bin目录下）
◆/tmp 临时文件。该目录会被自动清理干净。
◆/lost+found 在文件系统修复时恢复的文件
◆/usr目录下比较重要的部分有：
◆/usr/X11R6 X-WINDOWS系统（version 11, release 6)
◆/usr/X11 同/usr/X11R6 （/usr/X11R6的符号连接）
◆/usr/X11R6/bin 大量的小X-WINDOWS应用程序（也可能是一些在其它子目录下大执行文件的符号连
接 ）。
◆/usr/doc LINUX的文档资料（在更新的系统中，这个目录移到/usr/share/doc）。
◆/usr/share 独立与你计算机结构的数据，譬如，字典中的词。
◆/usr/bin和/usr/sbin 类似与“/”根目录下对应的目录（/bin和/sbin），但不用于基本的启动（譬如，
在紧急维护中）。大多数命令在这个目录下。
◆/usr/local 本地管理员安装的应用程序（也可能每个应用程序有单独的子目录）。在“main”安装后，
这个目录可能是空的。这个目录下的内容在重安装或升级操作系统后应该存在。
◆/usr/local/bin 可能是用户安装的小的应用程序，和一些在/usr/local目录下大应用程序的符号连接。
◆/proc目录的内容：
◆/proc/cpuinfo 关于处理器的信息，如类型、厂家、型号和性能等。
◆/proc/devices 当前运行内核所配置的所有设备清单。
◆/proc/dma 当前正在使用的DMA通道。/proc/filesystems 当前运行内核所配置的文件系统。
◆/proc/interrupts 正在使用的中断，和曾经有多少个中断。
◆/proc/ioports 当前正在使用的I/O端口。
举例，使用下面的命令能读出系统的CPU信息。
cat /proc/cpuinfo</p>
<div class="highlight"><pre><span></span><code>/bin bin是binary的缩写。这个目录沿袭了UNIX系统的结构，存放着使用者最经常使
用的命令。例如cp、ls、cat，等等。
/boot 这里存放的是启动Linux时使用的一些核心文件。
</code></pre></div>
<p><div class="highlight"><pre><span></span><code>/dev dev是device（设备）的缩写。这个目录下是所有Linux的外部设备，其功能类似
DOS下的.sys和Win下的.vxd。在 Linux中设备和文件是用同种方法访问的。例如：
/dev/hda代表第一个物理IDE硬盘。
/etc 这个目录用来存放系统管理所需要的配置文件和子目录。
/home 用户的主目录，比如说有个用户叫wang，那他的主目录就是/home/wang也可以
用~wang表示。
/lib 这个目录里存放着系统最基本的动态链接共享库，其作用类似于Windows里的.dll
文件。几乎所有的应用程序都须要用到这些共享库。
/lost+found 这个目录平时是空的，当系统不正常关机后，这里就成了一些无家可归的文件的
避难所。对了，有点类似于DOS下的.chk文件。
/mnt 这个目录是空的，系统提供这个目录是让用户临时挂载别的文件系统。
/proc 这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个
目录来获取系统信息。也就是说，这个目录的内容不在硬盘上而是在内存里。
/root 系统管理员（也叫超级用户）的主目录。作为系统的拥有者，总要有些特权啊！
比如单独拥有一个目录。
/sbin s就是Super User的意思，也就是说这里存放的是系统管理员使用的管理程序。
/tmp 这个目录不用说，一定是用来存放一些临时文件的地方了。
</code></pre></div>
/usr (^) 这是最庞大的目录，我们要用到的应用程序和文件几乎都存放在这个目录下。其
中包含以下子目录；
/usr/X11R6 存放X-Window的目录；
/usr/bin 存放着许多应用程序；
/usr/sbin 给超级用户使用的一些管理程序就放在这里；
/usr/doc 这是Linux文档的大本营；
/usr/include (^) Linux下开发和编译应用程序需要的头文件，在这里查找；
/usr/lib 存放一些常用的动态链接共享库和静态档案库；
/usr/local 这是提供给一般用户的/usr目录，在这里安装软件最适合；
/usr/man (^) man在Linux中是帮助的同义词，这里就是帮助文档的存放目录；
/usr/src Linux开放的源代码就存在这个目录，爱好者们别放过哦！
/var 这个目录中存放着那些不断在扩充着的东西，为了保持/usr的相对稳定，那些经
常被修改的目录可以放在这个目录下，实际上许多系统管理员都是这样干的。顺
带说一下系统的日志文件就在/var/log目录中。</p>
<h5 id="_33">总结来说：<a class="headerlink" href="#_33" title="Permanent link">&para;</a></h5>
<p>◆用户应该将文件存在/home/user_login_name目录下(及其子目录下)。
◆本地管理员大多数情况下将额外的软件安装在/usr/local目录下并符号连接在/usr/local/bin下的主执
行程序。
◆系统的所有设置在/etc目录下。
◆不要修改根目录（“/”） 或/usr目录下的任何内容，除非真的清楚要做什么。这些目录最好和LINUX
发布时保持一致。</p>
<div class="highlight"><pre><span></span><code>◆大多数工具和应用程序安装在目录：/bin, /usr/sbin, /sbin, /usr/x11/bin,/usr/local/bin。
◆所有的文件在单一的目录树下。没有所谓的“驱动符”。
</code></pre></div>
<h2 id="_34">六、 软件安装<a class="headerlink" href="#_34" title="Permanent link">&para;</a></h2>
<h4 id="rpm">RPM<a class="headerlink" href="#rpm" title="Permanent link">&para;</a></h4>
<p>RPM软件的安装、删除、更新只有root权限才能使用；对于查询功能任何用户都可以操作；如果普通
用户拥有安装目录的权限，也可以进行安装。
初始化rpm 数据库
通过rpm 命令查询一个rpm 包是否安装了，也是要通过rpm 数据库来完成的；所以我们要经常用下面
的两个命令来初始化rpm 数据库；
[root@localhost beinan]# rpm --initdb
[root@localhost beinan]# rpm --rebuilddb 注：这个要花好长时间；
注：这两个参数是极为有用，有时rpm系统出了问题，不能安装和查询，大多是这里出了问题；
/var/lib/rpm目录下的数据库记录所有软件的升级需求，记录已经安装的所有软件，数字证书记录等，这
个目录下的文件非常重要。</p>
<h4 id="rpm_1">RPM 软件包管理的查询功能：<a class="headerlink" href="#rpm_1" title="Permanent link">&para;</a></h4>
<h5 id="_35">命令格式<a class="headerlink" href="#_35" title="Permanent link">&para;</a></h5>
<p><div class="highlight"><pre><span></span><code>rpm {-q|-- query} [select-options] [query-options]
RPM的查询功能是极为强大，是极为重要的功能之一；举几个常用的例子，更为详细的具体的，请参考
#man rpm
</code></pre></div>
<strong>1</strong> 、查询系统已安装的软件；</p>
<p><div class="highlight"><pre><span></span><code>语法：rpm -q 软件名
举例：
[root@localhost beinan]# rpm –q gaim
gaim-1.3.0-1.fc4
-q就是 -- query ，中文意思是“问”，此命令表示的是，是不是系统安装了gaim ；如果已安装会有
信息输出；如果没有安装，会输出gaim 没有安装的信息；查看系统中所有已经安装的包，要加 -a 参
数；
[root@localhost RPMS]# rpm -qa
如果分页查看，再加一个管道 |和more命令；
[root@localhost RPMS]# rpm -qa |more
在所有已经安装的软件包中查找某个软件，比如说 gaim ；可以用 grep 抽取出来；
[root@localhost RPMS]# rpm -qa |grep gaim
上面这条的功能和 rpm -q gaim 输出的结果是一样的；
等 37448
</code></pre></div>
<strong>2</strong> 、查询一个已经安装的文件属于哪个软件包；</p>
<p><div class="highlight"><pre><span></span><code>语法 rpm -qf 文件名 注：文件名所在的绝对路径要指出举例：
[root@localhost RPMS]# rpm -qf /usr/lib/libacl.la
libacl-devel-2.2.23-8
</code></pre></div>
<strong>3</strong> 、查询已安装软件包都安装到何处；</p>
<div class="highlight"><pre><span></span><code>语法：rpm -ql 软件名 或 rpm rpmquery -ql 软件名
</code></pre></div>
<h5 id="_36">举例：<a class="headerlink" href="#_36" title="Permanent link">&para;</a></h5>
<p><div class="highlight"><pre><span></span><code>[root@localhost RPMS]# rpm -ql lynx
[root@localhost RPMS]# rpmquery -ql lynx
</code></pre></div>
<strong>4</strong> 、查询一个已安装软件包的信息</p>
<p><div class="highlight"><pre><span></span><code>语法格式： rpm -qi 软件名
举例：
[root@localhost RPMS]# rpm -qi lynx
</code></pre></div>
<strong>5</strong> 、查看一下已安装软件的配置文件；</p>
<p><div class="highlight"><pre><span></span><code>语法格式：rpm -qc 软件名
举例：
[root@localhost RPMS]# rpm -qc lynx
</code></pre></div>
<strong>6</strong> 、查看一个已经安装软件的文档安装位置：</p>
<p><div class="highlight"><pre><span></span><code>语法格式： rpm -qd 软件名
举例：
[root@localhost RPMS]# rpm -qd lynx
</code></pre></div>
<strong>7</strong> 、查看一下已安装软件所依赖的软件包及文件；</p>
<p><div class="highlight"><pre><span></span><code>语法格式： rpm -qR 软件名
举例：
[root@localhost beinan]# rpm -qR rpm -python
查询已安装软件的总结：对于一个软件包已经安装，我们可以把一系列的参数组合起来用；比如 rpm
-qil ；比如：
[root@localhost RPMS]# rpm -qil lynx
对已安装软件包查询的一点补充；
</code></pre></div>
<div class="highlight"><pre><span></span><code>[root@localhost RPMS]# updatedb
[root@localhost RPMS]# locate 软件名或文件名
通过updatedb，我们可以用 locate 来查询一些软件安装到哪里了；系统初次安装时要执行updatedb ，
每隔一段时间也要执行一次；以保持已安装软件库最新；updatedb 是slocate软件包所有；如果您没
有这个命令，就得安装slocate ；举例：
[root@localhost RPMS]# locate gaim
</code></pre></div></p>
<h4 id="_37">对于未安装的软件包的查看：<a class="headerlink" href="#_37" title="Permanent link">&para;</a></h4>
<p>查看的前提是您有一个.rpm 的文件，也就是说对既有软件file.rpm的查看等；</p>
<p><strong>1</strong> 、查看一个软件包的用途、版本等信息；</p>
<p><div class="highlight"><pre><span></span><code>语法： rpm -qpi file.rpm
举例：
[root@localhost RPMS]# rpm -qpi lynx-2.8.5-23.i386.rpm
</code></pre></div>
<strong>2</strong> 、查看一件软件包所包含的文件；</p>
<div class="highlight"><pre><span></span><code>语法： rpm -qpl file.rpm
举例：
[root@localhost RPMS]# rpm -qpl lynx-2.8.5-23.i386.rpm
</code></pre></div>
<h5 id="3_1">3 、查看软件包的文档所在的位置；<a class="headerlink" href="#3_1" title="Permanent link">&para;</a></h5>
<p><div class="highlight"><pre><span></span><code>语法： rpm -qpd file.rpm
举例：
[root@localhost RPMS]# rpm -qpd lynx-2.8.5-23.i386.rpm
</code></pre></div>
<strong>4</strong> 、查看一个软件包的配置文件；</p>
<p><div class="highlight"><pre><span></span><code>语法： rpm -qpc file.rpm
举例：
[root@localhost RPMS]# rpm -qpc lynx-2.8.5-23.i386.rpm
</code></pre></div>
<strong>5</strong> 、查看一个软件包的依赖关系</p>
<div class="highlight"><pre><span></span><code>语法： rpm -qpR file.rpm
举例：
[root@localhost archives]# rpm -qpR yumex_0.42-3.0.fc4_noarch.rpm
/bin/bash
/usr/bin/python
config(yumex) = 0.42-3.0.fc4
pygtk2
pygtk2-libglade
rpmlib(CompressedFileNames) &lt;= 3.0.4- 1
rpmlib(PayloadFilesHavePrefix) &lt;= 4.0-1
usermode
yum &gt;= 2.3.2
</code></pre></div>
<h4 id="_38">软件包的安装、升级、删除等；<a class="headerlink" href="#_38" title="Permanent link">&para;</a></h4>
<p><strong>1</strong> 、安装和升级一个 <strong>rpm</strong> 包；</p>
<p>[root@localhost beinan]#rpm -vih file.rpm 注：这个是用来安装一个新的rpm 包；
[root@localhost beinan]#rpm -Uvh file.rpm 注：这是用来升级一个rpm 包；
如果有依赖关系的，请解决依赖关系，其实软件包管理器能很好的解决依赖关系，请看前面的软件包管理器
的介绍；如果您在软件包管理器中也找不到依赖关系的包；那只能通过编译他所依赖的包来解决依赖关系，
或者强制安装；语法结构：
[root@localhost beinan]# rpm -ivh file.rpm --nodeps --force
[root@localhost beinan]# rpm -Uvh file.rpm --nodeps --force
更多的参数，请查看 man rpm 举例应用：
[root@localhost RPMS]# rpm -ivh lynx-2.8.5-23.i386.rpm
Preparing... ########################################### [100%]
1:lynx ########################################### [100%]
[root@localhost RPMS]# rpm -ivh --replacepkgs lynx-2.8.5-23.i386.rpm
Preparing... ########################################### [100%]
1:lynx ########################################### [100%]
注： --replacepkgs 参数是以已安装的软件再安装一次；有时没有太大的必要；测试安装参数 --test ，
用来检查依赖关系；并不是真正的安装；
[root@localhost RPMS]# rpm -ivh --test gaim-1.3.0-1.fc4.i386.rpm
Preparing... ########################################### [100%]</p>
<p>由新版本降级为旧版本，要加 --oldpackage 参数；
[root@localhost RPMS]# rpm -qa gaim
gaim-1.5.0-1.fc4
[root@localhost RPMS]# rpm -Uvh --oldpackage gaim-1.3.0-1.fc4.i386.rpm
Preparing... ########################################### [100%]
1:gaim ########################################### [100%]
[root@localhost RPMS]# rpm -qa gaim
gaim-1.3.0-1.fc4
为软件包指定安装目录：要加 -relocate 参数；下面的举例是把gaim-1.3.0-1.fc4.i386.rpm指定安装在
/opt/gaim 目录中；
[root@localhost RPMS]# rpm -ivh --relocate /=/opt/gaim gaim-1.3.0-1.fc4.i386.rpm
Preparing... ########################################### [100%]
1:gaim ########################################### [100%]
[root@localhost RPMS]# ls /opt/
gaim
为软件包指定安装目录：要加 -relocate 参数；下面的举例是把lynx-2.8.5-23.i386.rpm 指定安装在
/opt/lynx 目录中；
[root@localhost RPMS]# rpm -ivh --relocate /=/opt/lynx --badreloc lynx-2.8.5-23.i386.rpm
Preparing... ########################################### [100%]
1:lynx ########################################### [100%]
我们安装在指定目录中的程序如何调用呢？一般执行程序，都放在安装目录的bin或者sbin目录中；看下
面的例子；如果有错误输出，就做相应的链接，用 ln -s ；
[root@localhost RPMS]# /opt/lynx/usr/bin/lynx
Configuration file /etc/lynx.cfg is not available.
[root@localhost RPMS]# ln -s /opt/lynx/etc/lynx.cfg /etc/lynx.cfg
[root@localhost RPMS]# /opt/lynx/usr/bin/lynx <a href="http://www.linuxsir.org">http://www.linuxsir.org</a>
RPM管理包管理器支持网络安装和查询；
比如我们想通过 Fedora Core 4.0 的一个镜像查询、安装软件包；地址：
<a href="http://mirrors.kernel.org/fedora/core/4/i386/os/Fedora/RPMS/">http://mirrors.kernel.org/fedora/core/4/i386/os/Fedora/RPMS/</a> 举例：命令格式：
rpm 参数 rpm包文件的http或者ftp的地址</p>
<h1 id="rpm_-qpi_httpmirrorskernelorgfedoracore4i386os">rpm -qpi <a href="http://mirrors.kernel.org/fedora/core/4/i386/os/">http://mirrors.kernel.org/fedora/core/4/i386/os/</a><a class="headerlink" href="#rpm_-qpi_httpmirrorskernelorgfedoracore4i386os" title="Permanent link">&para;</a></h1>
<p>Fedora/RPMS/gaim-1.3.0-1.fc4.i386.rpm</p>
<h1 id="rpm_-ivh_httpmirrorskernelorgfedoracore4i386os">rpm -ivh <a href="http://mirrors.kernel.org/fedora/core/4/i386/os/">http://mirrors.kernel.org/fedora/core/4/i386/os/</a><a class="headerlink" href="#rpm_-ivh_httpmirrorskernelorgfedoracore4i386os" title="Permanent link">&para;</a></h1>
<p>Fedora/RPMS/gaim-1.3.0-1.fc4.i386.rpm</p>
<p><strong>2</strong> 、删除一个 <strong>rpm</strong> 包；</p>
<p>首先您要学会查询rpm 包 ；请看前面的说明； [root@localhost beinan]#rpm -e 软件包名 举例：我想
移除lynx 包，完整的操作应该是：
[root@localhost RPMS]# rpm -e lynx
如果有依赖关系，您也可以用--nodeps 忽略依赖的检查来删除。但尽可能不要这么做，最好用软件包管理
器 systerm-config-packages 来删除或者添加软件；
[root@localhost beinan]# rpm -e lynx --nodeps</p>
<h4 id="rpm_2">RPM 验证与数字证书：<a class="headerlink" href="#rpm_2" title="Permanent link">&para;</a></h4>
<h5 id="_39">导入签名：<a class="headerlink" href="#_39" title="Permanent link">&para;</a></h5>
<p>[root@localhost RPMS]# rpm --import 签名文件 举例：
[root@localhost fc40]# rpm --import RPM-GPG-KEY
[root@localhost fc40]# rpm --import RPM-GPG-KEY -fedora
RPM验证作用是使用/var/lib/rpm下面的数据库内容来比较目前linux系统的环境下的所有软件文件，也就
是说当你有数据不小心丢失，或者不小心修改到某个软件的文件内容，就用这个简单的方法验证一下原本的
文件系统</p>
<h1 id="rpm_va">rpm –Va 列出目前系统上面所有可能被改动过的文件<a class="headerlink" href="#rpm_va" title="Permanent link">&para;</a></h1>
<h4 id="rpm_3">从 rpm 软件包抽取文件；<a class="headerlink" href="#rpm_3" title="Permanent link">&para;</a></h4>
<p>命令格式： rpm2cpio file.rpm |cpio -div
举例：
[root@localhost RPMS]# rpm2cpio gaim-1.3.0-1.fc4.i386.rpm |cpio -div
抽取出来的文件就在当用操作目录中的 usr 和etc中；其实这样抽到文件不如指定安装目录来安装软件来
的方便；也一样可以抽出文件；为软件包指定安装目录：要加 -relocate 参数；下面的举例是把
gaim-1.3.0-1.fc4.i386.rpm指定安装在 /opt/gaim 目录中；
[root@localhost RPMS]# rpm -ivh --relocate /=/opt/gaim gaim-1.3.0-1.fc4.i386.rpm
Preparing... ########################################### [100%]
1:gaim ########################################### [100%]
[root@localhost RPMS]# ls /opt/
gaim
这样也能一目了然；gaim的所有文件都是安装在 /opt/gaim 中，我们只是把gaim 目录备份一下，然后卸
掉gaim；这样其实也算提取文件的一点用法；</p>
<h4 id="rpm_4">RPM 的配置文件；<a class="headerlink" href="#rpm_4" title="Permanent link">&para;</a></h4>
<p>RPM包管理，的配置文件是 rpmrc ，我们可以在自己的系统中找到；比如Fedora Core 4.0中的rpmrc 文
件位于；
[root@localhost RPMS]# locate rpmrc
/usr/lib/rpm/rpmrc
/usr/lib/rpm/redhat/rpmrc
我们可以通过 rpm --showrc 查看；具体的还得我们自己来学习。呵。。。不要问我，我也不懂；只要您
看了这篇文章，认为对您有用，您的水平就和我差不多；咱们水平是一样的，所以我不能帮助您了；请
理解。</p>
<h4 id="yum">YUM<a class="headerlink" href="#yum" title="Permanent link">&para;</a></h4>
<h4 id="yum_1">YUM 配置文件<a class="headerlink" href="#yum_1" title="Permanent link">&para;</a></h4>
<p>创建容器，位置在 <strong>/etc/yum.repos.d</strong> ，扩展名必须是 <strong>.repo</strong></p>
<div class="highlight"><pre><span></span><code>#cd /etc/yum.repos.d
#vim yum.repo 新建一个仓库文件，名字可以随便定义，在文件中写如下内容
[base] #代表容器名称，中括号一定要存在，里面的名字可随便取
name=base #说明这个容器的意义，随便写都可以
baseurl=ftp://192.168.0.6/pub/Server #192. 168. 0. 6是你的YUM源地址，这个很重要。
enabled=1 #是否启动，=0则不启动，不启动就无法使用该源
gpgcheck=0 #是否验证. 可不要
gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-redhat-release ＃验证的密钥. 可不要
</code></pre></div>
<p>命令 <strong>:#yum repolist all</strong> 显示目前所使用的容器有哪些
如果查询出来的容器，status为disabled，要将配置文件，如上enabled=1</p>
<p><strong>/etc/yum.conf</strong></p>
<p><strong>yum.conf</strong> 这个配置文件主要是 <strong>yum</strong> 客户端使用，里面主要规定了要去用的 <strong>rpm</strong> 包的 <strong>yum</strong> 服务器的信
息。
[main] #main开头的块用于对客户端进行配置，在main后也可以指定yum源（不推荐这样做），与
/etc/yum.repo.d中指定yum源相同
cachedir=/var/cache/yum</p>
<h1 id="cachediryumyumrpmvarcacheyum">cachedir：yum缓存的目录，yum在此存储下载的rpm包和数据库，一般是/var/cache/yum。<a class="headerlink" href="#cachediryumyumrpmvarcacheyum" title="Permanent link">&para;</a></h1>
<p>keepcache=0 #0表示不保存下载的文件， 1 表示保存下载的文件，默认为不保存
debuglevel=2</p>
<h1 id="debuglevel_0_10_2">debuglevel：除错级别， 0 ──10,默认是 2 貌似只记录安装和删除记录<a class="headerlink" href="#debuglevel_0_10_2" title="Permanent link">&para;</a></h1>
<p>logfile=/var/log/yum.log #指定yum的日志文件
pkgpolicy=newest #包的策略，如果配置多了yum源，同一软件在不同的yum源中有不同版本，
newest则安装最新版本，该值为lastest，则yum会将服务器上ID按照字母序排列，选择最后那个服务器上
的软件安装
distroverpkg=centos-release</p>
<h1 id="yumredhat-release">指定一个软件包，yum会根据这个包判断你的发行版本，默认是redhat-release，也可以是安装的任何<a class="headerlink" href="#yumredhat-release" title="Permanent link">&para;</a></h1>
<p>针对自己发行版的rpm包。
tolerant=1</p>
<h1 id="tolerent_1_0_yum">tolerent，也有 1 和 0 两个选项，表示yum是否容忍命令行发生与软件包有关的错误，比如你要安装<a class="headerlink" href="#tolerent_1_0_yum" title="Permanent link">&para;</a></h1>
<p>1,2,3三个包，而其中 3 此前已经 安装了，如果你设为1,则yum不会出现错误信息。默认是 0 。
exactarch=1</p>
<h1 id="exactarch_1_0cpu_1">exactarch，有两个选项 1 和0,代表是否只升级和你安装软件包cpu体系一致的包，如果设为 1 ，则如<a class="headerlink" href="#exactarch_1_0cpu_1" title="Permanent link">&para;</a></h1>
<p>你安装了一个i386的rpm，则yum不会用i686的包来升级。
retries=20</p>
<h1 id="retries_0">retries，网络连接发生错误后的重试次数，如果设为 0 ，则会无限重试。<a class="headerlink" href="#retries_0" title="Permanent link">&para;</a></h1>
<p>obsoletes=1
gpgcheck=1</p>
<h1 id="gpgchkeck_1_0_gpg">gpgchkeck= 有 1 和 0 两个选择，分别代表是否是否进行gpg校验，如果没有这一项，默认是检查的。<a class="headerlink" href="#gpgchkeck_1_0_gpg" title="Permanent link">&para;</a></h1>
<p>pl ugins = 1 #是否启用插件，默认 1 为允许， 0 表示不允许
reposdir=/etc/yy.rm #默认是 /etc/yum.repos.d/ 低下的 xx.repo后缀文件</p>
<h1 id="include_etcyumreposdxxrepo">默认都会被include 进来 也就是说 /etc/yum.repos.d/xx.repo 无论配置文件有多少个 每个里面有多少<a class="headerlink" href="#include_etcyumreposdxxrepo" title="Permanent link">&para;</a></h1>
<p>个[name]最后其实都被整合到 一个里面看就是了 重复的[name]应该是前面覆盖后面的--还是后面的覆盖前
面的呢？enabled 测试是后面覆盖前面
exclude=xxx</p>
<h1 id="exclude">exclude 排除某些软件在升级名单之外，可以用通配符，列表中各个项目要用空格隔开，这个对于安<a class="headerlink" href="#exclude" title="Permanent link">&para;</a></h1>
<p>装了诸如美化包，中文补丁的朋友特别有用。
keepcache=[1 or 0]</p>
<h1 id="keepcache1yum_headers">设置 keepcache=1，yum 在成功安装软件包之后保留缓存的头文件 (headers) 和软件包。默认值为<a class="headerlink" href="#keepcache1yum_headers" title="Permanent link">&para;</a></h1>
<p>keepcache=0 不保存
reposdir=[包含 .repo 文件的目录的绝对路径]</p>
<h1 id="repo_repo_etcyumconf">该选项用户指定 .repo 文件的绝对路径。.repo 文件包含软件仓库的信息 (作用与 /etc/yum.conf 文件<a class="headerlink" href="#repo_repo_etcyumconf" title="Permanent link">&para;</a></h1>
<p>中的 [repository] 片段相同)。中</p>
<h4 id="yum_2">YUM 命令<a class="headerlink" href="#yum_2" title="Permanent link">&para;</a></h4>
<p>用YUM安装删除软件yum install xxx，yum会查询数据库，有无这一软件包，如果有，则检查其依赖冲
突关系，如果没有依赖冲突，那么最好，下载安装;如果有，则会给出提示，询问是否要同时安装依赖，或
删除冲突的包，你可以自己作出判断。
删除的命令是，yum remove xxx，同安装一样，yum也会查询数据库，给出解决依赖关系的提示。</p>
<p><strong>YUM</strong> 安装软件包</p>
<p>命令：yum install</p>
<p><strong>YUM</strong> 删除软件包</p>
<p>命令：yum remove
用YUM查询软件信息，我们常会碰到这样的情况，想要安装一个软件，只知道它和某方面有关，但又
不能确切知道它的名字。这时yum的查询功能就起作用了。你可以用yum search keyword这样的命令来进
行搜索，比如我们要则安装一个Instant Messenger，但又不知到底有哪些，这时不妨用yum search messenger
这样的指令进行搜索，yum会搜索所有可用rpm的描述，列出所有描述中和messeger有关的rpm包，于是
我们可能得到gaim，kopete等等，并从中选择。有时我们还会碰到安装了一个包，但又不知道其用途，我
们可以用yum info packagename这个指令来获取信息。
1.使用YUM查找软件包
命令：yum search
2.列出所有可安装的软件包
命令：yum list
3.列出所有可更新的软件包
命令：yum list updates
4.列出所有已安装的软件包
命令：yum list installed
5.列出所有已安装但不在 Yum Repository 內的软件包
命令：yum list extras
6.列出所指定的软件包
命令：yum list
7.使用YUM获取软件包信息
命令：yum info
8.列出所有软件包的信息
命令：yum info
9.列出所有可更新的软件包信息
命令：yum info updates
10.列出所有已安裝的软件包信息
命令：yum info installed
11.列出所有已安裝但不在 Yum Repository 內的软件包信息
命令：yum info extras
12.列出软件包提供哪些文件
命令：yum provides</p>
<h4 id="yum_3">清除 YUM 缓存<a class="headerlink" href="#yum_3" title="Permanent link">&para;</a></h4>
<p>yum会把下载的软件包和header存储在cache中，而不会自动删除。如果我们觉得它们占用了磁盘空间，
可以使用yum clean指令进行清除，更精确的用法是yum clean headers清除header，yum clean packages清
除下载的rpm包，yum clean all一股脑儿端
1.清除缓存目录(/var/cache/yum)下的软件包
命令：yum clean packages
2.清除缓存目录(/var/cache/yum)下的 headers
命令：yum clean headers
3.清除缓存目录(/var/cache/yum)下旧的 headers
命令：yum clean
Oldheaders
4.清除缓存目录(/var/cache/yum)下的软件包及旧的headers
命令：yum clean, yum clean
all (= yum clean packages; yum clean oldheaders)</p>
<h2 id="_40">七、 时间管理<a class="headerlink" href="#_40" title="Permanent link">&para;</a></h2>
<h4 id="1_linux">1 、 Linux 时间介绍：<a class="headerlink" href="#1_linux" title="Permanent link">&para;</a></h4>
<div class="highlight"><pre><span></span><code>Linux时钟分为系统时钟（System Clock）和硬件（Real Time Clock，简称RTC）时钟。系统时钟
是指当前Linux Kernel中的时钟，而硬件时钟则是主板上由电池供电的时钟，这个硬件时钟可以在
BIOS中进行设置。当Linux启动时，硬件时钟会去读取系统时钟的 设置，然后系统时钟就会独立
于硬件运作。
Linux中的所有命令（包括函数）都是采用的系统时钟设置。在Linux中，用于时钟查看和
设置的命令主要有date、hwclock和clock。其中，clock和hwclock用法相近，只用一个就行，只不
过clock命令除了支持x86硬 件体系外，还支持Alpha硬件体系。
</code></pre></div>
<h4 id="2_linux">2 、 Linux 时间设置命令<a class="headerlink" href="#2_linux" title="Permanent link">&para;</a></h4>
<h4 id="21_date">2.1 、 date:<a class="headerlink" href="#21_date" title="Permanent link">&para;</a></h4>
<div class="highlight"><pre><span></span><code>语法格式：date [-u] [-d datestr] [-s datestr] [--utc] [--universal] [--date=datestr] [--set=datestr] [--help]
[--version] [+FORMAT] [MMDDhhmm[[CC]YY][.ss]]
说明： 可用来设置系统日期与时间。只有管理员才有设置日期与时间的权限，一般用户只能用
date命令显示时间。若不加任何参数，data会显示目前的日期与时间。
例 1 ：显示当前系统时间
[root@Test2 ~]# date
2010 年 06 月 17 日 星期四 00:00:04 CST
例 2 ：设置日期和时间为 2010 年 6 月 18 号12:00
[root@Test2 ~]# date -s &quot;20100618 12:00:00&quot;
2010 年 06 月 18 日 星期五 12:00:00 CST
例 3 ：设置日期为 2010 年年 6 月 18 号
[root@Test2 ~]# date -s 20100618
2010 年 06 月 18 日 星期五 00:00:00 CST
例 4 ：设置时间为12:00:00
</code></pre></div>
<p>[root@Test2 ~]# date 12:00:00
date: invalid date “12:00:00”
例 <strong>5</strong> ：显示时区
[root@Test2 ~]# date -R
Thu, 17 Jun 2010 00:01:36 +0800
或者：
[root@Test2 ~]# cat /etc/sysconfig/clock</p>
<h1 id="the_zone_parameter_is_only_evaluated_by_system-config-date">The ZONE parameter is only evaluated by system-config-date.<a class="headerlink" href="#the_zone_parameter_is_only_evaluated_by_system-config-date" title="Permanent link">&para;</a></h1>
<h1 id="the_timezone_of_the_system_is_defined_by_the_contents_of_etclocaltime">The timezone of the system is defined by the contents of /etc/localtime.<a class="headerlink" href="#the_timezone_of_the_system_is_defined_by_the_contents_of_etclocaltime" title="Permanent link">&para;</a></h1>
<p>ZONE="Asia/Shanghai"
UTC=true
ARC=false</p>
<h4 id="22_hwclockclock">2.2 、 hwclock/clock<a class="headerlink" href="#22_hwclockclock" title="Permanent link">&para;</a></h4>
<p>语法格式：hwclock [--adjust][--debug][--directisa][--hctosys][--show][--systohc][--test]
[--utc][--version][--set --date=&lt;日期与时间&gt;]
参数：
--adjust hwclock每次更改硬件时钟时，都会记录在/etc/adjtime文件中。使用--adjust参数，可使hwclock
根据先前的记录来估算硬件时钟的偏差，并用来校正目前的硬件时钟。
--debug 显示hwclock执行时详细的信息。
--directisa hwclock预设从/dev/rtc设备来存取硬件时钟。若无法存取时，可用此参数直接以I/O指令
来存取硬件时钟。
--hctosys 将系统时钟调整为与目前的硬件时钟一致。
--set --date=&lt;日期与时间&gt; 设定硬件时钟。
--show 显示硬件时钟的时间与日期。
--systohc 将硬件时钟调整为与目前的系统时钟一致。
--test 仅测试程序，而不会实际更改硬件时钟。
--utc 若要使用格林威治时间，请加入此参数，hwclock会执行转换的工作。
--version 显示版本信息。
例 <strong>1</strong> ：查看硬件时间</p>
<h1 id="hwclock_--show">hwclock --show<a class="headerlink" href="#hwclock_--show" title="Permanent link">&para;</a></h1>
<p>或者</p>
<h1 id="clock_--show">clock --show<a class="headerlink" href="#clock_--show" title="Permanent link">&para;</a></h1>
<p>例 <strong>2</strong> ：设置硬件时间</p>
<h1 id="hwclock_--set_--date070706_1019">hwclock --set --date="07/07/06 10:19" （月/日/年 时:分:秒）<a class="headerlink" href="#hwclock_--set_--date070706_1019" title="Permanent link">&para;</a></h1>
<p>或者</p>
<h1 id="clock_--set_--date070706_1019">clock --set --date="07/07/06 10:19" （月/日/年 时:分:秒）<a class="headerlink" href="#clock_--set_--date070706_1019" title="Permanent link">&para;</a></h1>
<p>例 <strong>3</strong> ：硬件时间和系统时间的同步
按照前面的说法，重新启动系统，硬件时间会读取系统时间，实现同步，但是在不重新启动的时候，需
要用hwclock或clock命令实现同步。
硬件时钟与系统时钟同步：</p>
<h1 id="hwclock_--hctosyshcsys">hwclock --hctosys（hc代表硬件时间，sys代表系统时间）<a class="headerlink" href="#hwclock_--hctosyshcsys" title="Permanent link">&para;</a></h1>
<p>或者</p>
<h1 id="clock_hctosys">clock –hctosys<a class="headerlink" href="#clock_hctosys" title="Permanent link">&para;</a></h1>
<p>例 <strong>4</strong> ：系统时钟和硬件时钟同步：</p>
<div class="highlight"><pre><span></span><code># hwclock --systohc
或者
# clock –systohc
例 5 ：强制将系统时间写入 CMOS ，使之永久生效，避免系统重启后恢复成原时间
# clock –w
或者
# hwclock -w
</code></pre></div>
<h4 id="23">2.3 、时区的设置<a class="headerlink" href="#23" title="Permanent link">&para;</a></h4>
<h1 id="tzselect">tzselect<a class="headerlink" href="#tzselect" title="Permanent link">&para;</a></h1>
<p>Please identify a location so that time zone rules can be set correctly.
Please select a continent or ocean.
1) Africa
2) Americas
3) Antarctica
4) Arctic Ocean
5) Asia
6) Atlantic Ocean
7) Australia
8) Europe
9) Indian Ocean
10) Pacific Ocean
11) none - I want to specify the time zone using the Posix TZ format.</p>
<h1 id="5">? 输入 5 ，亚洲<a class="headerlink" href="#5" title="Permanent link">&para;</a></h1>
<p>Please select a country.
1) Afghanistan 18) Israel 35) Palestine
2) Armenia 19) Japan 36) Philippines
3) Azerbaijan 20) Jordan 37) Qatar
4) Bahrain 21) Kazakhstan 38) Russia
5) Bangladesh 22) Korea (North) 39) Saudi Arabia
6) Bhutan 23) Korea (South) 40) Singapore
7) Brunei 24) Kuwait 41) Sri Lanka
8) Cambodia 25) Kyrgyzstan 42) Syria
9) China 26) Laos 43) Taiwan
10) Cyprus 27) Lebanon 44) Tajikistan
11) East Timor 28) Macau 45) Thailand
12) Georgia 29) Malaysia 46) Turkmenistan
13) Hong Kong 30) Mongolia 47) United Arab Emirates
14) India 31) Myanmar (Burma) 48) Uzbekistan
15) Indonesia 32) Nepal 49) Vietnam
16) Iran 33) Oman 50 ) Yeme n
17) Iraq 34) Pakistan</p>
<h1 id="9">? 输入 9 ，中国<a class="headerlink" href="#9" title="Permanent link">&para;</a></h1>
<p>Please select one of the following time zone regions.
1) east China - Beijing, Guangdong, Shanghai, etc.</p>
<p>2) Heilongjiang
3) central China - Gansu, Guizhou, Sichuan, Yunnan, etc.
4) Tibet &amp; most of Xinjiang Uyghur
5) southwest Xinjiang Uyghur</p>
<h1 id="1_1">? 输入 1 ，北京时间<a class="headerlink" href="#1_1" title="Permanent link">&para;</a></h1>
<p>The following information has been given:
China
east China - Beijing, Guangdong, Shanghai, etc.
Therefore TZ='Asia/Shanghai' will be used.
Local time is now: Fri Jul 7 10:32:18 CST 2006.
Universal Time is now: Fri Jul 7 02:32:18 UTC 2006.
Is the above information OK?
1 ) Ye s
2) No</p>
<h1 id="1_2">? 输入 1 ，确认<a class="headerlink" href="#1_2" title="Permanent link">&para;</a></h1>
<p>如果不用tzselect命令，可以修改文件变更时区。</p>
<h1 id="vi_etcsysconfigclock">vi /etc/sysconfig/clock<a class="headerlink" href="#vi_etcsysconfigclock" title="Permanent link">&para;</a></h1>
<p>Z/Shanghai（查/usr/share/zoneinfo下面的文件）
UTC=false
ARC=false</p>
<h1 id="rm_etclocaltime">rm /etc/localtime<a class="headerlink" href="#rm_etclocaltime" title="Permanent link">&para;</a></h1>
<h1 id="ln_-sf_usrsharezoneinfoasiashanghai_etclocaltime">ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime<a class="headerlink" href="#ln_-sf_usrsharezoneinfoasiashanghai_etclocaltime" title="Permanent link">&para;</a></h1>
<p>重新启动即可。</p>
<h4 id="24_timeconfig">2.4 、图形界面设置时区命令 timeconfig<a class="headerlink" href="#24_timeconfig" title="Permanent link">&para;</a></h4>
<h4 id="25">2.5 、时间同步<a class="headerlink" href="#25" title="Permanent link">&para;</a></h4>
<h5 id="1_3">例 1 ：同步时间<a class="headerlink" href="#1_3" title="Permanent link">&para;</a></h5>
<h1 id="ntpdate_2107214544_2107214544">ntpdate 210.72.145.44 （210.72.145.44是中国国家授时中心的官方服务器）<a class="headerlink" href="#ntpdate_2107214544_2107214544" title="Permanent link">&para;</a></h1>
<p>例 <strong>2</strong> ：定时同步时间</p>
<h1 id="crontab_e">crontab –e添加脚本例子如下：<a class="headerlink" href="#crontab_e" title="Permanent link">&para;</a></h1>
<p>*/20 * * * * /usr/sbin/ntpdate 210.72.145.44 //每 20 分钟执行一次
30 5 * * * /usr/sbin/ntpdate 210.72.145.44 //每天早晨 5 点半执行
※ 前面五个*号代表五个数字，数字的取值范围和含义如下：分钟（0-59） 小 時（0-23） 日 期（1-31）
月份（1-12） 星期（ 0 -6）//0代表星期天设定完毕后，可使用# crontab –l 查看上面的设定。</p>
<h2 id="_41">八、 启动引导<a class="headerlink" href="#_41" title="Permanent link">&para;</a></h2>
<h4 id="1_linux_1">1 、 Linux 的启动流程<a class="headerlink" href="#1_linux_1" title="Permanent link">&para;</a></h4>
<h5 id="1_bios">1) BIOS 自检<a class="headerlink" href="#1_bios" title="Permanent link">&para;</a></h5>
<h5 id="2_grublilo">2) 启动 GRUB/LILO<a class="headerlink" href="#2_grublilo" title="Permanent link">&para;</a></h5>
<div class="highlight"><pre><span></span><code>3) 运行 Linux kernel 并检测硬件
4) 挂载根文件系统
5) 运行 Linux 系统的第一个进程 init(其 PID 永远为 1 ，是所有其它进程的父进程)
6) init 读取系统引导配置文件 /etc/inittab 中的信息进行初始化
</code></pre></div>
<div class="highlight"><pre><span></span><code>7) 执行系统初始化脚本－ /etc/rc.d/rc.sysinit，执行系统初始化(包括很多内容)
8) 根据指定的运行级别(runlevel)来运行服务器脚本程序，再执行脚本 /etc/rc.d/rc.local
9) 运行一些其他的特别服务，一般为 /sbin/mingetty 和 /etc/X11/prefdm
10) Linux 控制台(console)提示用户输入用户名、密码进行登陆。
总结：BIOS初始化检查外围设备检查启动设备读区MBR
</code></pre></div>
<h4 id="2_linux_grub_lilo">2 、在 Linux 中常用的启动引导工具： grub 和 lilo<a class="headerlink" href="#2_linux_grub_lilo" title="Permanent link">&para;</a></h4>
<p>在Linux和WINDOWS两系统并存时就需要安装GRUB（Grand Unified Bootloader），GRUB被广泛地
用于替代lilo,GRUB支持在启动时使用命令行模式,支持md5加密保护 还可以从ext2/ext3、ReiseFS、JFS、
FAT、minix及FFS文件系统上启动其配置文件为/boot/grub/grub.conf,更改grub.conf即可立时生效如果
硬盘上的MBR被更动过，可以用/sbin/grub-install /dev/hda来重安装grub现在我们打开
/boot/grub/grub.conf查看一下</p>
<h1 id="vim_bootgrubgrubconf">vim /boot/grub/grub.conf<a class="headerlink" href="#vim_bootgrubgrubconf" title="Permanent link">&para;</a></h1>
<p>内容如下：</p>
<h1 id="grubconf_generated_by_anaconda">grub.conf generated by anaconda<a class="headerlink" href="#grubconf_generated_by_anaconda" title="Permanent link">&para;</a></h1>
<h1 id="_42"><a class="headerlink" href="#_42" title="Permanent link">&para;</a></h1>
<h1 id="note_that_you_do_not_have_to_rerun_grub_after_making_changes_to_this_file">Note that you do not have to rerun grub after making changes to this file<a class="headerlink" href="#note_that_you_do_not_have_to_rerun_grub_after_making_changes_to_this_file" title="Permanent link">&para;</a></h1>
<h1 id="notice_you_have_a_boot_partition_this_means_that">NOTICE: You have a /boot partition. This means that<a class="headerlink" href="#notice_you_have_a_boot_partition_this_means_that" title="Permanent link">&para;</a></h1>
<h1 id="all_kernel_and_initrd_paths_are_relative_to_boot_eg">all kernel and initrd paths are relative to /boot/, eg.<a class="headerlink" href="#all_kernel_and_initrd_paths_are_relative_to_boot_eg" title="Permanent link">&para;</a></h1>
<h1 id="root_hd00">root (hd0,0)<a class="headerlink" href="#root_hd00" title="Permanent link">&para;</a></h1>
<h1 id="kernel_vmlinuz-ve_rsion_ro_rootdevsda2">kernel /vmlinuz-ve rsion ro root=/dev/sda2<a class="headerlink" href="#kernel_vmlinuz-ve_rsion_ro_rootdevsda2" title="Permanent link">&para;</a></h1>
<h1 id="initrd_initrd-versionimg">initrd /initrd-version.img<a class="headerlink" href="#initrd_initrd-versionimg" title="Permanent link">&para;</a></h1>
<h1 id="bootdevsda">boot=/dev/sda<a class="headerlink" href="#bootdevsda" title="Permanent link">&para;</a></h1>
<p>default=0</p>
<h1 id="default0title">default=0表示默认启动第一个系统,如果系统有两个系统是用什么做为分隔符的呢？title就是系统的分<a class="headerlink" href="#default0title" title="Permanent link">&para;</a></h1>
<p>隔符,第一个title后面就是第一个系统,用 0 表示。
timeout=5</p>
<h1 id="timout5_5">timout=5，就是默认在启动选择界面停留的时间，单位是秒。等待 5 秒自动进入默认操作系统<a class="headerlink" href="#timout5_5" title="Permanent link">&para;</a></h1>
<p>splashimage=(hd0,0)/grub/splash.xpm.gz</p>
<h1 id="splashimagegrubgrubconf">splashimage是grub启动背景画面，如果是自己写grub.conf文件，这个可以不用写。<a class="headerlink" href="#splashimagegrubgrubconf" title="Permanent link">&para;</a></h1>
<p>hiddenmenu
title Red Hat Enterprise Linux Server (2.6.18-53.el5)</p>
<h1 id="title">title后面就是系统在启动时候显示的名字<a class="headerlink" href="#title" title="Permanent link">&para;</a></h1>
<p>root (hd0,0)</p>
<h1 id="root">root 启动文件所在位置<a class="headerlink" href="#root" title="Permanent link">&para;</a></h1>
<p>kernel /vmlinuz-2.6.18-53.el5 ro root=LABEL=/ rhgb quiet</p>
<h1 id="kernel">kernel 内核所在位置和名字<a class="headerlink" href="#kernel" title="Permanent link">&para;</a></h1>
<p>initrd /initrd-2.6.18-53.el5.img</p>
<h1 id="initrd">initrd内核镜象的名字<a class="headerlink" href="#initrd" title="Permanent link">&para;</a></h1>
<p>grub.conf的范例：
timeout=10 #等待 10 秒自动进入默认操作系统
splashimage=(hd0,0)/grub/splash.xpm.gz #grub启动背景画面
default=0 #默认进入第一个标题
title Red Hat Linux (2.4.20-18) #Red Hat Linux标题
root (hd0,0) #根文件系统位置
kernel /vmlinuz-2.4.20-18 ro root=LABEL=/ #核心位置与核心加载参数
initrd /initrd-2.4.20-18.img #启动initrd ram盘
title windows #另一个操作系统的标题
rootnoverify (hd0,1) #操作系统存放在hd0,1上，不要在grub里mount
chainloader +1 #从hd0,1的第一个扇面启动</p>
<h2 id="_43">九、 运行级别<a class="headerlink" href="#_43" title="Permanent link">&para;</a></h2>
<h4 id="1_linux_runlevel">1 、 Linux 系统的运行级别 (runlevel)<a class="headerlink" href="#1_linux_runlevel" title="Permanent link">&para;</a></h4>
<div class="highlight"><pre><span></span><code>Linux 系统有 7 个运行级别，Linux 系统任何时候都运行在一个指定的运行级别上，不同的运行级
别所运行的程序和服务不尽相同，所要完成的工作和要达到的目的也不相同
· 运行级别 0 系统停机(halt)状态，系统的默认运行级别不能设为 0 ，否则不能正常启动
· 运行级别 1 单用户工作(single user)状态，root 权限，用于系统维护，禁止远程登陆
· 运行级别 2 多用户(multiuser)状态 (没有 NFS)
· 运行级别 3 完全的多用户(multiuser)状态 (有 NFS)，登陆后进入控制台命令行模式
· 运行级别 4 系统未使用，保留
· 运行级别 5 X11 控制台 (xdm、gdm、kdm)，登陆后进入图形 GUI 模式
</code></pre></div>
<div class="highlight"><pre><span></span><code>· 运行级别 6 系统正常关闭并重启(reboot)，默认运行级别不能设为 6 ，否则不能正常启动
</code></pre></div>
<h4 id="2_1">2 、运行级别的原理<a class="headerlink" href="#2_1" title="Permanent link">&para;</a></h4>
<p><div class="highlight"><pre><span></span><code>在目录 /etc/rc.d/init.d 下有许多服务器脚本程序，一般称为服务(service)， 在 /etc/rc.d 下
有 7 个名为 rcN.d 的目录，其中 N=0-6，对应于系统的 7 个运行级别， rcN.d 目录下，都是
一些符号链接文件，这些链接文件都指向 init.d 目录下的 service 脚本文件，这些链接文件的命
名规则是 &quot;K+nn+服务名&quot; 或 &quot;S+nn+服务名&quot;，其中 nn 为 2 位数字：
例: rc3.d 目录下的链接文件 S80sendmail 就指向 service 脚本文件 ../init.d/sendmail
系统会根据指定的 runlevel 进入对应的 rcN.d 目录，并按照文件名顺序检索目录下的链接文件
</code></pre></div>
- 对于以 K 为开头的链接文件，系统将终止对应的服务
- 对于以 S 为开头的链接文件，系统将启动对应的服务
通过这种方式来实现 "不同的运行级别运行不同的程序和服务"</p>
<h4 id="3_etcinittab">3 、 /etc/inittab 配置文件详解<a class="headerlink" href="#3_etcinittab" title="Permanent link">&para;</a></h4>
<p>init的进程号是 1 ，从这一点就能看出，init进程是系统所有进程的起点，Linux在完成核内引导以后，
就开始运行init程序 ，init程序需要读取设置文件/etc/inittab。inittab是个不可执行的文本文件，他有若
干行指令所组成。在Redhat系统中，inittab的内容如下所示(以“###"开始的中注释为笔者增加的)：
（如果你改变了 <strong>inittab</strong> 文件，那么要使他立即生效，需要使用一个命令： <strong>init q</strong> ）</p>
<h1 id="_44"><a class="headerlink" href="#_44" title="Permanent link">&para;</a></h1>
<h1 id="inittab_this_file_describes_how_the_init_process_should_set_up">inittab This file describes how the INIT process should set up<a class="headerlink" href="#inittab_this_file_describes_how_the_init_process_should_set_up" title="Permanent link">&para;</a></h1>
<h1 id="the_system_in_a_certain_run-level">the system in a certain run-level.<a class="headerlink" href="#the_system_in_a_certain_run-level" title="Permanent link">&para;</a></h1>
<h1 id="_45"><a class="headerlink" href="#_45" title="Permanent link">&para;</a></h1>
<h1 id="author_miquel_van_smoorenburg_amp109amp105amp113amp117amp101amp108amp115amp64amp100amp114amp105amp110amp107amp101amp108amp46amp110amp108amp46amp109amp117amp103amp110amp101amp116amp46amp111amp114amp103">Author: Miquel van Smoorenburg, <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#109;&#105;&#113;&#117;&#101;&#108;&#115;&#64;&#100;&#114;&#105;&#110;&#107;&#101;&#108;&#46;&#110;&#108;&#46;&#109;&#117;&#103;&#110;&#101;&#116;&#46;&#111;&#114;&#103;">&#109;&#105;&#113;&#117;&#101;&#108;&#115;&#64;&#100;&#114;&#105;&#110;&#107;&#101;&#108;&#46;&#110;&#108;&#46;&#109;&#117;&#103;&#110;&#101;&#116;&#46;&#111;&#114;&#103;</a><a class="headerlink" href="#author_miquel_van_smoorenburg_amp109amp105amp113amp117amp101amp108amp115amp64amp100amp114amp105amp110amp107amp101amp108amp46amp110amp108amp46amp109amp117amp103amp110amp101amp116amp46amp111amp114amp103" title="Permanent link">&para;</a></h1>
<h1 id="modified_for_rhs_linux_by_marc_ewing_and_donnie_barnes">Modified for RHS Linux by Marc Ewing and Donnie Barnes<a class="headerlink" href="#modified_for_rhs_linux_by_marc_ewing_and_donnie_barnes" title="Permanent link">&para;</a></h1>
<h1 id="_46"><a class="headerlink" href="#_46" title="Permanent link">&para;</a></h1>
<h1 id="default_runlevel_the_runlevels_used_by_rhs_are">Default runlevel. The runlevels used by RHS are:<a class="headerlink" href="#default_runlevel_the_runlevels_used_by_rhs_are" title="Permanent link">&para;</a></h1>
<h1 id="0_-_halt_do_not_set_initdefault_to_this">0 - halt (Do NOT set initdefault to this)<a class="headerlink" href="#0_-_halt_do_not_set_initdefault_to_this" title="Permanent link">&para;</a></h1>
<h1 id="1_-_single_user_mode">1 - Single user mode<a class="headerlink" href="#1_-_single_user_mode" title="Permanent link">&para;</a></h1>
<h1 id="2_-_multiuser_without_nfs_the_same_as_3_if_you_do_not_have_networking">2 - Multiuser, without NFS (The same as 3, if you do not have networking)<a class="headerlink" href="#2_-_multiuser_without_nfs_the_same_as_3_if_you_do_not_have_networking" title="Permanent link">&para;</a></h1>
<h1 id="3_-_full_multiuser_mode">3 - Full multiuser mode<a class="headerlink" href="#3_-_full_multiuser_mode" title="Permanent link">&para;</a></h1>
<h1 id="4_-_unused">4 - unused<a class="headerlink" href="#4_-_unused" title="Permanent link">&para;</a></h1>
<h1 id="5_-_x11">5 - X11<a class="headerlink" href="#5_-_x11" title="Permanent link">&para;</a></h1>
<h1 id="6_-_reboot_do_not_set_initdefault_to_this">6 - reboot (Do NOT set initdefault to this)<a class="headerlink" href="#6_-_reboot_do_not_set_initdefault_to_this" title="Permanent link">&para;</a></h1>
<h1 id="_47"><a class="headerlink" href="#_47" title="Permanent link">&para;</a></h1>
<h3 id="5initdefault">表示当前缺省运行级别为5(initdefault)；<a class="headerlink" href="#5initdefault" title="Permanent link">&para;</a></h3>
<p>id:5:initdefault:</p>
<h3 id="etcrcdrcsysinitsysinit">启动时自动执行/etc/rc.d/rc.sysinit脚本(sysinit)<a class="headerlink" href="#etcrcdrcsysinitsysinit" title="Permanent link">&para;</a></h3>
<h1 id="system_initialization">System initialization.<a class="headerlink" href="#system_initialization" title="Permanent link">&para;</a></h1>
<p>si::sysinit:/etc/rc.d/rc.sysinit</p>
<p>l0:0:wait:/etc/rc.d/rc 0
l1:1:wait:/etc/rc.d/rc 1
l2:2:wait:/etc/rc.d/rc 2</p>
<p>l3:3:wait:/etc/rc.d/rc 3
l4:4:wait:/etc/rc.d/rc 4</p>
<h3 id="5_5_etcrcdrcinitwait">当运行级别为 5 时，以 5 为参数运行/etc/rc.d/rc脚本，init将等待其返回(wait)<a class="headerlink" href="#5_5_etcrcdrcinitwait" title="Permanent link">&para;</a></h3>
<p>l5:5:wait:/etc/rc.d/rc 5
l6:6:wait:/etc/rc.d/rc 6</p>
<h3 id="ctrl-alt-delete">在启动过程中允许按CTRL-ALT-DELETE重启系统<a class="headerlink" href="#ctrl-alt-delete" title="Permanent link">&para;</a></h3>
<h1 id="trap_c_tr_l-a_lt-delete">Trap C TR L-A LT-DELETE<a class="headerlink" href="#trap_c_tr_l-a_lt-delete" title="Permanent link">&para;</a></h1>
<p>ca::ctrlaltdel:/sbin/shutdown -t3 -r now</p>
<h1 id="when_our_ups_tells_us_power_has_failed_assume_we_have_a_few_minutes">When our UPS tells us power has failed, assume we have a few minutes<a class="headerlink" href="#when_our_ups_tells_us_power_has_failed_assume_we_have_a_few_minutes" title="Permanent link">&para;</a></h1>
<h1 id="of_power_left_schedule_a_shutdown_for_2_minutes_from_now">of power left. Schedule a shutdown for 2 minutes from now.<a class="headerlink" href="#of_power_left_schedule_a_shutdown_for_2_minutes_from_now" title="Permanent link">&para;</a></h1>
<h1 id="this_does_of_course_assume_you_have_powerd_installed_and_your">This does, of course, assume you have powerd installed and your<a class="headerlink" href="#this_does_of_course_assume_you_have_powerd_installed_and_your" title="Permanent link">&para;</a></h1>
<h1 id="ups_connected_and_working_correctly">UPS connected and working correctly.<a class="headerlink" href="#ups_connected_and_working_correctly" title="Permanent link">&para;</a></h1>
<p>pf::powerfail:/sbin/shutdown -f -h +2 "Power Failure; System Shutting Down"</p>
<h1 id="if_power_was_restored_before_the_shutdown_kicked_in_cancel_it">If power was restored before the shutdown kicked in, cancel it.<a class="headerlink" href="#if_power_was_restored_before_the_shutdown_kicked_in_cancel_it" title="Permanent link">&para;</a></h1>
<p>pr:12345:powerokwait:/sbin/shutdown -c "Power Restored; Shutdown Cancelled"</p>
<h3 id="2_3_4_5_ttyxsbinmingettyttyx">在 2 、 3 、 4 、 5 级别上以ttyX为参数执行/sbin/mingetty程序，打开ttyX终端用于用户登录，<a class="headerlink" href="#2_3_4_5_ttyxsbinmingettyttyx" title="Permanent link">&para;</a></h3>
<h3 id="mingettyrespawn">如果进程退出则再次运行mingetty程序(respawn)<a class="headerlink" href="#mingettyrespawn" title="Permanent link">&para;</a></h3>
<h1 id="run_gettys_in_standard_runlevels">Run gettys in standard runlevels<a class="headerlink" href="#run_gettys_in_standard_runlevels" title="Permanent link">&para;</a></h1>
<p>1:2345:respawn:/sbin/mingetty tty1
2:2345:respawn:/sbin/mingetty tty2
3:2345:respawn:/sbin/mingetty tty3
4:2345:respawn:/sbin/mingetty tty4
5:2345:respawn:/sbin/mingetty tty5
6:2345:respawn:/sbin/mingetty tty6</p>
<h3 id="5_xdmxdmrespawn">在 5 级别上运行xdm程序，提供xdm图像方式登录界面，并在退出时重新执行(respawn)<a class="headerlink" href="#5_xdmxdmrespawn" title="Permanent link">&para;</a></h3>
<h1 id="run_xdm_in_runlevel_5">Run xdm in runlevel 5<a class="headerlink" href="#run_xdm_in_runlevel_5" title="Permanent link">&para;</a></h1>
<p>x:5:respawn:/etc/X11/prefdm -nodaemon</p>
<p>以上面的inittab文件为例，来说明一下inittab的格式。其中以#开始的行是注释行，除了注释行之
外，每一行都有以下格式：</p>
<p>id:runlevel:action:process</p>
<p>对上面各项的周详解释如下：</p>
<ol>
<li>id</li>
</ol>
<p>id是指入口标识符，他是个字符串，对于getty或mingetty等其他login程序项，需求id和tty的编
号相同，否则getty程序将不能正常工作。</p>
<ol>
<li>runlevel</li>
</ol>
<p>runlevel是init所处于的运行级别的标识，一般使用 0 － 6 及S或s。 0 、 1 、 6 运行级别被系统保留：
其中 0 作为shutdown动作， 1 作为重启至单用户模式， 6 为重启；S和s意义相同，表示单用户模式，
且无需inittab文件，因此也不在inittab中出现，实际上，进入单用户模式时，init直接在控制台
（/dev/console）上运行/sbin/sulogin。在一般的系统实现中，都使用了 2 、 3 、 4 、 5 几个级别，在 Redhat
系统中， 2 表示无NFS支持的多用户模式， 3 表示完全多用户模式（也是最常用的级别）， 4 保留给用户
自定义， 5 表示XDM图像登录方式。 7 － 9 级别也是能使用的，传统的Unix系统没有定义这几个级别。
runlevel能是并列的多个值，以匹配多个运行级别，对大多数action来说，仅当runlevel和当前运行级
别匹配成功才会执行。</p>
<ol>
<li>action</li>
</ol>
<p>action是描述其后的process的运行方式的。action可取的值包括：initdefault、sysinit、boot、bootwait
等：</p>
<p>initdefault是个特别的action值，用于标识缺省的启动级别；当init由核心激活以后，他将读取inittab
中的 initdefault项，取得其中的runlevel，并作为当前的运行级别。如果没有inittab文件，或其中没有
initdefault项， init将在控制台上请求输入runlevel。</p>
<p>sysinit、boot、bootwait等action将在系统启动时无条件运行，而忽略其中的runlevel。</p>
<p>其余的action（不含initdefault）都和某个runlevel相关。各个action的定义在inittab的man手册
中有周详的描述。</p>
<ol>
<li>process</li>
</ol>
<p>process为具体的执行程序。程序后面能带参数。</p>
<p>第三部分：系统初始化</p>
<p>在init的设置文件中有这么一行：</p>
<p>si::sysinit:/etc/rc.d/rc.sysinit</p>
<p>他调用执行了/etc/rc.d/rc.sysinit，而rc.sysinit是个bash shell的脚本，他主要
在init的设置文件中有这么一行：
si::sysinit:/etc/rc.d/rc.sysinit
他 调用执行了/etc/rc.d/rc.sysinit，而rc.sysinit是个bash shell的脚本，他主要是完成一些系统初始化的
工作，rc.sysinit是每一个运行级别都要首先运行的重要脚本。他主要完成的工作有：激活交换分区，检
查磁盘，加载硬件模块及其他一些需要优先执行任务。</p>
<p>rc.sysinit约有 850 多行，不过每个单一的功能还是比较简单，而且带有注释，建议有兴趣的用户能自行
阅读自己机器上的该文件，以了解系统初始化所周详情况。由于此文件较长，所以不在本文中列出来，
也不做具体的介绍。
当rc.sysinit程序执行完毕后，将返回init继续下一步。
第四部分：启动对应运行级别的守护进程
在rc.sysinit执行后，将返回init继续其他的动作，通常接下来会执行到/etc/rc.d/rc程序。以运行级别 5
为例，init将执行设置文件inittab中的以下这行：
l5:5:wait:/etc/rc.d/rc 5
这一行表示以 5 为参数运行/etc/rc.d/rc，/etc/rc.d/rc是个Shell脚本，他接受 5 作为参数，去执行/etc/rc.d
/rc5.d/目录下的所有的rc启动脚本，/etc/rc.d/rc5.d/目录中的这些启动脚本实际上都是一些链接文件，
而不是真正的rc启动脚本，真正的rc启动脚本实际上都是放在/etc/rc.d/init.d/目录下。而这些rc启动
脚本有着类似的用法，他们一般能接受start、stop、 restart、status等参数。
/etc/rc.d/rc5.d/中的rc启动脚本通常是K或S开头的链接文件，对于以以S开头的启动脚本，将以start
参数来运行。而如果发现存在相应的脚本也存在K打头的链接，而且已处于运行态了(以/var/lock/subsys/
下的文件作为标志)，则将首先以stop为参数停止这些已启动了的守护进程，然后再重新运行。这样做
是为了确保是当init改动运行级别时，所有相关的守护进程都将重启。
至于在每个运行级中将运行哪些守护进程，用户能通过chkconfig或setup中的"System Services"来自行
设定。常见的守护进程有：
amd：自动安装NFS守护进程
apmd:高级电源管理守护进程
arpwatch：记录日志并构建一个在LAN接口上看到的以太网地址和IP地址对数据库
autofs：自动安装管理进程automount，和NFS相关，依赖于NIS
crond：Linux下的计划任务的守护进程
named：DNS服务器
netfs：安装NFS、Samba和NetWare网络文件系统
network：激活已设置网络接口的脚本程序
nfs：打开NFS服务
portmap：RPC portmap管理器，他管理基于RPC服务的连接
sendmail：邮件服务器sendmail
smb：Samba文件共享/打印服务
syslog：一个让系统引导时起动syslog和klogd系统日志守候进程的脚本
xfs：X Window字型服务器，为本地和远程X服务器提供字型集
Xinetd：支持多种网络服务的核心守护进程，能管理wuftp、sshd、telnet等服务
这些守护进程也启动完成了，rc程序也就执行完了，然后又将返回init继续下一步。
第五部分：建立终端
rc执行完毕后，返回init。这时基本系统环境已设置好了，各种守护进程也已启动了。init接下来会打
开 6 个终端，以便用户登录系统。通过按Alt+Fn(n对应1-6)能在这 6 个终端中转换。在inittab中的以下
6 行就是定义了 6 个终端：
1:2345:respawn:/sbin/mingetty tty1
2:2345:respawn:/sbin/mingetty tty2
3:2345:respawn:/sbin/mingetty tty3
4:2345:respawn:/sbin/mingetty tty4
5:2345:respawn:/sbin/mingetty tty5
6:2345:respawn:/sbin/mingetty tty6</p>
<p>从上面能看出在 2 、 3 、 4 、 5 的运行级别中都将以respawn方式运行mingetty程序，mingetty程序能打
开终端、设置模式。同时他会显示一个文本登录界面，这个界面就是我们经常看到的登录界面，在这个
登录界面中会提示用户输入用户名，而用户输入的用户将作为参数传给login程序来验证用户的身份。
第六部分：登录系统，启动完成
对于运行级别为 5 的图像方式用户来说，他们的登录是通过一个图像化的登录界面。登录成功后能直接
进入KDE、Gnome等窗口管理器。而本文主要讲的还是文本方式登录的情况：
当我们看到mingetty的登录界面时，我们就能输入用户名和密码来登录系统了。
Linux的账号验证程序是login，login会接收mingetty传来的用户名作为用户名参数。然后login会
对用户名进行分析：如果用户名不是root，且存在/etc/nologin文件，login将输出nologin文件的内容，
然后退出。这通常用来系统维护时防止非root用户登录。只有/etc/securetty中登记了的终端才允许root
用户登录，如果不存在这个文件，则root能在所有终端上登录。/etc /usertty文件用于对用户作出附加
访问限制，如果不存在这个文件，则没有其他限制。
在分析完用户名后，login将搜索/etc/passwd及/etc/shadow来验证密码及设置账户的其他信息，比如：
主目录是什么、使用何种shell。如果没有指定主目录，将默认为根目录；如果没有指定shell，将默 认
为/bin/bash。
login 程序成功后，会向对应的终端在输出最近一次登录的信息(在/var/log/lastlog中有记录)，并检查用
户是否有新邮件(在/usr/spool /mail/的对应用户名目录下)。然后开始设置各种环境变量：对于bash来说，
系统首先寻找/etc/profile脚本文件，并执行他；然后如果用户的主目录中存在.bash_profile文件，就执
行他，在这些文件中又可能调用了其他设置文件，所有的设置文件执行后后，各种环境变量也设好了，
这时会出现大家熟悉的命令行提示符，到此整个启动过程就结束了。</p>
<h4 id="4_1">4 、相关命令<a class="headerlink" href="#4_1" title="Permanent link">&para;</a></h4>
<h4 id="41">4.1 、查看当前系统运行等级<a class="headerlink" href="#41" title="Permanent link">&para;</a></h4>
<p>[root@test ~]# runlevel
N 5 //’N’代表先前的Runlevel; ‘5’代表目前的Runlevel</p>
<h4 id="42">4.2 、切换系统运行等级<a class="headerlink" href="#42" title="Permanent link">&para;</a></h4>
<h1 id="init_n_n">init N //切换到运行级别 N<a class="headerlink" href="#init_n_n" title="Permanent link">&para;</a></h1>
<h1 id="init_0">init 0 //关机<a class="headerlink" href="#init_0" title="Permanent link">&para;</a></h1>
<h1 id="init_6">init 6 //重启动系统<a class="headerlink" href="#init_6" title="Permanent link">&para;</a></h1>
<h2 id="_48">十、 进程管理<a class="headerlink" href="#_48" title="Permanent link">&para;</a></h2>
<p>进程就是运行中的程序，一个运行着的程序，可能有多个进程。 比如 LinuxSir.Org 所用的WWW
服务器是apache服务器，当管理员启动服务后，可能会有好多人来访问，也就是说许多用户来同时请
求httpd服务，apache服务器将会创建有多个httpd进程来对其进行服务。</p>
<h4 id="1_4">1 、 进程分类<a class="headerlink" href="#1_4" title="Permanent link">&para;</a></h4>
<h5 id="_49">进程一般分为交互进程、批处理进程和守护进程三类。<a class="headerlink" href="#_49" title="Permanent link">&para;</a></h5>
<h5 id="_50">值得一提的是守护进程总是活跃的，一般是后台运行，守护进程一般是由系统在开机时通过脚本自<a class="headerlink" href="#_50" title="Permanent link">&para;</a></h5>
<p>动激活启动或超级管理用户root来启动。比如在Fedora或Redhat中，我们可以定义httpd服务器的启
动脚本的运行级别，此文件位于/etc/init.d目录下，文件名是httpd，/etc/init.d/httpd就是httpd服务器
的守护程序，当把它的运行级别设置为 3 和 5 时，当系统启动时，它会跟着启动。
[root@localhost ~]# chkconfig --level 35 httpd on</p>
<h5 id="_51">由于守护进程是一直运行着的，所以它所处的状态是等待请求处理任务。比如，我们是不是访问<a class="headerlink" href="#_51" title="Permanent link">&para;</a></h5>
<p>LinuxSir.Org ，LinuxSir.Org 的httpd服务器都在运行，等待着用户来访问，也就是等待着任务处理。</p>
<h4 id="2_2">2 、进程的属性<a class="headerlink" href="#2_2" title="Permanent link">&para;</a></h4>
<h5 id="idpid">进程ID（PID)：是唯一的数值，用来区分进程；<a class="headerlink" href="#idpid" title="Permanent link">&para;</a></h5>
<h5 id="idppid">父进程和父进程的ID（PPID)；<a class="headerlink" href="#idppid" title="Permanent link">&para;</a></h5>
<h5 id="iduidgid">启动进程的用户ID（UID）和所归属的组（GID）；<a class="headerlink" href="#iduidgid" title="Permanent link">&para;</a></h5>
<h5 id="rsz">进程状态：状态分为运行R、休眠S、僵尸Z；<a class="headerlink" href="#rsz" title="Permanent link">&para;</a></h5>
<h5 id="_52">进程执行的优先级；<a class="headerlink" href="#_52" title="Permanent link">&para;</a></h5>
<h5 id="_53">进程所连接的终端名；<a class="headerlink" href="#_53" title="Permanent link">&para;</a></h5>
<h5 id="cpu">进程资源占用：比如占用资源大小（内存、CPU占用量）；<a class="headerlink" href="#cpu" title="Permanent link">&para;</a></h5>
<h4 id="3_2">3 、父进程和子进程<a class="headerlink" href="#3_2" title="Permanent link">&para;</a></h4>
<h5 id="_54">他们的关系是管理和被管理的关系，当父进程终止时，子进程也随之而终止。但子进程终止，父进<a class="headerlink" href="#_54" title="Permanent link">&para;</a></h5>
<p>程并不一定终止。比如httpd服务器运行时，我们可以杀掉其子进程，父进程并不会因为子进程的终止
而终止。
在进程管理中，当我们发现占用资源过多，或无法控制的进程时，应该杀死它，以保护系统的稳定
安全运行</p>
<h4 id="4_2">4 、进程管理命令<a class="headerlink" href="#4_2" title="Permanent link">&para;</a></h4>
<h4 id="41_ps">4.1 、 ps<a class="headerlink" href="#41_ps" title="Permanent link">&para;</a></h4>
<p>ps为我们提供了进程的一次性的查看，它所提供的查看结果并不动态连续的；如果想对进程时间监控，
应该用top工具。
<strong>4.1.1</strong> 、 <strong>ps</strong> 的参数说明：
ps 提供了很多的选项参数，常用的有以下几个；
l 长格式输出；
u 按用户名和启动时间的顺序来显示进程；
j 用任务格式来显示进程；
f 用树形格式来显示进程；
a 显示所有用户的所有进程（包括其它用户）；
x 显示无控制终端的进程；
r 显示运行中的进程；
ww 避免详细参数被截断；
我们常用的选项是组合是aux 或lax，还有参数f的应用；
ps aux 或lax输出的解释；</p>
<h5 id="userpidcpucpu">USER表示启动进程用户。PID表示进程标志号。%CPU表示运行该进程占用CPU的时间与该进<a class="headerlink" href="#userpidcpucpu" title="Permanent link">&para;</a></h5>
<h5 id="memvsz">程总的运行时间的比例。%MEM表示该进程占用内存和总内存的比例。VSZ表示占用的虚拟内存大<a class="headerlink" href="#memvsz" title="Permanent link">&para;</a></h5>
<h5 id="kbrsskbtty">小，以KB为单位。RSS为进程占用的物理内存值，以KB为单位。TTY表示该进程建立时所对应的<a class="headerlink" href="#kbrsskbtty" title="Permanent link">&para;</a></h5>
<h5 id="statd">终端，"?"表示该进程不占用终端。STAT表示进程的运行状态，包括以下几种代码：D，不可中断的<a class="headerlink" href="#statd" title="Permanent link">&para;</a></h5>
<h5 id="rstzz">睡眠；R，就绪（在可运行队列中）；S，睡眠；T，被跟踪或停止；Z，终止（僵死）的进程，Z不<a class="headerlink" href="#rstzz" title="Permanent link">&para;</a></h5>
<h5 id="wn">存在，但暂时无法消除；W，没有足够的内存分页可分配；&lt;高优先序的进程；N，低优先序的进程；<a class="headerlink" href="#wn" title="Permanent link">&para;</a></h5>
<h5 id="liosta_rttime">L，有内存分页分配并锁在内存体内（实时系统或I/O）。STA RT为进程开始时间。TIME为执行的时<a class="headerlink" href="#liosta_rttime" title="Permanent link">&para;</a></h5>
<h5 id="command">间。COMMAND是对应的命令名。<a class="headerlink" href="#command" title="Permanent link">&para;</a></h5>
<p><strong>4.1.2 ps</strong> 应用举例
实例一：ps aux 最常用
[root@localhost ~]# ps -aux |more
可以用 | 管道和 more 连接起来分页查看；
[root@localhost ~]# ps aux &gt; ps001.txt
[root@localhost ~]# more ps001.txt
这里是把所有进程显示出来，并输出到ps001.txt文件，然后再通过more 来分页查看；
实例二：和grep 结合，提取指定程序的进程；
[root@localhost ~]# ps aux |grep httpd
root 4187 0.0 1.3 24236 10272? Ss 11:55 0:00 /usr/sbin/httpd
apache 4189 0.0 0.6 24368 4940? S 11:55 0:00 /usr/sbin/httpd
apache 4190 0.0 0.6 24368 4932? S 11:55 0:00 /usr/sbin/httpd
apache 4191 0.0 0.6 24368 4932? S 11:55 0:00 /usr/sbin/httpd
apache 4192 0.0 0.6 24368 4932? S 11:55 0:00 /usr/sbin/httpd
apache 4193 0.0 0.6 24368 4932? S 11:55 0:00 /usr/sbin/httpd
apache 4194 0.0 0.6 24368 4932? S 11:55 0:00 /usr/sbin/httpd
apache 4195 0.0 0.6 24368 4932? S 11:55 0:00 /usr/sbin/httpd
apache 4196 0.0 0.6 24368 4932? S 11:55 0:00 /usr/sbin/httpd
root 4480 0.0 0.0 5160 708 pts/3 R+ 12:20 0:00 grep httpd
实例二：父进和子进程的关系友好判断的例子
[root@localhost ~]# ps auxf |grep httpd
root 4484 0.0 0.0 5160 704 pts/3 S+ 12:21 0:00 _ grep
httpd
root 4187 0.0 1.3 24236 10272? Ss 11:55 0:00 /usr/sbin/httpd
apache 4189 0.0 0.6 24368 4940? S 11:55 0:00 _ /usr/sbin/httpd
apache 4190 0.0 0.6 24368 4932? S 11:55 0:00 _ /usr/sbin/httpd
apache 4191 0.0 0.6 24368 4932? S 11:55 0:00 _ /usr/sbin/httpd
apache 4192 0.0 0.6 24368 4932? S 11:55 0:00 _ /usr/sbin/httpd
apache 4193 0.0 0.6 24368 4932? S 11:55 0:00 _ /usr/sbin/httpd
apache 4194 0.0 0.6 24368 4932? S 11:55 0:00 _ /usr/sbin/httpd
apache 4195 0.0 0.6 24368 4932? S 11:55 0:00 _ /usr/sbin/httpd
apache 4196 0.0 0.6 24368 4932? S 11:55 0:00 _ /usr/sbin/httpd
这里用到了f参数；父与子关系一目了然；
例三：找出消耗内存最多的前 10 名进程</p>
<h1 id="ps_-auxf_sort_-nr_-k_4_head_-_10">ps -auxf | sort -nr -k 4 | head - 10<a class="headerlink" href="#ps_-auxf_sort_-nr_-k_4_head_-_10" title="Permanent link">&para;</a></h1>
<p>例四：找出使用CPU最多的前 10 名进程</p>
<h1 id="ps_-auxf_sort_-nr_-k_3_head_-_10">ps -auxf | sort -nr -k 3 | head - 10<a class="headerlink" href="#ps_-auxf_sort_-nr_-k_3_head_-_10" title="Permanent link">&para;</a></h1>
<h4 id="42_pstree">4.2 、 pstree<a class="headerlink" href="#42_pstree" title="Permanent link">&para;</a></h4>
<p>功能：pstree命令列出当前的进程，以及它们的树状结构。
格式：pstree [选项] [pid|user]
主要选项如下：</p>
<p><div class="highlight"><pre><span></span><code>-a：显示执行程序的命令与完整参数。
-c：取消同名程序，合并显示。
-h：对输出结果进行处理，高亮显示正在执行的程序。
-l：长格式显示。
-n：以PID大小排序。
-p：显示PID。
-u：显示UID信息。
-G：使用VT100终端编码显示。
-U：使用UTF-8（Unicode）编码显示。
说明：使用ps命令得到的数据精确，但数据庞大，这一点对掌握系统整体概况来说是不容易的。pstree
正好可以弥补这个缺憾。它能将当前的执行程序以树状结构显示。pstree支持指定特定程序（PID）
或使用者（USER）作为显示的起始。
应用实例如下。
进程启动的时候可能会产生自己的一个子进程。运行pstree命令就可以很容易地看到这些信息。以超
级用户权限运行pstree：
＃init-+-apmd
</code></pre></div>
<div class="highlight"><pre><span></span><code>|-atd
</code></pre></div>
<div class="highlight"><pre><span></span><code>|-bdflush
</code></pre></div>
<div class="highlight"><pre><span></span><code>|-gconfd-2
</code></pre></div>
<div class="highlight"><pre><span></span><code>|-gdm-binary---gdm-binary-+-X
</code></pre></div>
<div class="highlight"><pre><span></span><code>| `-startkde-+-kwrapper
</code></pre></div>
<div class="highlight"><pre><span></span><code>| `-ssh-agent
</code></pre></div>
<div class="highlight"><pre><span></span><code>|-gpm
</code></pre></div>
<div class="highlight"><pre><span></span><code>|-httpd---8*[httpd]
</code></pre></div>
<div class="highlight"><pre><span></span><code>......下略
</code></pre></div>
<div class="highlight"><pre><span></span><code>命令对程序名称相同的会自动合并，所有&quot;|-httpd---8*[httpd]&quot;即表示系统中有 8 个httpd进程产生的
子进程。
</code></pre></div></p>
<h4 id="43_top">4.3 、 top<a class="headerlink" href="#43_top" title="Permanent link">&para;</a></h4>
<p>top命令用来显示系统当前的进程状况。
格式：top [选项]
主要选项如下。
d：指定更新的间隔，以秒计算。
q：没有任何延迟的更新。如果使用者有超级用户，则top命令将会以最高的优先序执行。
c：显示进程完整的路径与名称。
S：累积模式，会将已完成或消失的子进程的CPU时间累积起来。</p>
<p>s：安全模式。
i：不显示任何闲置（Idle）或无用（Zombie）的进程。
n：显示更新的次数，完成后将会退出top。
说明：top命令和ps命令的基本作用是相同的，都显示系统当前的进程状况。但是top是一个动态显
示过程，即可以通过用户按键来不断刷新当前状态。这里结合下图来说明它给出的信息。</p>
<h5 id="_55">第一行表示的项目依次为当前时间、系统启动时间、当前系统登录用户数目、平均负载。<a class="headerlink" href="#_55" title="Permanent link">&para;</a></h5>
<p>第二行显示的是Tasks: 114 total 进程总数、2 running 正在运行的进程数、110 sleeping 睡眠的进程数、
0 stopped 停止的进程数、2 zombie 僵尸进程数
第三行显示的是目前CPU的使用情况，Cpu(s): 0.3% us 用户空间占用CPU百分比、1.0% sy 内核空间
占用CPU百分比、0.0% ni 用户进程空间内改变过优先级的进程占用CPU百分比、98.7% id 空
闲CPU百分比、0.0% wa 等待输入输出的CPU时间百分比、0.0% hi、0.0% si
第四行显示物理内存的使用情况，Mem: 191272k total 物理内存总量、173656k used 使用的物理内存
总量、17616k free 空闲内存总量、22052k buffers 用作内核缓存的内存量
第五行显示交换分区使用情况，Swap: 192772k total 交换区总量、0k used 使用的交换区总量、192772k
free 空闲交换区总量、123988k cached 缓冲的交换区总量、内存中的内容被换出到交换区，
而后又被换入到内存，但使用过的交换区尚未被覆盖，该数值即为这些内容已存在于内存中的
交换区的大小。相应的内存再次被换出时可不必再对交换区写入。
第六行显示的项目最多，下面列出了详细解释。
PID（Process ID）：进程标志号，是非零正整数。USER：进程所有者的用户名。PR：进程的优先级别。
NI：进程的优先级别数值。VIRT：进程占用的虚拟内存值。RES：进程占用的物理内存值。SHR：进程
使用的共享内存值。S TAT：进程的状态，其中S表示休眠，R表示正在运行，Z表示僵死状态，N表
示该进程优先值是负数。%CPU：该进程占用的CPU使用率。%MEM：该进程占用的物理内存和总内</p>
<h5 id="timecpucommand">存的百分比。TIME：该进程启动后占用的总的CPU时间。COMMAND：进程启动的启动命令名称，如<a class="headerlink" href="#timecpucommand" title="Permanent link">&para;</a></h5>
<h5 id="_56">果这一行显示不下，进程会有一个完整的命令行。<a class="headerlink" href="#_56" title="Permanent link">&para;</a></h5>
<div class="highlight"><pre><span></span><code>top命令使用过程中，还可以使用一些交互的命令来完成其他参数的功能。这些命令是通过快捷键启
动的。
&lt;空格&gt;：立刻刷新。
A 分类显示系统不同资源的使用大户。有助于快速识别系统中资源消耗多的任务。
f 添加删除所要显示栏位.
o 调整所要显示栏位的顺序.
r 调整一个正在运行的进程Nice值.
k 结束一个正在运行的进程.
z 彩色/黑白显示开关
P：根据CPU使用大小进行排序。
T：根据时间、累计时间排序。
q：退出top命令。
m：切换显示内存信息。
t：切换显示进程和CPU状态信息。
c：切换显示命令名称和完整命令行。
M：根据使用内存大小进行排序。
W：将当前设置写入～/.toprc文件中。这是写top配置文件的推荐方法。
可以看到，top命令是一个功能十分强大的监控系统的工具，对于系统管理员而言尤其重要。但是，
它的缺点是会消耗很多系统资源。
</code></pre></div>
<h2 id="_57">十一、 资源监控<a class="headerlink" href="#_57" title="Permanent link">&para;</a></h2>
<h4 id="1_free">1 、 free 内存监控<a class="headerlink" href="#1_free" title="Permanent link">&para;</a></h4>
<p>语 法： free [-bkmotV][-s &lt;间隔秒数&gt;]
补充说明：free指令会显示内存的使用情况，包括实体内存，虚拟的交换文件内存，共享内存区段，以
及系统核心使用的缓冲区等。
参 数：
-b 以Byte为单位显示内存使用情况。
-k 以KB为单位显示内存使用情况。
-m 以MB为单位显示内存使用情况。
-o 不显示缓冲区调节列。
-s&lt;间隔秒数&gt; 持续观察内存使用状况。
-t 显示内存总和列。
-V 显示版本信息。</p>
<p>Mem：表示物理内存统计
-/+ buffers/cached：表示物理内存的缓存统计
Swap：表示硬盘上交换分区的使用情况
第 1 行 Mem： total：表示物理内存总量。</p>
<p>used：表示总计分配给缓存（包含buffers 与cache ）使用的数量，但其中可能部分缓存并未实际使
用。
free：未被分配的内存。
shared：共享内存，一般系统不会用到，这里也不讨论。
buffers：系统分配但未被使用的buffers 数量。
cached：系统分配但未被使用的cache 数量。buffer 与cache 的区别见后面。 total = used + free
第 2 行 -/+ buffers/cached： used：也就是第一行中的used – buffers-cached 也是实际使用的内
存总量。
free：未被使用的buffers 与cache 和未被分配的内存之和，这就是系统当前实际可用内存。 free 2=
buffers1 + cached1 + free1 //free2为第二行、buffers1等为第一行
A buffer is something that has yet to be “written” to disk. A cache is something that has
been “read” from the disk and stored for later use 第 3 行： 第三行所指的是从应用程序角度
来看，对于应用程序来说，buffers/cached 是等于可用的，因为buffer/cached是为了提高文件读取
的性能，当应用程序需在用到内存的时候，buffer/cached会很快地被回收。
所以从应用程序的角度来说，可用内存=系统free memory+buffers+cached.
接下来解释什么时候内存会被交换，以及按什么方交换。
当可用内存少于额定值的时候，就会开会进行交换，如何看额定值（RHEL4.0）：</p>
<h1 id="cat_procmeminfo">cat /proc/meminfo<a class="headerlink" href="#cat_procmeminfo" title="Permanent link">&para;</a></h1>
<p>交换将通过三个途径来减少系统中使用的物理页面的个数：
1.减少缓冲与页面cache的大小，
2.将系统V类型的内存页面交换出去，
3.换出或者丢弃页面。(Application 占用的内存页，也就是物理内存不足）。
事实上，少量地使用swap是不是影响到系统性能的。
下面是buffers与cached的区别：
buffers是指用来给块设备做的缓冲大小，他只记录文件系统的metadata以及 tracking in-flight
pages.
cached是用来给文件做缓冲。
那就是说：buffers是用来存储，目录里面有什么内容，权限等等。
而cached直接用来记忆我们打开的文件 ，如果你想知道他是不是真的生效，你可以试一下，先后执行
两次命令#man X ,你就可以明显的感觉到第二次的开打的速度快很多。
实验：在一台没有什么应用的机器上做会看得比较明显。记得实验只能做一次，如果想多做请换一个文
件名。</p>
<h1 id="free">free<a class="headerlink" href="#free" title="Permanent link">&para;</a></h1>
<h1 id="man_x">man X<a class="headerlink" href="#man_x" title="Permanent link">&para;</a></h1>
<h1 id="free_1">free<a class="headerlink" href="#free_1" title="Permanent link">&para;</a></h1>
<h1 id="man_x_1">man X<a class="headerlink" href="#man_x_1" title="Permanent link">&para;</a></h1>
<h1 id="free_2">free<a class="headerlink" href="#free_2" title="Permanent link">&para;</a></h1>
<p>你可以先后比较一下free后显示buffers的大小。
另一个实验：</p>
<h1 id="free_3">free<a class="headerlink" href="#free_3" title="Permanent link">&para;</a></h1>
<h1 id="ls_dev">ls /dev<a class="headerlink" href="#ls_dev" title="Permanent link">&para;</a></h1>
<h1 id="free_4">free<a class="headerlink" href="#free_4" title="Permanent link">&para;</a></h1>
<p>你比较一下两个的大小，当然这个buffers随时都在增加，但你有ls过的话，增加的速度会变得快，
这个就是buffers/chached的区别。</p>
<p>因为Linux将你暂时不使用的内存作为文件和数据缓存，以提高系统性能，当你需要这些内存时，
系统会自动释放（不像windows那样，即使你有很多空闲内存,他也要访问一下磁盘中的pagefiles）
使用free命令
将used的值减去 buffer和cache的值就是你当前真实内存使用 ————– 对操作系统 来讲是
Mem的参数.buffers/cached 都是属于被使用,所以它认为free只有16936.
对应用程序 来讲是(-/+ buffers/cach).buffers/cached 是等同可用的，因为buffer/cached是为 了
提高 程序执行的性能， 当程序使用内存时，buffer/cached会很快地被使用。 所以,以应用来看看,
以(-/+ buffers/cache)的free和used为主.所以我们看这个就好了.另外告诉大家 一些常识.Linux
为了提高磁盘和内存存取效率, Linux做了很多精心的设计, 除了对dentry进行缓存(用于 VFS,加速
文件路径名到inode的转换), 还采取了两种主要Cache方式：Buffer Cache和Page Cache。 前者针
对磁盘块的读写，后者针对文件inode的读写。这些Cache能有效缩短了 I/O系统调用(比如
read,write,getdents)的时间。 记住内存是拿来用的,不是拿来看的. 不象windows,无论你的真实物
理内存有多少,他都要拿硬盘交换 文 件来读.这也就是windows为什么常常提示虚拟空间不足的原因.
你们想想,多无聊,在内存还有大部分 的时候,拿出一部分硬盘空间来充当内存.硬盘怎么会快过内存.
所以我们看linux,只要不用swap的交换 空间,就不用担心自己的内存太少.如果常常swap用很多,可
能你就要考虑加物理内存了.这也是linux看 内存是否够用的标准哦.
[root@scs-2 tmp]# free
total used free shared buffers cached
Mem: 3266180 3250004 16176 0 110652 2668236
-/+ buffers/cache: 471116 2795064
Swap: 2048276 80160 1968116
下面是对这些数值的解释：
total:总计物理内存的大小。
used:已使用多大。
free:可用有多少。
Shared:多个进程共享的内存总额。
Buffers/cached:磁盘缓存 的大小。
第三行(-/+ buffers/cached):
used:已使用多大。
free:可用有多少。
第四行就不多解释了。
区别：第二行(mem)的used/free与第三行(-/+ buffers/cache) used/free的区别。 这两个的区别在于使用
的角度来看，第一行是从OS的角度来看，因为对于OS，buffers/cached 都是属于被使用，所以他的可
用内存是16176KB,已用内存是3250004KB,其中包括，内核（OS）使用+Application(X, oracle,etc)使用的
+buffers+cached.
第三行所指的是从应用程序角度来看，对于应用程序来说，buffers/cached 是等于可用的，因为
buffer/cached是为了提高文件读取的性能，当应用程序需在用到内存的时候，buffer/cached会很快地被
回收。
所以从应用程序的角度来说，可用内存=系统free memory+buffers+cached。
如上例：
2795064=16176+110652+2668236
接下来解释什么时候内存会被交换，以及按什么方交换。 当可用内存少于额定值的时候，就会开会进
行交换。
如何看额定值：</p>
<p>cat /proc/meminfo
[root@scs-2 tmp]# cat /proc/meminfo
MemTotal: 3266180 kB
MemFree: 17456 kB
Buffers: 111328 kB
Cached: 2664024 kB
SwapCached: 0 kB
Active: 467236 kB
Inactive: 2644928 kB
HighTotal: 0 kB
HighFree: 0 kB
LowTotal: 3266180 kB
LowFree: 17456 kB
SwapTotal: 2048276 kB
SwapFree: 1968116 kB
Dirty: 8 kB
Writeback: 0 kB
Mapped: 345360 kB
Slab: 112344 kB
Committed_AS: 535292 kB
PageTables: 2340 kB
VmallocTotal: 536870911 kB
VmallocUsed: 272696 kB
VmallocChunk: 536598175 kB
HugePages_Total: 0
HugePages_Free: 0
Hugepagesize: 2048 kB
用free -m查看的结果：
[root@scs-2 tmp]# free -m
total used free shared buffers cached
Mem: 3189 3173 16 0 107 2605
-/+ buffers/cache: 460 2729
Swap: 2000 78 1921</p>
<p>查看/proc/kcore文件的大小（内存镜像）：
[root@scs-2 tmp]# ll -h /proc/kcore
-r-------- 1 root root 4.1G Jun 12 12:04 /proc/kcore
备注：
占用内存的测量
测量一个进程占用了多少内存，linux为我们提供了一个很方便的方法，/proc目录为我们提供了所有的
信息，实际上top等工具也通过这里来获取相应的信息。
/proc/meminfo 机器的内存使用信息
/proc/pid/maps pid为进程号，显示当前进程所占用的虚拟地址。
/proc/pid/statm 进程所占用的内存</p>
<p>[root@localhost ~]# cat /proc/self/statm
654 57 44 0 0 334 0
输出解释
CPU 以及CPU0。。。的每行的每个参数意思（以第一行为例）为：
参数 解释 /proc//status
Size (pages) 任务虚拟地址空间的大小 VmSize/4
Resident(pages) 应用程序正在使用的物理内存的大小 VmRSS/4
Shared(pages) 共享页数 0
Trs(pages) 程序所拥 有的可执行虚拟内存的大小 VmExe/4
Lrs(pages) 被映像到任务的虚拟内存空间的库的大小 VmLib/4
Drs(pages) 程序数据段和用户态的栈的大小 （VmData+ VmStk ） 4
dt(pages) 04
查看机器可用内存
/proc/28248/&gt;free
total used free shared buffers cached
Mem: 1023788 926400 97388 0 134668 503688
-/+ buffers/cache: 288044 735744
Swap: 1959920 89608 1870312
我们通过free命令查看机器空闲内存时，会发现free的值很小。这主要是因为，在linux中有这么一种
思想，内存不用白不用，因此它尽可能的cache和buffer一些数据，以方便下次使用。但实际上这些内
存也是可以立刻拿来使用的。
所以 空闲内存=free+buffers+cached=total-used</p>
<h4 id="2_vmstat">2 、 vmstat<a class="headerlink" href="#2_vmstat" title="Permanent link">&para;</a></h4>
<p>很显然从名字中我们就可以知道vmstat是一个查看虚拟内存（Virtual Memory）使用状况的工具，但
是怎样通过vmstat来发现系统中的瓶颈呢？在回答这个问题前，还是让我们回顾一下Linux中关于虚拟
内存相关内容。</p>
<h4 id="21">2.1 、虚拟内存运行原理<a class="headerlink" href="#21" title="Permanent link">&para;</a></h4>
<h5 id="_58">在系统中运行的每个进程都需要使用到内存，但不是每个进程都需要每时每刻使用系统分配的内存<a class="headerlink" href="#_58" title="Permanent link">&para;</a></h5>
<h5 id="_59">空间。当系统运行所需内存超过实际的物理内存，内核会释放某些进程所占用但未使用的部分或所有物<a class="headerlink" href="#_59" title="Permanent link">&para;</a></h5>
<h5 id="_60">理内存，将这部分资料存储在磁盘上直到进程下一次调用，并将释放出的内存提供给有需要的进程使用。<a class="headerlink" href="#_60" title="Permanent link">&para;</a></h5>
<p>在Linux内存管理中，主要是通过“调页Paging”和“交换Swapping”来完成上述的内存调度。调页算
法是将内存中最近不常使用的页面换到磁盘上，把活动页面保留在内存中供进程使用。交换技术是将整
个进程，而不是部分页面，全部交换到磁盘上。
分页(Page)写入磁盘的过程被称作Page-Out，分页(Page)从磁盘重新回到内存的过程被称作Page-In。当
内核需要一个分页时，但发现此分页不在物理内存中(因为已经被Page-Out了)，此时就发生了分页错误
（Page Fault）。
当系统内核发现可运行内存变少时，就会通过Page-Out来释放一部分物理内存。经管Page-Out不是经
常发生，但是如果Page-out频繁不断的发生，直到当内核管理分页的时间超过运行程式的时间时，系
统效能会急剧下降。这时的系统已经运行非常慢或进入暂停状态，这种状态亦被称作thrashing(颠簸)。</p>
<h4 id="22_vmstat">2.2 、使用 vmstat<a class="headerlink" href="#22_vmstat" title="Permanent link">&para;</a></h4>
<h5 id="1_5">1.用法<a class="headerlink" href="#1_5" title="Permanent link">&para;</a></h5>
<div class="highlight"><pre><span></span><code>vmstat [-a] [-n] [-S unit] [delay [ count]]
</code></pre></div>
<p>vmstat [-s] [-n] [-S unit]
vmstat [-m] [-n] [delay [ count]]
vmstat [-d] [-n] [delay [ count]]
vmstat [-p disk partition] [-n] [delay [ count]]
vmstat [-f]
vmstat [-V]
-a：显示活跃和非活跃内存
-f：显示从系统启动至今的fork数量 。
-m：显示slabinfo
-n：只在开始时显示一次各字段名称。
-s：显示内存相关统计信息及多种系统活动数量。
delay：刷新时间间隔。如果不指定，只显示一条结果。
count：刷新次数。如果不指定刷新次数，但指定了刷新时间间隔，这时刷新次数为无穷。
-d：显示磁盘相关统计信息。
-p：显示指定磁盘分区统计信息
-S：使用指定单位显示。参数有 k 、K 、m 、M ，分别代表 1000 、 1024 、 1000000 、 1048576 字 节（byte）。
默认单位为K（1024 bytes）
-V：显示vmstat版本信息。</p>
<h4 id="23_1">2.3 、实例<a class="headerlink" href="#23_1" title="Permanent link">&para;</a></h4>
<h5 id="1_6">例子 1 ：每 2 秒输出一条结果<a class="headerlink" href="#1_6" title="Permanent link">&para;</a></h5>
<h5 id="_61">字段说明：<a class="headerlink" href="#_61" title="Permanent link">&para;</a></h5>
<p><strong>Procs</strong> （进程）：
r: 运行的和等待(CPU时间片)运行的进程数，这个值也可以判断是否需要增加CPU(长期大于1)
b: 等待IO的进程数量，处于不可中断状态的进程数，常见的情况是由IO引起的
<strong>Memory</strong> （内存）：
swpd: 使用虚拟内存大小，切换到交换内存上的内存(默认以KB为单位)
如果 swpd 的值不为 0 ，或者还比较大，比如超过100M了，但是 si, so 的值长期为 0 ，这种情况我
们可以不用担心，不会影响系统性能。
free: 空闲的物理内存
buff: 用作缓冲的内存大小
cache: 用作缓存的内存大小，文件系统的cache，如果 cache 的值大的时候，说明cache住的文件数
多，如果频繁访问到的文件都能被cache住，那么磁盘的读IO bi 会非常小
<strong>Swap</strong> ：
si: 每秒从交换区写到内存的大小，交换内存使用，由磁盘调入内存
so: 每秒写入交换区的内存大小，交换内存使用，由内存调入磁盘
内存够用的时候，这 2 个值都是 0 ，如果这 2 个值长期大于 0 时，系统性能会受到影响。磁盘IO和
CPU资源都会被消耗。</p>
<p>常有人看到空闲内存(free)很少或接近于 0 时，就认为内存不够用了，实际上不能光看这一点的，还
要结合si,so，如果free很少，但是si,so也很少(大多时候是0)，那么不用担心，系统性能这时不会受
到影响的。
<strong>IO</strong> ：（现在的 <strong>Linux</strong> 版本块的大小为 <strong>1024bytes</strong> ）
bi: 每秒读取的块数，从块设备读入的数据总量(读磁盘) (KB/s)
bo: 每秒写入的块数，写入到块设备的数据总理(写磁盘) (KB/s)
随机磁盘读写的时候，这 2 个 值越大（如超出1M），能看到CPU在IO等待的值也会越大
<strong>system</strong> ：
in: 每秒中断数，包括时钟中断。
cs: 每秒上下文切换数。
上面这 2 个值越大，会看到由内核消耗的CPU时间会越多
<strong>CPU</strong> （以百分比表示）：
us: 用户进程消耗的CPU时间百分比，us 的值比较高时，说明用户进程消耗的CPU时间多，但是如
果长期超过50% 的使用，那么我们就该考虑优化程序算法或者进行加速了
sy: 内核进程消耗的CPU时间百分比，sy 的值高时，说明系统内核消耗的CPU资源多，这并不是良
性的表现，我们应该检查原因。
id: CPU处在空闲状态时间百分比(包括IO等待时间)
wa: IO等待消耗的CPU时间百分比，wa 的值高时，说明IO等待比较严重，这可能是由于磁盘大量
作随机访问造成，也有可能是磁盘的带宽出现瓶颈(块操作)。
例子 <strong>2</strong> ：显示活跃和非活跃内存</p>
<p>使用-a选项显示活跃和非活跃内存时，所显示的内容除增加inact和active外，其他显示内容与例子 1
相同。
字段说明：
<strong>Memory</strong> （内存）：
inact: 非活跃内存大小（当使用-a选项时显示）
active: 活跃的内存大小（当使用-a选项时显示）
注：如果r经常大于 4 ，且id经常少于 40 ，表示cpu的负荷很重，如果bi，bo长期不等于 0 ，表示内
存不足，如果disk经常不等于 0 ，且在b中的队列大于 3 ，表示io性能不好。
CPU问题现象：
1.)如果在processes中运行的序列(process r)是连续的大于在系统中的CPU的个数表示系统现在运行比较
慢,有多数的进程等待CPU.
2.)如果r的输出数大于系统中可用CPU个数的 4 倍的话,则系统面临着CPU短缺的问题,或者是CPU的速
率过低,系统中有多数的进程在等待CPU,造成系统中进程运行过慢.
3.)如果空闲时间(cpu id)持续为 0 并且系统时间(cpu sy)是用户时间的两倍(cpu us)系统则面临着CPU资源
的短缺.
解决办法:</p>
<h5 id="cpucpu">当发生以上问题的时候请先调整应用程序对CPU的占用情况.使得应用程序能够更有效的使用CPU.同<a class="headerlink" href="#cpucpu" title="Permanent link">&para;</a></h5>
<p>时可以考虑增加更多的CPU. 关于CPU的使用情况还可以结合mpstat, ps aux top prstat –a等
等一些相应的命令来综合考虑关于具体的CPU的使用情况,和那些进程在占用大量的CPU时间.一般情
况下，应用程序的问题会比较大一些.比如一些SQL语句不合理等等都会造成这样的现象.
内存问题现象:
内存的瓶颈是由scan rate (sr)来决定的.scan rate是通过每秒的始终算法来进行页扫描的.如果scan
rate(sr)连续的大于每秒 200 页则表示可能存在内存缺陷.同样的如果page项中的pi和po这两栏表示每
秒页面的调入的页数和每秒调出的页数.如果该值经常为非零值,也有可能存在内存的瓶颈,当然,如果个
别的时候不为 0 的话,属于正常的页面调度这个是虚拟内存的主要原理.
解决办法:
1.调节applications &amp; servers使得对内存和cache的使用更加有效.
2.增加系统的内存.</p>
<ol>
<li>Implement priority paging in s in pre solaris 8 versions by adding line "set priority paging=1" in
/etc/system. Remove this line if upgrading from Solaris 7 to 8 &amp; retaining old /etc/system file.
关于内存的使用情况还可以结ps aux top prstat –a等等一些相应的命令来综合考虑关于具体的内
存的使用情况,和那些进程在占用大量的内存.一般情况下，如果内存的占用率比较高,但是,CPU的占用
很低的时候,可以考虑是有很多的应用程序占用了内存没有释放,但是,并没有占用CPU时间,可以考虑
应用程序,对于未占用CPU时间和一些后台的程序,释放内存的占用</li>
</ol>
<h4 id="44">4.4 、案例<a class="headerlink" href="#44" title="Permanent link">&para;</a></h4>
<h5 id="_62">案例学习：<a class="headerlink" href="#_62" title="Permanent link">&para;</a></h5>
<h5 id="1_7">1 ：在这个例子中,这个系统被充分利用<a class="headerlink" href="#1_7" title="Permanent link">&para;</a></h5>
<div class="highlight"><pre><span></span><code># vmstat 1
procs memory swap io system cpu
r b swpd free buff cache si so bi bo in cs us sy wa id
3 0 206564 15092 80336 176080 0 0 0 0 718 26 81 19 0 0
2 0 206564 14772 80336 176120 0 0 0 0 758 23 96 4 0 0
1 0 206564 14208 80336 176136 0 0 0 0 820 20 96 4 0 0
1 0 206956 13884 79180 175964 0 412 0 2680 1008 80 93 7 0 0
2 0 207348 14448 78800 175576 0 412 0 412 763 70 84 16 0 0
2 0 207348 15756 78800 175424 0 0 0 0 874 25 89 11 0 0
1 0 207348 16368 78800 175596 0 0 0 0 940 24 86 14 0 0
1 0 207348 16600 78800 175604 0 0 0 0 929 27 95 3 0 2
3 0 207348 16976 78548 175876 0 0 0 2508 969 35 93 7 0 0
4 0 207348 16216 78548 175704 0 0 0 0 874 36 93 6 0 1
4 0 207348 16424 78548 175776 0 0 0 0 850 26 77 23 0 0
2 0 207348 17496 78556 175840 0 0 0 0 736 23 83 17 0 0
0 0 207348 17680 78556 175868 0 0 0 0 861 21 91 8 0 1
根据观察值,我们可以得到以下结论：
1.有大量的中断(in) 和较少的上下文切换(cs).这意味着一个单一的进程在产生对硬件设备的请求.
2.进一步显示某单个应用,user time(us)经常在85%或者更多.考虑到较少的上下文切换,这个应用应该
还在处理器中被处理.
3.运行队列还在可接受的性能范围内,其中有 2 个地方,是超出了允许限制.
2 ：在这个例子中,内核调度中的上下文切换处于饱和
# vmstat 1
</code></pre></div>
<div class="highlight"><pre><span></span><code>procs memory swap io system cpu
r b swpd free buff cache si so bi bo in cs us sy wa id
2 1 207740 98476 81344 180972 0 0 2496 0 900 2883 4 12 57 27
0 1 207740 96448 83304 180984 0 0 1968 328 810 2559 8 9 83 0
0 1 207740 94404 85348 180984 0 0 2044 0 829 2879 9 6 78 7
0 1 207740 92576 87176 180984 0 0 1828 0 689 2088 3 9 78 10
2 0 207740 91300 88452 180984 0 0 1276 0 565 2182 7 6 83 4
3 1 207740 90124 89628 180984 0 0 1176 0 551 2219 2 7 91 0
4 2 207740 89240 90512 180984 0 0 880 520 443 907 22 10 67 0
5 3 207740 88056 91680 180984 0 0 1168 0 628 1248 12 11 77 0
4 2 207740 86852 92880 180984 0 0 1200 0 654 1505 6 7 87 0
6 1 207740 85736 93996 180984 0 0 1116 0 526 1512 5 10 85 0
0 1 207740 84844 94888 180984 0 0 892 0 438 1556 6 4 90 0
根据观察值,我们可以得到以下结论：
1.上下文切换数目高于中断数目,说明kernel中相当数量的时间都开销在上下文切换线程.
2.大量的上下文切换将导致CPU 利用率分类不均衡.很明显实际上等待io 请求的百分比(wa)非常高,
以及user time百分比非常低(us).
3.因为CPU 都阻塞在IO请求上,所以运行队列里也有相当数目的可运行状态线程在等待执行.
</code></pre></div>
<h4 id="3_iostat">3 、 iostat<a class="headerlink" href="#3_iostat" title="Permanent link">&para;</a></h4>
<p>用途：报告中央处理器（CPU）统计信息和整个系统、适配器、tty 设备、磁盘和 CD-ROM 的输入／
输出统计信息。
语法：iostat [ -c | -d ] [ -k ] [ -t | -m ] [ -V ] [ -x [ device ] ] [ interval [ count ] ]
描述：iostat 命令用来监视系统输入／输出设备负载，这通过观察与它们的平均传送速率相关的物
理磁盘的活动时间来实现。iostat 命令生成的报告可以用来更改系统配置来更好地平衡物理磁盘和适配
器之间的输入／输出负载。
参数：-c为汇报CPU的使用情况；-d为汇报磁盘的使用情况；-k表示每秒按kilobytes字节显示数据；
-m表示每秒按M字节显示数据；-t为打印汇报的时间；-v表示打印出版本信息和用法；-x device指定
要统计的设备名称，默认为所有的设备；interval指每次统计间隔的时间；count指按照这个时间间隔统
计的次数。
iostat 结果解析</p>
<p>rrqm/s: 每秒进行 merge 的读操作数目。即 delta(rmerge)/s
wrqm/s: 每秒进行 merge 的写操作数目。即 delta(wmerge)/s
r/s: 每秒完成的读 I/O 设备次数。即 delta(rio)/s
w/s: 每秒完成的写 I/O 设备次数。即 delta(wio)/s
rsec/s: 每秒读扇区数。即 delta(rsect)/s</p>
<p>wsec/s: 每秒写扇区数。即 delta(wsect)/s
rkB/s: 每秒读K字节数。是 rsect/s 的一半，因为每扇区大小为 512 字节。
wkB/s: 每秒写K字节数。是 wsect/s 的一半。
avgrq-sz: 平均每次设备I/O操作的数据大小 (扇区)。即 delta(rsect+wsect)/delta(rio+wio)
avgqu-sz: 平均I/O队列长度。即 delta(aveq)/s/1000 (因为aveq的单位为毫秒)。
await: 平均每次设备I/O操作的等待时间 (毫秒)。即 delta(ruse+wuse)/delta(rio+wio)
svctm: 平均每次设备I/O操作的服务时间 (毫秒)。即 delta(use)/delta(rio+wio)
%util: 一秒中有百分之多少的时间用于 I/O 操作，或者说一秒中有多少时间 I/O 队列是非空的。即
delta(use)/s/1000 (因为use的单位为毫秒)
如果 %util 接近 100%，说明产生的I/O请求太多，I/O系统已经满负荷，该磁盘可能存在瓶颈。
比较重要的参数
%util: 一秒中有百分之多少的时间用于 I/O 操作，或者说一秒中有多少时间 I/O 队列是非空的
svctm: 平均每次设备I/O操作的服务时间
await: 平均每次设备I/O操作的等待时间
avgqu-sz: 平均I/O队列长度
如果%util接近100%,表明i/o请求太多,i/o系统已经满负荷,磁盘可能存在瓶颈,一般%util大于70%,i/o压
力就比较大,读取速度有较多的wait.同时可以结合vmstat查看查看b参数(等待资源的进程数)和wa参数
(IO等待所占用的CPU时间的百分比,高过30%时IO压力高)。
要理解这些性能指标我们先看下图</p>
<h5 id="io">IO的执行过程的各个参数<a class="headerlink" href="#io" title="Permanent link">&para;</a></h5>
<p>上图的左边是iostat显示的各个性能指标，每个性能指标都会显示在一条虚线之上，这表明这个性
能指标是从虚线之上的那个读写阶段开始计量的，比如说图中的w/s从Linux IO scheduler开始穿过硬盘
控制器(CCIS/3ware)，这就表明w/s统计的是每秒钟从Linux IO scheduler通过硬盘控制器的写IO的数量。
结合上图对读IO操作的过程做一个说明，在从OS Buffer Cache传入到OS Kernel(Linux IO scheduler)
的读IO操作的个数实际上是rrqm/s+r/s，直到读IO请求到达OS Kernel层之后，有每秒钟有rrqm/s个
读IO操作被合并，最终转送给磁盘控制器的每秒钟读IO的个数为r/w；在进入到操作系统的设备层
(/dev/sda)之后，计数器开始对IO操作进行计时，最终的计算结果表现是await，这个值就是我们要的
IO响应时间了；svctm是在IO操作进入到磁盘控制器之后直到磁盘控制器返回结果所花费的时间，这
是一个实际IO操作所花的时间，当await与svctm相差很大的时候，我们就要注意磁盘的IO性能了；
而avgrq-sz是从OS Kernel往下传递请求时单个IO的大小，avgqu-sz则是在OS Kernel中IO请求队列 的
平均大小。
现在我们可以将iostat输出结果和我们上面讨论的指标挂钩了
设备IO操作:总IO(io)/s = r/s(读) +w/s(写) =1.46 + 25.28=26.74
平均每次设备I/O操作只需要0.36毫秒完成,现在却需要10.57毫秒完成，因为发出的请求太多(每秒26.74
个)，假如请求时同时发出的，可以这样计算平均等待时间:
平均等待时间=单个I/O服务器时间*(1+2+...+请求总数-1)/请求总数
每秒发出的I/0请求很多,但是平均队列就4,表示这些请求比较均匀,大部分处理还是比较及时
svctm 一般要小于 await (因为同时等待的请求的等待时间被重复计算了)，svctm 的大小一般和磁盘性
能有关，CPU/内存的负荷也会对其有影响，请求过多也会间接导致 svctm 的增加。await 的大小一般
取决于服务时间(svctm) 以及 I/O 队列的长度和 I/O 请求的发出模式。如果 svctm 比较接近 await，
说明 I/O 几乎没有等待时间；如果 await 远大于 svctm，说明 I/O 队列太长，应用得到的响应时间变
慢，如果响应时间超过了用户可以容许的范围，这时可以考虑更换更快的磁盘，调整内核 elevator 算
法，优化应用，或者升级 CPU。
队列长度(avgqu-sz)也可作为衡量系统 I/O 负荷的指标，但由于 avgqu-sz 是按照单位时间的平均值，所
以不能反映瞬间的 I/O 洪水。
<strong>I/O</strong> 系统 <strong>vs.</strong> 超市排队
举一个例子，我们在超市排队 checkout 时，怎么决定该去哪个交款台呢? 首当是看排的队人数， 5 个
人总比 20 人要快吧? 除了数人头，我们也常常看看前面人购买的东西多少，如果前面有个采购了一星
期食品的大妈，那么可以考虑换个队排了。还有就是收银员的速度了，如果碰上了连钱都点不清楚的新
手，那就有的
等了。另外，时机也很重要，可能 5 分钟前还人满为患的收款台，现在已是人去楼空，这时候交款可
是很爽啊，当然，前提是那过去的 5 分钟里所做的事情比排队要有意义 (不过我还没发现什么事情比
排队还无聊的)。
I/O 系统也和超市排队有很多类似之处:
r/s+w/s 类似于交款人的总数
平均队列长度(avgqu-sz)类似于单位时间里平均排队人的个数
平均服务时间(svctm)类似于收银员的收款速度
平均等待时间(await)类似于平均每人的等待时间
平均I/O数据(avgrq-sz)类似于平均每人所买的东西多少
I/O 操作率 (％util)类似于收款台前有人排队的时间比例。
我们可以根据这些数据分析出 I/O 请求的模式，以及 I/O 的速度和响应时间。</p>
<p>一个例子</p>
<h1 id="iostat_-x_1">iostat -x 1<a class="headerlink" href="#iostat_-x_1" title="Permanent link">&para;</a></h1>
<p>avg-cpu: ％user ％nice ％sys ％idle
16.24 0.00 4.31 79.44
Device: rrqm/s wrqm/s r/s w/s rsec/s wsec/s rkB/s wkB/s avgrq-sz avgqu-sz await svctm ％util
/dev/cciss/c0d0
0.00 44.90 1.02 27.55 8.16 579.59 4.08 289.80 20.57 22.35 78.21 5.00 14.29
/dev/cciss/c0d0p1
0.00 44.90 1.02 27.55 8.16 579.59 4.08 289.80 20.57 22.35 78.21 5.00 14.29
/dev/cciss/c0d0p2
0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00
上面的 iostat 输出表明秒有 28.57 次设备 I/O 操作: delta(io)/s = r/s +w/s = 1.02+27.55 = 28.57 (次/秒)
其中写操作占了主体 (w:r = 27:1)。
平均每次设备 I/O 操作只需要 5ms 就可以完成，但每个 I/O 请求却需要等上78ms，为什么? 因为发
出的 I/O 请求太多 (每秒钟约 29 个)，假设这些请求是同时发出的，那么平均等待时间可以这样计算:
平均等待时间 = 单个 I/O 服务时间 * ( 1 + 2 + ... + 请求总数-1) / 请求总数
应用到上面的例子: 平均等待时间 = 5ms * (1+2+...+28)/29 = 70ms，和iostat 给出的 78ms 的平均等待
时间很接近。这反过来表明 I/O 是同时发起的。每秒发出的 I/O 请求很多 (约 29 个)，平均队列却不
长 (只有 2 个 左右)，这表明这 29 个请求的到来并不均匀，大部分时间 I/O 是空闲的。一秒中有
14.29％ 的时间 I/O 队列中是有请求的，也就是说，85.71％ 的时间里I/O 系统无事可做，所有 29 个
I/O 请求都在 142 毫秒之内处理掉了。
delta(ruse+wuse)/delta(io) = await = 78.21 =&gt; delta(ruse+wuse)/s =78.21 * delta(io)/s = 78.21*28.57 = 2232.8，
表明每秒内的I/O请求总共需要等待2232.8ms。所以平均队列长度应为 2232.8ms/1000ms = 2.23，而
iostat
给出的平均队列长度 (avgqu-sz) 却为 22.35，为什么?! 因为 iostat 中有bug，avgqu-sz 值应为 2.23，
而不是 22.35。</p>
<h4 id="4_uptime">4 、 uptime<a class="headerlink" href="#4_uptime" title="Permanent link">&para;</a></h4>
<p>uptime命令用于查看服务器运行了多长时间以及有多少个用户登录，快速获知服务器的负荷情况。
uptime的输出包含一项内容是load average，显示了最近 1 ， 5 ， 15 分钟的负荷情况。它的值代表等待
CPU处理的进程数，如果CPU没有时间处理这些进程，load average值会升高；反之则会降低。load average
的最佳值是 1 ，说明每个进程都可以马上处理并且没有CPU cycles被丢失。对于单CPU的机器， 1 或者
2 是可以接受的值；对于多路CPU的机器，load average值可能在 8 到 10 之间。也可以使用uptime命
令来判断网络性能。例如，某个网络应用性能很低，通过运行uptime查看服务器的负荷是否很高，如
果不是，那么问题应该是网络方面造成的。
以下是uptime的运行实例：
9:24am up 19:06, 1 user, load average: 0.00, 0.00, 0.00
也可以查看/proc/loadavg和/proc/uptime两个文件，注意不能编辑/proc中的文件，要用cat等命令来查
看，如：
liyawei:~ # cat /proc/loadavg
0.0 0.00 0.00 1/55 5505
uptime命令用法十分简单：直接输入</p>
<h1 id="uptime">uptime<a class="headerlink" href="#uptime" title="Permanent link">&para;</a></h1>
<p>例：
18:02:41 up 41 days, 23:42, 1 user, load average: 0.00, 0.00, 0.00</p>
<h5 id="1_cpu1-3smp6-10">1 可以被认为是最优的负载值。负载是会随着系统不同改变得。单CPU系统1-3和SMP系统6-10都是<a class="headerlink" href="#1_cpu1-3smp6-10" title="Permanent link">&para;</a></h5>
<h5 id="_63">可能接受的。<a class="headerlink" href="#_63" title="Permanent link">&para;</a></h5>
<p>另外还有一个参数 -V ，是用来查询版本的。 (注意是大写的字母v)
[linux @ localhost]$ uptime -V
procps version 3.2.7
[linux @ localhost]$ uptime
显示结果为：
10:19:04 up 257 days, 18:56, 12 users, load average: 2.10, 2.10,2.09
显示内容说明：
10:19:04 //系统当前时间
up 257 days, 18:56 //主机已运行时间,时间越大，说明你的机器越稳定。
12 user //用户连接数，是总连接数而不是用户数
load average // 系统平均负载，统计最近 1 ， 5 ， 15 分钟的系统平均负载
那么什么是系统平均负载呢？ 系统平均负载是指在特定时间间隔内运行队列中的平均进程数。如
果每个CPU内核的当前活动进程数不大于 3 的话，那么系统的性能是良好的。如果每个CPU内核的任
务数大于 5 ，那么这台机器的性能有严重问题。如果你的linux主机是 1 个双核CPU的话，当Load Average
为 6 的时候说明机器已经被充分使用了。</p>
<h4 id="5_w">5 、 W<a class="headerlink" href="#5_w" title="Permanent link">&para;</a></h4>
<p>w命令主要是查看当前登录的用户，这个命令相对来说比较简单。我们来看一下截图。</p>
<p>在上面这个截图里面呢，第一列user，代表登录的用户，第二列，tty代表用户登录的终端号，因为在
linux中并不是只有一个终端的，pts/2代表是图形界面的第二个终端（这仅是个人意见，网上的对pts
的看法可能有些争议）。第三列FROM代表登录的地方，如果是远程登录的，会显示ip地址，:0 表示的
是 display 0:0，意思就是主控制台的第一个虚拟终端。第四列login@代表登录的时间，第五列的IDLE
代表系统的闲置时间。最后一列what是代表正在运行的进程，因为我正在运行w命令，所以咋root
显示w。</p>
<h4 id="5_mpstat">5 、 mpstat<a class="headerlink" href="#5_mpstat" title="Permanent link">&para;</a></h4>
<p>mpstat （RHEL5默认不安装）
mpstat是MultiProcessor Statistics的缩写，是实时系统监控工具。其报告与CPU的一些统计信息，
这些信息存放在/proc/stat文件中。在多CPUs系统里，其不但能查看所有CPU的平均状况信息，而且
能够查看特定CPU的信息。下面只介绍mpstat与CPU相关的参数，mpstat的语法如下：
mpstat [-P {|ALL}] [internal [count]]
参数的含义如下：
-P {|ALL} 表示监控哪个CPU， cpu在[0,cpu个数-1]中取值
internal 相邻的两次采样的间隔时间
count 采样的次数，count只能和delay一起使用
当没有参数时，mpstat则显示系统启动以后所有信息的平均值。有interval时，第一行的信息自系
统启动以来的平均信息。
从第二行开始，输出为前一个interval时间段的平均信息。与CPU有关的输出的含义如下：
[oracle@Test ~]$ mpstat -P ALL</p>
<p>Linux 2.6.18-194.el5 (Test.linux.com) 2010年 06 月 22 日
09 时 18 分 18 秒 CPU %user %nice %sys %iowait %irq %soft %steal %idle intr/s
09 时 18 分 18 秒 all 0.06 0.00 0.43 0.78 0.00 0.00 0.00 98.71 1069.35
09 时 18 分 18 秒 0 0.05 0.00 0.36 0.17 0.02 0.00 0.00 99.41 1032.01
09 时 18 分 18 秒 1 0.04 0.00 0.42 0.07 0.00 0.00 0.00 99.47 0.26
09 时 18 分 18 秒 2 0.11 0.00 0.28 0.08 0.00 0.00 0.00 99.52 0.00
09 时 18 分 18 秒 3 0.07 0.00 0.48 0.05 0.00 0.00 0.00 99.39 0.01
09 时 18 分 18 秒 4 0.08 0.00 0.19 5.63 0.00 0.02 0.00 94.08 24.51
09 时 18 分 18 秒 5 0.05 0.00 0.63 0.11 0.00 0.00 0.00 99.21 0.22
09 时 18 分 18 秒 6 0.07 0.00 0.45 0.10 0.00 0.01 0.00 99.36 12.33
09 时 18 分 18 秒 7 0.05 0.00 0.64 0.07 0.00 0.00 0.00 99.24 0.00
参数 解释 从/proc/stat获得数据CPU 处理器ID
user 在internal时间段里，用户的CPU时间（%） ，不包含 nice值为负 进程 (usr/total)*100
nice 在internal时间段里，nice值为负进程的CPU时间（%） (nice/total)*100
system 在internal时间段里，核心时间（%） (system/total)*100
iowait 在internal时间段里，硬盘IO等待时间（%） (iowait/total)*100
irq 在internal时间段里 ，硬中断时间（%） (irq/total)*100
soft 在internal时间段里，软中断时间（%） (softirq/total)*100
idle 在internal时间段里，CPU除去等待磁盘IO操作外的因为任何原因而空闲的时间闲置时间（%）
(idle/total)*100
intr/s 在internal时间段里，每秒CPU接收的中断的次数intr/total)*100
CPU总的工作时间=total_cur=user+system+nice+idle+iowait+irq+softirq
total_pre=pre_user+ pre_system+ pre_nice+ pre_idle+ pre_iowait+ pre_irq+ pre_softirq
user=user_cur – user_pre
total=total_cur-total_pre
其中_cur 表示当前值，_pre表示interval时间前的值。上表中的所有值可取到两位小数点。
范例 1 ：average mode (粗略信息)当mpstat不带参数时，输出为从系统启动以来的平均值。
[work@builder linux-2.6.14]$ mpstat
Linux 2.6.9-5.31AXsmp (builder.redflag-linux.com) 12/16/2005
09:38:46 AM CPU %user %nice %system %iowait %irq %soft %idle intr/s
09:38:48 AM all 23.28 0.00 1.75 0.50 0.00 0.00 74.47 1018.59
范例2: 每 2 秒产生了 2 个处理器的统计数据报告
下面的命令可以每 2 秒产生了 2 个处理器的统计数据报告，一共产生三个interval 的信息，然后再给出
这三个interval的平均信息。默认时，输出是按照CPU 号排序。第一个行给出了从系统引导以来的所有
活跃数据。接下来每行对应一个处理器的活跃状态。
[root@server yum_dir]# mpstat -P ALL 2 3
Linux 2.6.18-164.el5 (server.sys.com) 01/04/2010
09:34:20 PM CPU %user %nice %sys %iowait %irq %soft %steal %idle intr/s
09:34:22 PM all 0.00 0.00 0.00 0.00 0.00 0.00 0.00 100.00 1001.49
09:34:22 PM 0 0.00 0.00 0.50 0.00 0.00 0.00 0.00 99.50 1001.00
09:34:22 PM 1 0.00 0.00 0.00 0.00 0.00 0.00 0.00 100.00 0.00
09:34:22 PM CPU %user %nice %sys %iowait %irq %soft %steal %idle intr/s
09:34:24 PM all 0.00 0.00 0.25 0.00 0.00 0.00 0.00 99.75 1005.00
09:34:24 PM 0 0.00 0.00 0.00 0.00 0.00 0.00 0.00 100.00 1005.50</p>
<h5 id="093424_pm_1_000_000_000_000_000_000_000_10000_000">09:34:24 PM 1 0.00 0.00 0.00 0.00 0.00 0.00 0.00 100.00 0.00<a class="headerlink" href="#093424_pm_1_000_000_000_000_000_000_000_10000_000" title="Permanent link">&para;</a></h5>
<p>09:34:24 PM CPU %user %nice %sys %iowait %irq %soft %steal %idle intr/s
09:34:26 PM all 0.00 0.00 0.00 0.00 0.00 0.00 0.00 100.00 1001.49
09:34:26 PM 0 0.00 0.00 0.00 0.00 0.00 0.00 0.00 100.00 1001.00
09:34:26 PM 1 0.00 0.00 0.00 0.00 0.00 0.00 0.00 100.00 0.00
Average: CPU %user %nice %sys %iowait %irq %soft %steal %idle intr/s
Average: all 0.00 0.00 0.08 0.00 0.00 0.00 0.00 99.92 1002.66
Average: 0 0.00 0.00 0.17 0.00 0.00 0.00 0.00 99.83 1002.49
Average: 1 0.00 0.00 0.00 0.00 0.00 0.00 0.00 100.00 0.00
范例 3 ：比较带参数和不带参数的mpstat的结果。
在后台开一个2G的文件</p>
<h1 id="cat_1img">cat 1.img &amp;<a class="headerlink" href="#cat_1img" title="Permanent link">&para;</a></h1>
<p>然后在另一个终端运行mpstat命令
[root@server ~]# cat 1.img &amp;
[1] 6934
[root@server ~]# mpstat
Linux 2.6.18-164.el5 (server.sys.com) 01/04/2010
10:17:31 PM CPU %user %nice %sys %iowait %irq %soft %steal %idle intr/s
10:17:31 PM all 0.07 0.02 0.25 0.21 0.01 0.04 0.00 99.40 1004.57
[root@server ~]# mpstat
Linux 2.6.18-164.el5 (server.sys.com) 01/04/2010
10:17:35 PM CPU %user %nice %sys %iowait %irq %soft %steal %idle intr/s
10:17:35 PM all 0.07 0.02 0.25 0.21 0.01 0.04 0.00 99.39 1004.73
[root@server ~]# mpstat
Linux 2.6.18-164.el5 (server.sys.com) 01/04/2010
10:17:39 PM CPU %user %nice %sys %iowait %irq %soft %steal %idle intr/s
10:17:39 PM all 0.07 0.02 0.25 0.21 0.01 0.04 0.00 99.38 1004.96
[root@server ~]# mpstat
Linux 2.6.18-164.el5 (server.sys.com) 01/04/2010
10:17:44 PM CPU %user %nice %sys %iowait %irq %soft %steal %idle intr/s
10:17:44 PM all 0.07 0.02 0.26 0.21 0.01 0.05 0.00 99.37 1005.20
[root@server ~]# mpstat 3 10
Linux 2.6.18-164.el5 (server.sys.com) 01/04/2010
10:17:55 PM CPU %user %nice %sys %iowait %irq %soft %steal %idle intr/s
10:17:58 PM all 13.12 0.00 20.93 0.00 1.83 9.80 0.00 54.32 2488.08
10:18:01 PM all 10.82 0.00 19.30 0.83 1.83 9.32 0.00 57.90 2449.83
10:18:04 PM all 10.95 0.00 20.40 0.17 1.99 8.62 0.00 57.88 2384.05
10:18:07 PM all 10.47 0.00 18.11 0.00 1.50 8.47 0.00 61.46 2416.00
10:18:10 PM all 11.81 0.00 22.63 0.00 1.83 11.98 0.00 51.75 2210.60
10:18:13 PM all 6.31 0.00 10.80 0.00 1.00 5.32 0.00 76.58 1795.33
10:18:19 PM all 1.75 0.00 3.16 0.75 0.25 1.25 0.00 92.85 1245.18
10:18:22 PM all 11.94 0.00 19.07 0.00 1.99 8.29 0.00 58.71 2630.46
10:18:25 PM all 11.65 0.00 19.30 0.50 2.00 9.15 0.00 57.40 2673.91
10:18:28 PM all 11.44 0.00 21.06 0.33 1.99 10.61 0.00 54.56 2369.87</p>
<p>Average: all 9.27 0.00 16.18 0.30 1.50 7.64 0.00 65.11 2173.54
[root@server ~]#
上两表显示出当要正确反映系统的情况，需要正确使用命令的参数。vmstat 和iostat 也需要注意这一
问题。</p>
<h4 id="6_pmap">6 、 pmap<a class="headerlink" href="#6_pmap" title="Permanent link">&para;</a></h4>
<p>pmap命令可以显示进程的内存映射，使用这个命令可以找出造成内存瓶颈的原因。</p>
<h1 id="pmap_-d_pid">pmap -d PID<a class="headerlink" href="#pmap_-d_pid" title="Permanent link">&para;</a></h1>
<p>显示PID为 47394 进程的内存信息。</p>
<h1 id="pmap_-d_47394">pmap -d 47394<a class="headerlink" href="#pmap_-d_47394" title="Permanent link">&para;</a></h1>
<p>输出样例：
47394: /usr/bin/php-cgi
Address Kbytes Mode Offset Device Mapping
0000000000400000 2584 r-x-- 0000000000000000 008:00002 php-cgi
0000000000886000 140 rw--- 0000000000286000 008:00002 php-cgi
00000000008a9000 52 rw--- 00000000008a9000 000:00000 [ anon ]
0000000000aa8000 76 rw--- 00000000002a8000 008:00002 php-cgi
000000000f678000 1980 rw--- 000000000f678000 000:00000 [ anon ]
000000314a600000 112 r-x-- 0000000000000000 008:00002 ld-2.5.so
000000314a81b000 4 r---- 000000000001b000 008:00002 ld-2.5.so
000000314a81c000 4 rw--- 000000000001c000 008:00002 ld-2.5.so
000000314aa00000 1328 r-x-- 0000000000000000 008:00002 libc-2.5.so
000000314ab4c000 2048 ----- 000000000014c000 008:00002 libc-2.5.so
.....
......
00002af8d48fd000 4 rw--- 0000000000006000 008:00002 xsl.so
00002af8d490c000 40 r-x-- 0000000000000000 008:00002 libnss_files-2.5.so
00002af8d4916000 2044 ----- 00 0000000000a000 008:00002 libnss_files-2.5.so
00002af8d4b15000 4 r---- 0000000000009000 008:00002 libnss_files-2.5.so
00002af8d4b16000 4 rw--- 000000000000a000 008:00002 libnss_files-2.5.so
00002af8d4b17000 768000 rw-s- 0000000000000000 000:00009 zero (deleted)
00007fffc95fe000 84 rw--- 00007ffffffea000 000:00000 [ stack ]
ffffffffff600000 8192 ----- 0000000000000000 000:00000 [ anon ]
mapped: 933712K writeable/private: 4304K shared: 768000K
最后一行非常重要：
* mapped: 933712K 内存映射所占空间大小
* writeable/private: 4304K 私有地址空间大小
* shared: 768000K 共享地址空间大小</p>
<h4 id="7_sar">7 、 sar<a class="headerlink" href="#7_sar" title="Permanent link">&para;</a></h4>
<p>sar是一个优秀的一般性能监视工具，它可以输出Linux所完成的几乎所有工作的数据。sar命令在
sysetat rpm中提供。示例中使用sysstat版本5.0.5，这是稳定的最新版本之一。关于版本和下载信息，
请访问sysstat主页http://perso.wanadoo.fr/sebastien.godard/。
sar可以显示CPU、运行队列、磁盘I/O、分页 （交换区）、内存、CPU中断、网络等性能数据。最重要
的sar功能是创建数据文件。每一个Linux系统都应该通过cron工作收集sar数据。该sar数据文件为</p>
<p>系统管理员提供历史性能信息。这个功能非常重要，它将sar和其他性能工具区分开。如果一个夜晚批
处理工作正常运行两次，直到下一个早上才会发现这种情况（除非被叫醒）。我们需要具备研究 12 小时
以前的性能数据的能力。sar数据收集器提供了这种能力。
sar 命令行的常用格式：
sar [options] [-A] [-o file] t [n]</p>
<p>在命令行中，n 和t 两个参数组合起来定义采样间隔和次数，t为采样间隔，是必须有的参数，n
为采样次数，是可选的，默认值是 1 ，-o file表示将命令结果以二进制格式存放在文件中，file 在此处
不是关键字，是文件名。options 为命令行选项，sar命令的选项很多，下面只列出常用选项：</p>
<ul>
<li>A：所有报告的总和。</li>
<li>u：CPU利用率</li>
<li>v：进程、I节点、文件和锁表状态。</li>
<li>d：硬盘使用报告。</li>
<li>r：没有使用的内存页面和硬盘块。</li>
<li>g：串口I/O的情况。</li>
<li>b：缓冲区使用情况。</li>
<li>a：文件读写情况。</li>
<li>c：系统调用情况。</li>
<li>R：进程的活动情况。</li>
<li>y：终端设备活动情况。</li>
<li>w：系统交换活动。</li>
</ul>
<h4 id="71_cpu">7.1 、 CPU 统计数据<a class="headerlink" href="#71_cpu" title="Permanent link">&para;</a></h4>
<p>sar -u输出显示CPU信息。-u选项是sar的默认选项。该输出以百分比显示CPU的使用情况。表3-2
解释该输出。
表3-2 sar -u字段
字 段 说 明
CPU CPU编号
%user CPU 花费在用户进程（如应用程序、Shell 脚本或与
该用户进行的交互）上的时间的百分比。</p>
<p>%nice (^) 运行正常进程所花的时间
%system 在内核模式（系统）中运行进程所花的时间, 也就是
CPU 用来执行核心任务的时间的百分比。
%iowait 没有进程在该CPU上执行时，处理器等待I/O完成的
时间
%idle 没有进程在该CPU上执行的时间
这些看起来应该比较熟悉，它和top报告中的CPU信息内容相同。以下显示输出格式：
[oracle@Test ~]$ sar -u -o aixi 60 5
Linux 2.6.18-194.el5 (Test.linux.com) 06/22/10
13:41:25 CPU %user %nice %system %iowait %steal %idle
13:42:25 all 0.28 0.00 0.21 1.17 0.00 98.34
13:43:25 all 0.23 0.00 0.16 1.14 0.00 98.46</p>
<p><div class="highlight"><pre><span></span><code>13:44:25 all 0.27 0.00 0.21 1.40 0.00 98.12
13:45:25 all 0.26 0.00 0.19 0.99 0.00 98.56
13:46:25 all 0.32 0.00 0.23 1.39 0.00 98.05
Average: all 0.27 0.00 0.20 1.22 0.00 98.31
</code></pre></div>
<div class="highlight"><pre><span></span><code>每 60 秒采样一次，连续采样 5 次，观察CPU 的使用情况，并将采样结果以二进制形式存入当前目
录下的文件aixi中
</code></pre></div>
<div class="highlight"><pre><span></span><code>在所有的显示中，我们应主要注意%wio和%idle，%wio的值过高，表示硬盘存在I/O瓶颈，%idle
值高，表示CPU较空闲，如果%idle值高但系统响应慢时，有可能是CPU等待分配内存，此时应加大内
存容量。%idle值如果持续低于 10 ，那么系统的CPU处理能力相对较低，表明系统中最需要解决的资源
是CPU。另外任何sar报告的第一列都是时间戳。
</code></pre></div>
<div class="highlight"><pre><span></span><code>如果要查看二进制文件aixi中的内容，则需键入如下sar命令：
</code></pre></div>
<div class="highlight"><pre><span></span><code># sar -u -f aixi
</code></pre></div>
<div class="highlight"><pre><span></span><code>可见，sar命令即可以实时采样，又可以对以往的采样结果进行查询。
</code></pre></div>
<div class="highlight"><pre><span></span><code>我们本来可以研究使用-f选项通过sadc创建的文件。这个sar语法显示sar -f/var/log/ sa/sa21的输出：
</code></pre></div>
在多CPU Linux系统中，sar命令也可以为每个CPU分解该信息，如以下sar -u -P ALL 5 5输出所示：</p>
<h4 id="io_1">磁盘 I/O 统计数据<a class="headerlink" href="#io_1" title="Permanent link">&para;</a></h4>
<p>sar是一个研究磁盘I/O的优秀工具。以下是sar磁盘I/O输出的一个示例。</p>
<p>第一行-d显示磁盘I/O信息， 5 2 选项是间隔和迭代，就像sar数据收集器那样。表3-3列出了字段和说
明。
表3-3 sar -d字段
字 段 说 明
DEV 磁盘设备
tps 每秒传输数（或者每秒IO数）
rd_sec/s 每秒 512 字节读取数
wr_sec/s 每秒 512 字节写入数
512 只是一个测量单位，不表示所有磁盘I/O均使用 512 字节块。DEV列是dev#-#格式的磁盘设备，其中
第一个#是设备主编号，第二个#是次编号或者连续编号。对于大于2.5的内核，sar使用次编号。例如，
在sar -d输出中看到的dev3-0和dev3-1。它们对应于/dev/hda和/dev/hdal。请看/dev中的以下各项：</p>
<p>/dev/hda有主编号 3 和次编号 0 。hda1有主编号 3 和次编号 1 。
<strong>3.2.4</strong> 网络统计数据
sar提供四种不同的语法选项来显示网络信息。-n选项使用四个不同的开关：DEV、EDEV、SOCK和FULL。
DEV显示网络接口信息，EDEV显示关于网络错误的统计数据，SOCK显示套接字信息，FULL显示所有三
个开关。它们可以单独或者一起使用。表3-4显示通过-n DEV选项报告的字段。
表3-4 sar -n DEV字段
字 段 说 明</p>
<p>IFACE (^) LAN接口</p>
<p>rxpck/s (^) 每秒钟接收的数据包
txpck/s 每秒钟发送的数据包
rxbyt/s 每秒钟接收的字节数
txbyt/s 每秒钟发送的字节数
rxcmp/s 每秒钟接收的压缩数据包
txcmp/s 每秒钟发送的压缩数据包
rxmcst/s 每秒钟接收的多播数据包
以下是使用-n DEV选项的sar输出：
关于网络错误的信息可以用sar -n EDEV显示。表3-5列出了显示的字段。</p>
<p>表3-5 sar -n EDEV字段
字 段 说 明
IFACE LAN接口
rxerr/s 每秒钟接收的坏数据包
txerr/s 每秒钟发送的坏数据包
coll/s 每秒冲突数
rxdrop/s 因为缓冲充满，每秒钟丢弃的已接收数据包数
txdrop/s 因为缓冲充满，每秒钟丢弃的已发送数据包数
txcarr/s 发送数据包时，每秒载波错误数
rxfram/s 每秒接收数据包的帧对齐错误数
rxfifo/s 接收的数据包每秒FIFO过速的错误数
txfifo/s 发送的数据包每秒FIFO过速的错误数
SOCK参数显示IPCS套接字信息。表3-6列出显示的字段及其意义。
表3-6 sar -n SOCK字段
字 段 说 明
totsck 使用的套接字总数量
tcpsck 使用的TCP套接字数量
udpsck 使用的UDP套接字数量
rawsck 使用的raw套接字数量
ip-frag 使用的IP段数量</p>
<p>sar可以产生许多其他报告。我们有必要仔细阅读sar（ 1 ）手册页，查看是否有自己需要的其他报告</p>
<p><div class="highlight"><pre><span></span><code>例二：使用命行sar -v t n
</code></pre></div>
<div class="highlight"><pre><span></span><code>例如，每 30 秒采样一次，连续采样 5 次，观察核心表的状态，需键入如下命令：
</code></pre></div>
<div class="highlight"><pre><span></span><code># sar -v 30 5
</code></pre></div>
<div class="highlight"><pre><span></span><code>屏幕显示：
SCO_SV scosysv 3.2v5.0.5 i80386 10/01/2001
10:33:23 proc-sz ov inod-sz ov file-sz ov lock-sz (-v)
10:33:53 305/ 321 0 1337/2764 0 1561/1706 0 40/ 128
10:34:23 308/ 321 0 1340/2764 0 1587/1706 0 37/ 128
10:34:53 305/ 321 0 1332/2764 0 1565/1706 0 36/ 128
10:35:23 308/ 321 0 1338/2764 0 1592/1706 0 37/ 128
10:35:53 308/ 321 0 1335/2764 0 1591/1706 0 37/ 128
</code></pre></div>
<div class="highlight"><pre><span></span><code>显示内容包括：
</code></pre></div>
<div class="highlight"><pre><span></span><code>proc-sz：目前核心中正在使用或分配的进程表的表项数，由核心参数MAX-PROC控制。
</code></pre></div>
<div class="highlight"><pre><span></span><code>inod-sz：目前核心中正在使用或分配的i节点表的表项数，由核心参数MAX-INODE控制。
</code></pre></div>
<div class="highlight"><pre><span></span><code>file-sz： 目前核心中正在使用或分配的文件表的表项数，由核心参数MAX-FILE控制。
</code></pre></div>
<div class="highlight"><pre><span></span><code>ov：溢出出现的次数。
</code></pre></div>
<div class="highlight"><pre><span></span><code>Lock-sz：目前核心中正在使用或分配的记录加锁的表项数，由核心参数MAX-FLCKRE控制。
</code></pre></div>
<div class="highlight"><pre><span></span><code>显示格式为
</code></pre></div>
<div class="highlight"><pre><span></span><code>实际使用表项/可以使用的表项数
</code></pre></div>
<div class="highlight"><pre><span></span><code>显示内容表示，核心使用完全正常，三个表没有出现溢出现象，核心参数不需调整，如果出现溢出
时，要调整相应的核心参数，将对应的表项数加大。
</code></pre></div></p>
<p>例三：使用命行sar -d t n</p>
<p>例如，每 30 秒采样一次，连续采样 5 次，报告设备使用情况，需键入如下命令：</p>
<h1 id="sar_-d_30_5">sar -d 30 5<a class="headerlink" href="#sar_-d_30_5" title="Permanent link">&para;</a></h1>
<p>屏幕显示：</p>
<p>SCO_SV scosysv 3.2v5.0.5 i80386 10/01/2001
11:06:43 device %busy avque r+w/s blks/s avwait avserv (-d)
11:07:13 wd-0 1.47 2.75 4.67 14.73 5.50 3.14
11:07:43 wd-0 0.43 18.77 3.07 8.66 25.11 1.41
11:08:13 wd-0 0.77 2.78 2.77 7.26 4.94 2.77
11:08:43 wd-0 1.10 11.18 4.10 11.26 27.32 2.68
11:09:13 wd-0 1.97 21.78 5.86 34.06 69.66 3.35
Average wd-0 1.15 12.11 4.09 15.19 31.12 2.80</p>
<p>显示内容包括：</p>
<p>device： sar命令正在监视的块设备的名字。
%busy： 设备忙时，传送请求所占时间的百分比。
avque： 队列站满时，未完成请求数量的平均值。
r+w/s： 每秒传送到设备或从设备传出的数据量。
blks/s： 每秒传送的块数，每块 512 字节。
avwait： 队列占满时传送请求等待队列空闲的平均时间。
avserv： 完成传送请求所需平均时间（毫秒）。</p>
<p>在显示的内容中，wd- 0是硬盘的名字，%busy的值比较小，说明用于处理传送请求的有效时间太少，
文件系统效率不高，一般来讲，%busy值高些，avque值低些，文件系统的效率比较高，如果%busy和
avque值相对比较高，说明硬盘传输速度太慢，需调整。</p>
<p>例四：使用命行sar -b t n</p>
<p>例如，每 30 秒采样一次，连续采样 5 次，报告缓冲区的使用情况，需键入如下命令：</p>
<h1 id="sar_-b_30_5">sar -b 30 5<a class="headerlink" href="#sar_-b_30_5" title="Permanent link">&para;</a></h1>
<p>屏幕显示：</p>
<p>SCO_SV scosysv 3.2v5.0.5 i80386 10/01/2001
14:54:59 bread/s lread/s %rcache bwrit/s lwrit/s %wcache pread/s pwrit/s (-b)
14:55:29 0 147 100 5 21 78 0 0
14:55:59 0 186 100 5 25 79 0 0</p>
<h5 id="145629_4_232_98_8_58_86_0_0">14:56:29 4 232 98 8 58 86 0 0<a class="headerlink" href="#145629_4_232_98_8_58_86_0_0" title="Permanent link">&para;</a></h5>
<h5 id="145659_0_125_100_5_23_76_0_0">14:56:59 0 125 100 5 23 76 0 0<a class="headerlink" href="#145659_0_125_100_5_23_76_0_0" title="Permanent link">&para;</a></h5>
<h5 id="145729_0_89_100_4_12_66_0_0">14:57:29 0 89 100 4 12 66 0 0<a class="headerlink" href="#145729_0_89_100_4_12_66_0_0" title="Permanent link">&para;</a></h5>
<p>Average 1 156 99 5 28 80 0 0</p>
<p>显示内容包括：</p>
<p>bread/s： 每秒从硬盘读入系统缓冲区buffer的物理块数。
lread/s： 平均每秒从系统buffer读出的逻辑块数。
%rcache： 在buffer cache中进行逻辑读的百分比。
bwrit/s： 平均每秒从系统buffer向磁盘所写的物理块数。
lwrit/s： 平均每秒写到系统buffer逻辑块数。
%wcache： 在buffer cache中进行逻辑读的百分比。
pread/s： 平均每秒请求物理读的次数。
pwrit/s： 平均每秒请求物理写的次数。</p>
<p>在显示的内容中，最重要的是%cache和%wcache两列，它们的值体现着buffer的使用效率，%rcache
的值小于 90 或者%wcache的值低于 65 ，应适当增加系统buffer的数量，buffer数量由核心参数NBUF
控制，使%rcache达到 90 左右，%wcache达到 80 左右。但buffer参数值的多少影响I/O效率，增加
buffer，应在较大内存的情况下，否则系统效率反而得不到提高。</p>
<p>例五：使用命行sar -g t n</p>
<p>例如，每 30 秒采样一次，连续采样 5 次，报告串口I/O的操作情况，需键入如下命令：</p>
<h1 id="sar_-g_30_5">sar -g 30 5<a class="headerlink" href="#sar_-g_30_5" title="Permanent link">&para;</a></h1>
<p>屏幕显示：</p>
<p>SCO_SV scosysv 3.2v5.0.5 i80386 11/22/2001
17:07:03 ovsiohw/s ovsiodma/s ovclist/s (-g)
17:07:33 0.00 0.00 0.00
17:08:03 0.00 0.00 0.00
17:08:33 0.00 0.00 0.00
17:09:03 0.00 0.00 0.00
17:09:33 0.00 0.00 0.00
Average 0.00 0.00 0.00</p>
<p>显示内容包括：</p>
<p>ovsiohw/s：每秒在串口I/O硬件出现的溢出。</p>
<div class="highlight"><pre><span></span><code>ovsiodma/s：每秒在串口I/O的直接输入输出通道高速缓存出现的溢出。
</code></pre></div>
<p>ovclist/s ：每秒字符队列出现的溢出。</p>
<p>在显示的内容中，每一列的值都是零，表明在采样时间内，系统中没有发生串口I/O溢出现象。</p>
<p>sar命令的用法很多，有时判断一个问题，需要几个sar命令结合起来使用，比如，怀疑CPU存在
瓶颈，可用sar -u 和sar -q来看，怀疑I/O存在瓶颈，可用sar -b、sar -u和sar -d来看。</p>
<hr />
<p>Sar
-A 所有的报告总和
-a 文件读，写报告
-B 报告附加的buffer cache使用情况
-b buffer cache使用情况
-c 系统调用使用报告
-d 硬盘使用报告
-g 有关串口I/O情况
-h 关于buffer使用统计数字
-m IPC消息和信号灯活动
-n 命名cache
-p 调页活动
-q 运行队列和交换队列的平均长度
-R 报告进程的活动
-r 没有使用的内存页面和硬盘块
-u CPU利用率
-v 进程，i节点，文件和锁表状态
-w 系统交换活动
-y TTY设备活动</p>
<p>-a 报告文件读，写报告
sar –a 5 5
SCO_SV scosvr 3.2v5.0.5 PentII(D)ISA 06/07/2002
11:45:40 iget/s namei/s dirbk/s (-a)
11:45:45 6 2 2
11:45:50 91 20 28
11:45:55 159 20 18
11:46:00 157 21 19
11:46:05 177 30 35
Average 118 18 20</p>
<p>iget/s 每秒由i节点项定位的文件数量
namei/s 每秒文件系统路径查询的数量
dirbk/s 每秒所读目录块的数量</p>
<h5 id="_64">＊这些值越大，表明核心花在存取用户文件上的时间越多，它反映着一些程序和应用文件系统产生<a class="headerlink" href="#_64" title="Permanent link">&para;</a></h5>
<p>的负荷。一般地，如果iget/s与namei/s的比值大于 5 ，并且namei/s的值大于 30 ，则说明文件系统
是低效的。这时需要检查文件系统的自由空间，看看是否自由空间过少。</p>
<p>-b 报告缓冲区（buffer cache）的使用情况
sar -b 2 3
SCO_SV scosvr 3.2v5.0.5 PentII(D)ISA 06/07/2002
13:51:28 bread/s lread/s %rcache bwrit/s lwrit/s %wcache pread/s pwrit/s (-b)
13:51:30 382 1380 72 131 273 52 0 0
13:51:32 378 516 27 6 22 72 0 0
13:51:34 172 323 47 39 57 32 0 0
Average 310 739 58 58 117 50 0 0</p>
<p>bread/s 平均每秒从硬盘（或其它块设备）读入系统buffer的物理块数
lread/s 平均每秒从系统buffer读出的逻辑块数
%rcache 在buffer cache中进行逻辑读的百分比（即 100 ％ - bread/lreads）
bwrit/s 平均每秒从系统buffer向磁盘（或其它块设备）所写的物理块数
lwrit/s 平均每秒写到系统buffer的逻辑块数
%wcache 在buffer cache中进行逻辑写的百分比（即 100 ％ - bwrit/lwrit）.
pread/sgu 平均每秒请求进行物理读的次数
pwrit/s 平均每秒请求进行物理写的次数</p>
<p>＊所显示的内容反映了目前与系统buffer有关的读，写活。在所报告的数字中，最重要的是%rcache
和%wcache（统称为cache命中率）两列，它们具体体现着系统buffer的效率。衡量cache效率的标准
是它的命中率值的大小。
＊如果%rcache的值小于 90 或者%wcache的值低于 65 ，可能就需要增加系统buffer的数量。如果
在系统的应用中，系统的I/O活动十分频繁，并且在内存容量配置比较大时，可以增加buffer cache，
使%rcache达到 95 左右，%wcache达到 80 左右。
＊系统buffer cache中，buffer的数量由核心参数NBUF控制。它是一个要调的参数。系统中buffer
数量的多少是影响系统I/O效率的瓶颈。要增加系统buffer数量，则要求应该有较大的内存配置。否
则一味增加buffer数量，势必减少用户进程在内存中的运行空间，这同样会导致系统效率下降。</p>
<p>-c 报告系统调用使用情况
sar -c 2 3
SCO_SV scosvr 3.2v5.0.5 PentII(D)ISA 06/07/2002
17:02:42 scall/s sread/s swrit/s fork/s exec/s rchar/s wchar/s (-c)
17:02:44 2262 169 141 0.00 0.00 131250 22159
17:02:46 1416 61 38 0.00 0.00 437279 6464
17:02:48 1825 43 25 0.00 0.00 109397 42331
Average 1834 91 68 0.00 0.00 225975 23651</p>
<p>scall/s 每秒使用系统调用的总数。一般地，当4~6个用户在系统上工作时，每秒大约 30 个左右。</p>
<p>sread/s 每秒进行读操作的系统调用数量。
swrit/s 每秒进行写操作的系统调用数量。
fork/s 每秒fork系统调用次数。当4~6个用户在系统上工作时，每秒大约0.5秒左右。
exec/s 每秒exec系统调用次数。
rchar/s 每秒由读操作的系统调用传送的字符（以字节为单位）。
wchar/s 每秒由写操作的系统调用传送的字符（以字节为单位）。
＊如果scall/s持续地大于 300 ，则表明正在系统中运行的可能是效率很低的应用程序。在比较典
型的情况下，进行读操作的系统调用加上进行写操作的系统调用之和，约是scall的一半左右。</p>
<p>-d 报告硬盘使用情况
sar -d 2 3
SCO_SV scosvr 3.2v5.0.5 PentII(D)ISA 06/07/2002
17:27:49 device %busy avque r+w/s blks/s avwait avserv (-d)
17:27:51 ida-0 6.93 1.00 13.86 259.41 0.00 5.00
ida-1 0.99 1.00 17.33 290.10 0.00 0.57
17:27:53 ida-0 75.50 1.00 54.00 157.00 0.00 13.98
ida-1 9.50 1.00 12.00 75.00 0.00 7.92
17:27:55 ida-0 7.46 1.00 46.77 213.93 0.00 1.60
ida-1 17.41 1.00 57.71 494.53 0.00 3.02
Average ida-0 29.85 1.00 38.14 210.28 0.00 7.83
ida-1 9.29 1.00 29.02 286.90 0.00 3.20</p>
<p>device 这是sar命令正在监视的块设备的名字。
%busy 设备忙时，运行传送请求所占用的时间。这个值以百分比表示。
avque 在指定的时间周期内，没有完成的请求数量的平均值。仅在队列被占满时取这个值。
r+w/s 每秒传送到设备或者从设备传送出的数据量。
blks/s 每秒传送的块数。每块 512 个字节。
avwait 传送请求等待队列空闲的平均时间（以毫秒为单位）。仅在队列被占满时取这个值。
avserv 完成传送请求所需平均时间（以毫秒为单位）
＊ida- 0和ida- 1是硬盘的设备名字。在显示的内容中，如果%busy的值比较小，说明用于处理传
送请求的有效时间太少，文件系统的效率不高。要使文件系统的效率得到优化，应使%busy的数值相对
高一些，而avque的值应该低一些。</p>
<p>-g 报告有关串口I/O情况
sar -g 3 3
SCO_SV scosvr 3.2v5.0.5 PentII(D)ISA 06/13/2002
11:10:09 ovsiohw/s ovsiodma/s ovclist/s (-g)
11:10:12 0.00 0.00 0.00
11:10:15 0.00 0.00 0.00
11:10:18 0.00 0.00 0.00
Average 0.00 0.00 0.00</p>
<p>ovsiohw/s 每秒在串囗I/O硬件出现的溢出。
ovsiodma/s 每秒在串囗I/O的直接输入，输出信道高速缓存出现的溢出。
ovclist/s 每秒字符队列出现的溢出。</p>
<p>-m 报告进程间的通信活动（IPC消息和信号灯活动）情况
sar -m 4 3
SCO_SV scosvr 3.2v5.0.5 PentII(D)ISA 06/13/2002
13:24:28 msg/s sema/s (-m)
13:24:32 2.24 9.95
13:24:36 2.24 21.70
13:24:40 2.00 36.66
Average 2.16 22.76</p>
<p>msg/s 每秒消息操作的次数（包括发送消息的接收信息）。
sema/s 每秒信号灯操作次数。
＊信号灯和消息作为进程间通信的工具，如果在系统中运行的应用过程中没有使用它们，那么由
sar命令报告的msg 和sema的值都将等于0.00。如果使用了这些工具，并且其中或者msg/s大于 100 ，
或者sema/s大于 100 ，则表明这样的应用程序效率比较低。原因是在这样的应用程序中，大量的时间
花费在进程之间的沟通上，而对保证进程本身有效的运行时间必然产生不良的影响。</p>
<p>-n 报告命名缓冲区活动情况
sar -n 4 3
SCO_SV scosvr 3.2v5.0.5 PentII(D)ISA 06/13/2002
13:37:31 c_hits cmisses (hit %) (-n)
13:37:35 1246 71 (94%)
13:37:39 1853 81 (95%)
13:37:43 969 56 (94%)
Average 1356 69 (95%)</p>
<p>c_hits cache命中的数量。
cmisses cache未命中的数量。
(hit %) 命中数量/(命中数理+未命中数量)。
＊不难理解，(hit %)值越大越好，如果它低于 90 ％，则应该调整相应的核心参数。</p>
<p>-p 报告分页活动
sar -p 5 3
SCO_SV scosvr 3.2v5.0.5 PentII(D)ISA 06/13/2002
13:45:26 vflt/s pflt/s pgfil/s rclm/s (-p)
13:45:31 36.25 50.20 0.00 0.00
13:45:36 32.14 58.48 0.00 0.00</p>
<h5 id="134541_7980_5840_000_000">13:45:41 79.80 58.40 0.00 0.00<a class="headerlink" href="#134541_7980_5840_000_000" title="Permanent link">&para;</a></h5>
<p>Average 49.37 55.69 0.00 0.00</p>
<p>vflt/s 每秒进行页面故障地址转换的数量（由于有效的页面当前不在内存中）。
pflt/s 每秒来自由于保护错误出现的页面故障数量（由于对页面的非法存，取引起的页面故障）。
pgfil/s 每秒通过”页—入”满足vflt/s的数量。
rclm/s 每秒由系统恢复的有效页面的数量。有效页面被增加到自由页面队列上。
＊如果vflt/s的值高于 100 ，可能预示着对于页面系统来说，应用程序的效率不高，也可能分页
参数需要调整，或者内存配置不太合适。</p>
<p>-q 报告进程队列（运行队列和交换队列的平均长度）情况
sar -q 2 3
SCO_SV scosvr 3.2v5.0.5 PentII(D)ISA 06/13/2002
14:25:50 runq-sz %runocc swpq-sz %swpocc (-q)
14:25:52 4.0 50
14:25:54 9.0 100
14:25:56 9.0 100
Average 7.3 100</p>
<p>runq-sz 准备运行的进程运行队列。
%runocc 运行队列被占用的时间（百分比）
swpq-sz 要被换出的进程交换队列。
%swpocc 交换队列被占用的时间（百分比）。
＊如果%runocc大于 90 ，并且runq-sz的值大于 2 ，则表明CPU的负载较重。其直接后果，可能使
系统的响应速度降低。如果%swpocc大于 20 ，表明交换活动频繁，将严重导致系统效率下降。解决的办
法是加大内存或减少缓存区数量，从而减少交换及页—入,页—出活动。</p>
<p>-r 报告内存及交换区使用情况（没有使用的内存页面和硬盘块）
sar -r 2 3
SCO_SV scosvr 3.2v5.0.5 PentII(D)ISA 06/14/2002
10:14:19 freemem freeswp availrmem availsmem (-r)
10:14:22 279729 6673824 93160 1106876
10:14:24 279663 6673824 93160 1106876
10:14:26 279661 6673824 93160 1106873
Average 279684 6673824 93160 1106875</p>
<p>freemem 用户进程可以使用的内存页面数，4KB为一个页面。
freeswp 用于进程交换可以使用的硬盘盘块，512B为一个盘块。</p>
<p>-u CPU利用率
sar -u 2 3</p>
<p>SCO_SV scosvr 3.2v5.0.5 PentII(D)ISA 06/14/2002
10:27:23 %usr %sys %wio %idle (-u)
10:27:25 2 3 8 88
10:27:27 3 3 5 89
10:27:29 0 0 0 100
Average 2 2 4 92
.
%usr cpu处在用户模式下时间（百分比）
%sys cpu处在系统模式下时间（百分比）
%wio cpu等待输入，输出完成（时间百分比）
%idle cpu空闲时间（百分比）
＊在显示的内容中，%usr和 %sys这两个值一般情况下对系统无特别影响，%wio的值不能太高，
如果%wio的值过高，则CPU花在等待输入，输出上的时间太多，这意味着硬盘存在I/O瓶颈。如果%idle
的值比较高，但系统响应并不快，那么这有可能是CPU花时间等待分配内存引起的。%idle的值可以较
深入帮助人们了解系统的性能，在这种情况上，%idle的值处于40~100之间，一旦它持续低于 30 ，则
表明进程竟争的主要资源不是内存而是CPU。
＊在有大量用户运行的系统中，为了减少CPU的压力，应该使用智能多串卡，而不是非智能多串卡。
智能多串卡可以承担CPU的某些负担。
＊此外，如果系统中有大型的作业运行，应该把它们合理调度，错开高峰，当系统相对空闲时再运
行。</p>
<p>-v 报告系统表的内容（进程，i节点，文件和锁表状态）
sar -v 2 3
SCO_SV scosvr 3.2v5.0.5 PentII(D)ISA 06/14/2002
10:56:46 proc-sz ov inod-sz ov file-sz ov lock-sz (-v)
10:56:48 449/ 500 0 994/4147 0 1313/2048 0 5/ 128
10:56:50 450/ 500 0 994/4147 0 1314/2048 0 5/ 128
10:56:52 450/ 500 0 994/4147 0 1314/2048 0 5/ 128</p>
<p>proc-sz 目前在核心中正在使用或分配的进程表的表项数
inod-sz 目前在核心中正在使用或分配的i节点表的表项数
file-sz 目前在核心中正在使用或分配的文件表的表项数
ov 溢出出现的次数
lock-sz 目前在核心中正在使用或分配的记录加锁的表项数
＊除ov外，均涉及到unix的核心参数，它们分别受核心参数NPROC,NIMODE,NFILE和FLOCKREC
的控制。
＊显示格式为：
实际使用表项/整个表可以使用的表项数
比如，proc-sz一列所显示的四个数字中，分母的 100 是系统中整个进程表的长度（可建立 100 个
表项），分子上的 24 ， 26 和 25 分别是采样的那一段时间所使用的进程表项。inod -sz，file-sz和lock-sz
三列数字的意义也相同。
三列ov的值分别对应进程表，i节点表和文件表，表明目前这三个表都没有出现溢出现象，当出
现溢出时，需要调整相应的核心参数，将对应表加大。</p>
<p>-w 系统交换活动
sar -w 2 3
SCO_SV scosvr 3.2v5.0.5 PentII(D)ISA 06/14/2002
11:22:05 swpin/s bswin/s swpot/s bswots pswch/s (-w)
11:22:07 0.00 0.0 0.00 0.0 330
11:22:09 0.00 0.0 0.00 0.0 892
11:22:11 0.00 0.0 0.00 0.0 1053
Average 0.00 0.0 0.00 0.0 757</p>
<p>swpin/s 每秒从硬盘交换区传送进入内存的次数。
bswin/s 每秒为换入而传送的块数。
swpot/s 每秒从内存传送到硬盘交换区的次数。
bswots 每秒为换出而传送的块数。
pswch/s 每秒进程交换的数量。
＊swpin/s，bswin/s，swpot/s和bswots描述的是与硬盘交换区相关的交换活动。交换关系到系
统的效率。交换区在硬盘上对硬盘的读，写操作比内存读，写慢得多，因此，为了提高系统效率就应该
设法减少交换。通常的作法就是加大内存，使交换区中进行的交换活动为零，或接近为零。如果swpot/s
的值大于 1 ，预示可能需要增加内存或减少缓冲区（减少缓冲区能够释放一部分自由内存空间）。</p>
<h4 id="8_proc">8 、 proc 文件系统<a class="headerlink" href="#8_proc" title="Permanent link">&para;</a></h4>
<p>"proc文件系统是一个伪文件系统，它只存在内存当中，而不占用外存空间。它以文件系统的方式为
访问系统内核数据的操作提供接口。用户和应用程序可以通过proc得到系统的信息，并可以改变内核
的某些参数。"
这里将介绍如何从/proc文件系统中获取与防火墙相关的一些性能参数，以及如何通过/proc文件系统
修改内核的相关配置。
1 、从/proc文件系统获取相关的性能参数
cpu使用率：/proc/stat
内存使用情况： /proc/meminfo
网络负载信息：/proc/net/dev
相应的计算方法：(摘自：什么是proc文件系统)
（ 1 ） 处理器使用率
（ 2 ） 内存使用率
（ 3 ） 流入流出数据包
（ 4 ） 整体网络负载
这些数据分别要从/proc/stat、/proc/net/dev、/proc/meminfo三个文件中提取。如里有问题或对要
提取的数据不太清楚，可以使用man proc来查看proc文件系统的联机手册。
（ 1 ） 处理器使用率
这里要从/proc/stat中提取四个数据：用户模式（user）、低优先级的用户模式（nice）、内 核 模 式（system）
以及空闲的处理器时间（idle）。它们均位于/proc/stat文件的第一行。CPU的利用率使用如下公式来
计算。
CPU利用率 = 100 *（user + nice + system）/（user + nice + system +
idle）</p>
<h5 id="2_3">（ 2 ） 内存使用率<a class="headerlink" href="#2_3" title="Permanent link">&para;</a></h5>
<p>这里需要从/proc/meminfo文件中提取两个数据，当前内存的使用量(cmem)以及内存总量(amem)。
内存使用百分比 = 100 * (cmem / umem)
（ 3 ）网络利用率
为了得到网络利用率的相关数据，需要从/proc/net/dev文件中获得两个数据：从本机输出的数据包数，
流入本机的数据包数。它们都位于这个文件的第四行。
性能收集程序开始记录下这两个数据的初始值，以后每次获得这个值后均减去这个初始值即为从集群启
动开始从本节点通过的数据包。
利用上述数据计算出网络的平均负载，方法如下：
平均网络负载 = (输出的数据包+流入的数据包) / 2</p>
<ol>
<li>通过/proc文件系统调整相关的内核配置
允许ip转发 /proc/sys/net/ipv4/ip_forward
禁止ping/proc/sys/net/ipv4/icmp_echo_ignore_all
可以在命令行下直接往上述两个“文件”里头写入"1"来实现相关配置，如果写入"0"将取消相关配置。
不过在系统重启以后，这些配置将恢复默认设置，所以，如果想让这些修改生效，可以把下面的配置直
接写入/etc/profile文件，或者其他随系统启动而执行的程序文件中。
1.echo 1 &gt; /proc/sys/net/ipv4/ip_forward
2.echo 1 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all
如果需要获取其他的性能参数，或者需要对内核进行更多的配置，可以参考proc文件系统介绍，也可
以直接通过man proc查看相关的信息。</li>
</ol>
<h2 id="_65">十二、 系统服务<a class="headerlink" href="#_65" title="Permanent link">&para;</a></h2>
<h4 id="1_8">1 、系统服务分类，根据其使用的方法来分，可以被分为三类<a class="headerlink" href="#1_8" title="Permanent link">&para;</a></h4>
<p>a、由init控制的服务：基本都是系统级别的服务，运行级别这一章讲的就是这一类的服务
b、由System V启动脚本启动的服务：和我们打交道最多的一种服务，服务器基本都是这个类型的服务
c、由xinetd管理的服务</p>
<h4 id="2_system_v">2 、 System V 启动脚本启动的服务<a class="headerlink" href="#2_system_v" title="Permanent link">&para;</a></h4>
<div class="highlight"><pre><span></span><code>/etc/rc.d/init.d/目录下的内容如下：这些常用的服务器都是System v的服务，要控制System
V 的服务，我们可以使用以下命令
#/etc/rc.d/init.d/script {start|stop|restart|reload|condrestart|status}
stop：停止这个服务。
restart：先停止，再启动，也就是重新启动的意思。
reload：重新加载设定档，这个参数只有在服务已经启动的状况下才能使用。
condrestart：有条件的重新启动，这个服务必须是已经启动的，才会被重新启
动；如果这个服务尚未启动，则无须启动之。
status：察看目前服务的启动状态。
也可以使用service命令来执行脚本，例如 #service network
{start|stop|restart|reload|condrestart|status}
</code></pre></div>
<p>System V的服务在不同级别下的默认开关可以不相同。我们还可以用两种方法来控制默认情况下，
开机是否开启某些服务,使用chkconfig和ntsysv（图形方式，默认只能定义当前级别，不过可以增加
参数来实现如# ntsysv –level 23 ） 来控制。</p>
<h1 id="chkconfig_--list_system_v">chkconfig --list //查看系统 system v服务所有级别下的开关情况。<a class="headerlink" href="#chkconfig_--list_system_v" title="Permanent link">&para;</a></h1>
<h1 id="chkconfig_sshd_onoff_sshd2-_5">chkconfig sshd on|off //更改 sshd服务2- 5级别的默认开关情况<a class="headerlink" href="#chkconfig_sshd_onoff_sshd2-_5" title="Permanent link">&para;</a></h1>
<h1 id="chkconfig_sendmail_off_sendmail">chkconfig sendmail off //所有级别关闭 sendmail服务<a class="headerlink" href="#chkconfig_sendmail_off_sendmail" title="Permanent link">&para;</a></h1>
<h1 id="chkconfig_--level_23_sendmail_off_2_3_sendmail">chkconfig --level 23 sendmail off //在 2 、 3 级别关闭sendmail服务<a class="headerlink" href="#chkconfig_--level_23_sendmail_off_2_3_sendmail" title="Permanent link">&para;</a></h1>
<h4 id="3_xinetd">3 、 xinetd 服务管理<a class="headerlink" href="#3_xinetd" title="Permanent link">&para;</a></h4>
<p><div class="highlight"><pre><span></span><code>xinetd服务的管理文件都放在 /etc/xinetd.d目录内，我们可以编辑这个目录内的服务文件来
开启和关闭服务。每个服务文件都有disable 这个行，如果把值改成yes就是禁用服务，如果是no，
那就是启动这个服务。修改成功后，要使修改生效，需要从新启动xinetd服务。
#service xinetd restart
</code></pre></div>
<div class="highlight"><pre><span></span><code># vim chargen-dgram
</code></pre></div></p>
<h4 id="4_3">4 、常见服务列表<a class="headerlink" href="#4_3" title="Permanent link">&para;</a></h4>
<h5 id="_66">服务名 必需（是/否）用途描述 注解<a class="headerlink" href="#_66" title="Permanent link">&para;</a></h5>
<div class="highlight"><pre><span></span><code>acon 否 语言支持 特别支持左手书写语言:阿拉伯语,波斯语和希伯莱
语
acpi 否 电源管理 手提电脑电池电扇监控器
acpid 否 监听精灵进程 此进程监听并分配内核中的acpi事件
</code></pre></div>
<p>adsl 否 内部ADSL开关控制 只有你的计算机内部有互联网连接adsl
开关时才用到此服务
alsa 否 高级Linux声音构件 这个单独的声音系统实际包含在内核中
anacron 否 周期命令调度程序 一个任务调度工具
apmd 否 电源管理 手提电脑电源管理
apmiser 否 电源管理 另一手提电脑电池延长器
arpwatch 否 以太网IP地址配对监控器 用主机名监控并记录远程IP地址
atd 否 周期命令调度程序 一个任务调度工具
autofs 否 自动安装服务 几个命令服务文件系统自动安装之一.一些此
类服务专门针对发行配套软件,如果你使用的发行配套软件拥有自己的自动安装系统,不要用这一个.
bluetooth 否 蓝牙技术核心 用于所有蓝牙服务
bootparamd 否 导入服务 以前导入无盘客户端/瘦客户端的方法.最新型的
方法为零配置系统(zeroconf system).
canna 否 日语转换引擎
capi4linux 否 基本CAPI子系统
cpqarrayd 否 硬件服务 康柏独立冗余磁盘阵列(Raid Array)监控器
cpufreq 否 硬件服务 控查并配置CPU频率精灵程序模块
cpufreqd 否 硬件服务 此服务自 动衡量CPU频率来减少过热情况.在超频
时有用.
crond 是 周期命令调度程序 一个任务调度工具
Cups-lpd 否 使旧式Lunux或商业Unix系统连接到打印主机上. 只有在允
许旧式系统访问打印机时才有用
cups 是 公共Unix打印系统 进行打印的必要功能
cvs 否 并发版本系统 用于管理多用户文档
devfsd 否 系统维护 此服务只清除动态桌面目录,除非你的系统经常崩
溃,否则不需要此服务.
dhcpd 否 DHCP服务器 你的网络足够大,使用静态IP很麻烦吗?此项服
务对你的网络进行DHCP IP配置,方便网络应用.
diald 否 拨号网络智能自动拨号器 此服务一经请求,即连接上网络.
你一旦输入电子邮件,点击发送,它就自动连接,发送电邮并断开.
dkms 否 DKMS自安装导入 发行配套软件专用工具,用于OEM类型安装.
它允许管理员密码的最初导入设置以及常规应用的用户名密码,系统的最后配置.
dm 是 显示管理器 X服务器的核心,使用图形用户界面(GUI)时必
需.
dnbc 否 数字网络绑定Chrooter 这是一个简单的bash脚本,它将一
个BIND服务器放入一个chroot牢笼中.安装BIND,发布脚本并重启.
Drakxtools-http 否 小型服务管理服务器 远程系统管理的发行配套软件专用工
具.
dund 否 蓝牙拨号网络
fam 否 文件系统变更监控器 文件系统所有改变的记录器
finger 否 数据远程访问 此服务允许你远程访问用户登录日期,最后登
录日期与时间.用于不在办公室时监控雇员的工作习惯,主要的安全违反,因为你正有效地在线发布公
司机密数据.
freshclam 是 ClamAV更新器 用于自动更新ClamAV</p>
<p>gpm 是 鼠标 鼠标驱动器控制台模式
haldaemon 否 硬件监控系统 此服务监控硬件改变,为你改变新的或更改过
的硬件.
harddrake 否 硬件服务 发行配套软件专用硬件探测与配置
heartbeat 否 高可用性服务 此服务旨在增加重要服务与服务器的优先级
hidd 否 蓝牙H.I.D.服务器
hplip 否 惠普Linux打印与成像 旧版惠普整成产品供应驱动器
hpoj 否 Pital?init,惠普办公喷墨打印机驱动器 惠普办公喷墨打印
机旧式驱动器.新式驱动器包含在打印机的打印驱动器内.
httpd 否 Apache网络服务器 在系统上应用此服务有两个原因,一是
要用它作为网络服务器,二是用它作为网址开发器.如果没有此二项,则不必安装 Apache.
hylafax?server 否 企业传真机?调制调解器服务 此服务仅用于 1 类与 2 类传真
机.如果你想用hylafax通过调制调解器发送传真,必须运行此服务.它并不是唯一有效的传真工具.
ibod 否 按需ISDN MPPP带宽 与拨号网络一同使用,按需连接到网络.
identd 否 TCP连接鉴定
imaps 否 安全IMAP服务器
imaps 否 IMAP服务器
iplog 否 用主机名或远程主机记录TCP,UDP,ICMP. 有用的网络监控
工具
ipop2 否 POP2邮件服务器
ipop3 否 POP3邮件服务器
ipsec 否 加密与验证通信 KLIPS为内核一半,PLUTO为用户空间一半.
在远程访问情况下十分有用.
iptables 是 基于Packet过滤防火墙内核 所有优秀的Linux防火墙都基
于此项服务
ipvsadmin 否 Linux核心IP虚拟服务器 最早的Linux网络系统之一,已不
常用.
irda 否 红外线设备界面 以前的无线设备支持
keytable 是 键盘映射 此服务明确告诉系统你正在使用哪种键盘
kheader 否 导入服务 此服务自动重建内核头导入
lads 否 登录异常探测系统 跟踪登录企图并警告入侵企图的工具
laptop mode 否 电源管理 减少电力耗费,延长手提电脑电池寿命的工具
leafnode 否 X? INETD NNTP服务
lisa 否 局域网信息服务器
lmsensors 否 硬件健康监控器 此服务要求系统主板支持并有合适的监控
系统,如CPU温度与电压监控器.
mailman 否 GUN邮件列表管理器 常用的邮件列表工具,带Python编写的
管理网络界面.它允许列表成员发送邮件并回复邮件到同一个地址进行交流. 它还可用于向那些发送
请求的用户传送新闻时讯/产品更新.
mandi 否 交互式防火墙 允许暂时无线访问系统的专用服务,将为当前
任务开放iptables防火墙,仅用于无线设备访问.在用户许可情况下才可使用,不能自动使用.
mdadm 否 软阵列监控服务 这也是一个用于上述软件阵列栏的管理工
具
mdnsresponder 否 零配置DNS配置工具</p>
<p>messagebus 是 事件监控服务 此服务在必要时向所有用户发送广播信息,如
服务器将要重启.
mon 是 系统监控精灵进程 许多系统服务要求此服务来运行
mysqld 否 MySQL服务器 如果你不需要这个数据库,不要打开它.
named 否 绑定(BIND)服务器 这就是声名狼藉的名称服务器
netplugd 否 网卡精灵进程 此服务监控网络界面,根据信号关闭或启动它,
主要用于不经常连接的手提电脑.
network 是 网络 此服务打开网卡,或为调制调解器供电.
nfs 否 网络文件共享 此服务使用户访问NFS共享文件,为NFS系统
客户机所必需.
nfsfs 否 网络文件共享服务器 只有在网络服务器上才被激活
nfslock 否 NFS文件锁定 只有在使用NFS网络/文件共享功能时,此服务
才被激活.
nifd 否 Howl 客户端 此服务为零配置网络/系统提供ipv4链接本地
服务
nscd 否 密码与群查找服务 此服务用于减慢N.I.S/Y.P.nist,ldap
和hesiod之类的服务.专门为这些服务提供更长的中断时间.
ntpd 否 NTP服务器的第 4 版
numlock 否 数字锁定键灯光控制 此服务保持数字锁定键的激活状态,打
开键盘上的数字键区.
Oki4daemon 否 OKI4和兼容win打印机的兼容性精灵进程 只有在你有这些
打印机时才可用
pand 否 蓝牙个人区域网络 用于基于网络的家庭区域蓝牙技术
partmon 是 分区监控 此服务跟踪安装分区上的剩余空间.大多数文件系
统浏览器使用它来计算指定分区上的剩余空间.
pcmcia 否 个人电脑内存卡国际协会
pg_autovacum 否 PostgreSQL维护 此服务自动运行PostgreSQL所需的空间
(vacuum)来减少磁盘空间,从数据库中拖动临时表格,并删除 PostgreSQL建立的临时文件.
pop3s 否 安全POP3服务 POP3 SSL服务器
portmap 否 RPC支持 支持那些应用rpc的罕有的应用软件
postgresql 否 Postgresql数据库引擎 只有在运行或开发Postgresql数据
库驱动应用软件时才用到此服务
postfix 否 电子邮件服务器 与sendmail兼容的电子邮件服务器,比
sendmail更新,也变得比sendmail更通用.
pptp 否 PPP断电服务 PPP频道断电服务,UPS打开时使用,以避免电
源返回系统时出现文件锁定问题.
prelude 否 IDS 入侵探测系统
psacct 否 进程计算 活动进程追踪器,实际上是资源的浪费.
rawdevices 是 分配raw设备,阻止其使用 DVDS,oracle DBMS等需要此服务
rsync 否 远程同步 使指定目录树上的文件远程同步的服务器,常用于
维护镜象地址,也在备份时用于保持公司文件为最新状态.
saned 否 网络扫描仪 从网络上的任何工作站提供扫描仪访问
shorwall 是 防火墙 一个非常优秀的IPTables防火墙</p>
<p>smartd 否 自我监控服务 用于智能设备的OS访问,此服务允许Linux
告诉你是否设备将要变坏,但这要依靠设备的精确智能特性.
smb 否 Samba网络服务 此服务提供samba服务,实现Windows网络
兼容性.
snmpd 否 简单的网络管理协议 用于小型(家庭办公室)网络
sound 否 声音系统 此为Linux声音系统的核心,适用于桌面系统,在
服务器上则是资源的浪费.
squid 否 高速缓存工具 用于高速缓存网络页面及DNS登录
ssh?xinetd 否 X?inetd OpenSSH服务器 OpenSSH的按需运行版本
sshd 否 OpenSSH服务器 如果你需要SSH访问你的系统时才开启此服
务,将不会使用x?inetd版本.
subversion 否 并发版本系统 CVS的新型替代品
swat 否 Samba网络管理工具 基于Samba管理的网络
syslog 是 系统登录 一项必要的服务,控制整个系统上的所有登录.
tmdns 否 多点传送DNS响应器 用于零配置环境
ultrabayed 否 ThinkPad工具 此服务为你的IBM ThindPad探测ultrabay,
并在适当情况下启动/关闭IDE接口.
upsd 否 NUT精灵进程及驱动器 一个不间断地电源监控及报告工具,
此服务向中心地址报告,产生关于UPS统计的数据库.
upsmon 否 UPS监控工具 此服务监控UPS的状况,在其运行低下时关系
系统.
vncserver 否 虚拟网络计算服务器 在项目中应用VNC时非常有用
Webmin 否 远程管理工具 发行配套软件Agnostic远程管理工具.在机
器不能总是直接访问,如网络服务器集群时有用.
winbind 否 Samba名称服务器 Samba网络运行所必需.此服务将用户与
群数据从windows网络映射到Linux工作站中.
wine 否 Wine并非竞争者 此服务使MS Windows可在Linux上执
行,WINE是商业产品Crossover Office的限制版本.
wlan 否 控制精灵进程 由于服务通常由init进程控制,此控制服务
不常用.
xinetd 是 监控并控制其它服务器的服务器 这是一项必需的服务,它实
际上减少了服务器上CPU的负载.如果你需要SSH,ftp等但并不总是需要,x?inetd版本将在请求,甚
至是远程需求时启 动它们.此服务让它们生效,但如果它们一天/周只使用几次的话,又释放了时钟周
期.
xfs 是 X字体服务器 你任何时间需要使用图形用户界面(GUI),就
需要此服务.
ypbind 否 SUN的YP服务器名称服务器 此服务用于基于GLIBC的
NIS/YP网络服务</p>
<h2 id="_67">十三、 环境管理<a class="headerlink" href="#_67" title="Permanent link">&para;</a></h2>
<h4 id="1_9">1 、环境变量<a class="headerlink" href="#1_9" title="Permanent link">&para;</a></h4>
<p>在linux系统下，如果你下载并安装了应用程序，很有可能在键入它的名称时出现“command not
found”的提示内容。如果每次都到安装目标文件夹内，找到可执行文件来进行操作就太繁琐了。这涉
及到环境变量PATH的设置问题，而PATH的设置也是在linux下定制环境变量的一个组成部分。
环境变量可以让子程序继续引用的原因，是因为：</p>
<ol>
<li>当启动一个 shell ，操作系统分配一记忆区块给 shell 使用，此区域之变量可以让子程序存
取；</li>
<li>利用 export 功能，可以让变量的内容写到上述的记忆区块当中(环境变量)；
当加载另一个 shell 时 (亦即启动子程序，而离开原本的父程序了)，子 shell 3. 可以将父
shell 的环境变量所在的记忆区块导入自己的环境变量区块当中。
所以环境变量是和Shell紧密相关的，用户登录系统后就启动了一个Shell。对于Linux来说一般
是bash，但也可以重新设定或切换到其它的Shell（使用chsh命 令 ）。
根据发行版本的情况，bash有两个基本的系统级配置文件：/etc/bashrc和/etc/profile。这些配
置文件包含两组不同的变量：shell变量和环境变量。前者只是在特定的shell中固定（如bash）， 后
者在不同shell中固定。很明显，shell变量是局部的，而环境变量是全局的。环境变量是通过Shell
命令来设置的，设置好的环境变量又可以被所有当前用户所运行的程序所使用。对于bash这个Shell
程序来说，可以通过变量名来访问相应的环境变量，通过export来设置环境变量。
注：Linux的环境变量名称一般使用大写字母</li>
</ol>
<h4 id="11_linux">1.1 、 Linux 环境变量的种类<a class="headerlink" href="#11_linux" title="Permanent link">&para;</a></h4>
<p>按环境变量的生存周期来划分，Linux的环境变量可分为两类：</p>
<p>○^1 永久的：需要修改配置文件，变量永久生效。^</p>
<p>○^2 临时的：使用export命令行声明即可，变量在关闭shell时失效。^</p>
<h4 id="12">1.2 、设置变量的三种方法<a class="headerlink" href="#12" title="Permanent link">&para;</a></h4>
<p>(^) ○ 1 在/etc/profile文件中添加变量对所有用户生效（永久的）
用VI在文件/etc/profile文件中增加变量，该变量将会对Linux下所有用户有效，并且是“永久
生效”。
例如：编辑/etc/profile文件，添加CLASSPATH变量</p>
<h1 id="vi_etcprofile">vi /etc/profile<a class="headerlink" href="#vi_etcprofile" title="Permanent link">&para;</a></h1>
<p>export CLASSPATH=./JAVA_HOME/lib;$JAVA_HOME/jre/lib
注 1 ：profile文件在系统启动时将被运行。大家可以在里面加入其他命令，但是一定要加正确，不然
的话系统会启动不起来的。
○^2 在用户目录下的.bash_profile文件中增加变量对单一用户生效（永久的）^
用VI在用户目录下的.bash_profile文件中增加变量，改变量仅会对当前用户有效，并且是“永
久的”。
例如：编辑guok用户目录（/home/guok）下的.bash_profile</p>
<h1 id="vi_homeguokbashprofile">vi /home/guok/.bash.profile<a class="headerlink" href="#vi_homeguokbashprofile" title="Permanent link">&para;</a></h1>
<h5 id="_68">添加如下内容：<a class="headerlink" href="#_68" title="Permanent link">&para;</a></h5>
<dl>
<dt>export CLASSPATH=./JAVA_HOME/lib;$JAVA_HOME/jre/lib</dt>
<dt>注 2 ：如果修改了/etc/profile，那么编辑结束后执行source profile 或 执行点命令 ./profile,PATH</dt>
<dt>的值就会立即生效了。这个方法的原理就是再执行一次/etc/profile shell脚本，注意如果用sh</dt>
<dt>/etc/profile是不行的，因为sh是在子shell进程中执行的，即使PATH改变了也不会反应到当前环</dt>
<dt>境中，但是source是在当前 shell进程中执行的，所以我们能看到PATH的改变。</dt>
<dt>注 3 ：变量重复定义时，以后面的设置为先。</dt>
<dt>例如：在peofile文件默认对PATH变量都有设置PATH=￥￥￥￥￥￥￥，在以后可能在对PATH设</dt>
<dt>置，一般都加在profile文件的最后PATH=······（打个比方）。而系统之中认定的</dt>
<dt>PATH=·······￥￥￥￥￥￥￥￥￥，也就是说相同名字的环境变量，后写入的先起作用（通俗地讲）。</dt>
<dt>注 4 、特殊字符介绍。</dt>
<dt>例如在profile中有如下内容，通过以下内容说明特殊符号的用法。</dt>
<dt>export A=/q/jing:aaa/cc/ld</dt>
<dt>export B=.:/liheng/wang export A=/cd/cdr:$A</dt>
<dd>表示并列含义，例如A变量值有多个，用：符号进行分离。</dd>
</dl>
<p>. 表示你操作的当前目录。例如pap命令会查找B环境变量。
在/home键入B命令，系统首先在/home目录下（即当前路径）查找关于 B 的内容，如果没有在
/liheng/wang目录下查找关于B的内容。 $ 表示该变量本次定义之前的值，例如<span class="arithmatex"><span class="MathJax_Preview">A代表
/q/jing:aaa/cc/ld。也就是说 A=/cd/cdr:/q/jing:aaa/cc/ld
注 5 、常见的环境变量
    PATH：决定了shell将到哪些目录中寻找命令或程序
       HOME：当前用户主目录
MAIL：是指当前用户的邮件存放目录。
SHELL：是指当前用户用的是哪种Shell。
HISTSIZE：是指保存历史命令记录的条数。
LOGNAME：是指当前用户的登录名。
HOSTNAME：是指主机的名称，许多应用程序如果要用到主机名的话，通常是从这个环境变量中来取得的。
LANG/LANGUGE：是和语言相关的环境变量，使用多种语言的用户可以修改此环境变量。
PS1：是基本提示符，对于root用户是#，对于普通用户是</span><script type="math/tex">A代表
/q/jing:aaa/cc/ld。也就是说 A=/cd/cdr:/q/jing:aaa/cc/ld
注 5 、常见的环境变量
    PATH：决定了shell将到哪些目录中寻找命令或程序
       HOME：当前用户主目录
MAIL：是指当前用户的邮件存放目录。
SHELL：是指当前用户用的是哪种Shell。
HISTSIZE：是指保存历史命令记录的条数。
LOGNAME：是指当前用户的登录名。
HOSTNAME：是指主机的名称，许多应用程序如果要用到主机名的话，通常是从这个环境变量中来取得的。
LANG/LANGUGE：是和语言相关的环境变量，使用多种语言的用户可以修改此环境变量。
PS1：是基本提示符，对于root用户是#，对于普通用户是</script></span>。
PS2：是附属提示符，默认是“&gt;”。可以通过修改此环境变量来修改当前的命令符，比如下列命令
会将提示符修改成字符串“Hello,My NewPrompt :) ”。</p>
<h1 id="ps1_hellomy_newprompt">PS1=" Hello,My NewPrompt :) "<a class="headerlink" href="#ps1_hellomy_newprompt" title="Permanent link">&para;</a></h1>
<p><div class="highlight"><pre><span></span><code>○^3 直接运行export命令定义变量【只对当前shell（BASH）有效（临时的）】^
</code></pre></div>
在shell的命令行下直接使用[export变量名=变量值]定义变量，该变量只在当前的shell（BASH）或
其子shell（BASH）下是有效的，shell关闭了，变量也就失效了，再打开新shell时就没有这个变量，
需要使用的话还需要重新定义。</p>
<h4 id="13">1.3 、环境变量设置命令<a class="headerlink" href="#13" title="Permanent link">&para;</a></h4>
<p>(^) ○1 echo $ &lt;变量名&gt; //显示 某个环境变量
○2 env // environment (环境 ) 的简写，列出来所有的环境变量^</p>
<p><div class="highlight"><pre><span></span><code>○3 set //显示所有本地定义的 Shell变量，这个命令除了会将环境变量列出来之外，其它我们
</code></pre></div>
的自定义的变量，都会被列出来。因此，想要观察目前 shell 环境下的所有变量，就用 set 即可！</p>
<p><div class="highlight"><pre><span></span><code>○4 export 命令^
功能说明：设置或显示环境变量。
语 法：export [-fnp][变量名称]=[变量设置值]
补充说明：在shell中执行程序时，shell会提供一组环境变量。export可新增，修改或删除环
境变量，供后续执行的程序使用。export的效力仅及于该此登陆操作。
参 数：
-f 代表[变量名称]中为函数名称。
-n 删除指定的变量。变量实际上并未删除，只是不会输出到后续指令的执行环境中。
-p 列出所有的shell赋予程序的环境变量。
一个变量创建时，它不会自动 地为在它之后创建的shell进程所知。而命令export可以向后面
的shell传递变量的值。当一个shell脚本调用并执行时，它不会自动得到原为脚本（调用者）
里定义的变量的访问权，除非这些变量已经被显式地设置为可用。export命令可以用于传递一
个或多个变量的值到任何后继脚本。
</code></pre></div>
(^) ○5 unset清除环境变量，如果未指定值，则该变量值将被设为NULL
(^) ○6 readonly设置只读变量，只读变量设置后不能用unset清除，除非重启shell
(^) ○7 declare 、typeset 这两个命令是完全一样的，他们允许指定变量的具体类型，在某些特定的语言
中,
这是一种指定类型的很弱的形式，declare 命令是在 Bash 版本 2 或之后的版本才被加入的，typeset
命令也可以工作在 ksh 脚本中。
[root@linux ~]# declare [-aixr] variable
参数：
-a ：将后面的 variable 定义成为数组 (array)
-i ：将后面接的 variable 定义成为整数数字 (integer)
-x ：用法与 export 一样，就是将后面的 variable 变成环境变量；
-r ：将一个 variable 的变量设定成为 readonly ，该变量不可被更改内容，也不能 unset
范例一：让变量 sum 进行 100+300+50 的加总结果
[root@linux ~]# sum=100+300+50
[root@linux ~]# echo $sum
100+300+50 &lt;==咦！怎么没有帮我计算加总？因为这是文字型态的变量属性啊！
[root@linux ~]# declare -i sum=100+300+50
[root@linux ~]# echo $sum
450
范例二：将 sum 变成环境变量
[root@linux ~]# declare -x sum
范例三：让 sum 变成只读属性，不可更动！
[root@linux ~]# declare -r sum
[root@linux ~]# sum=tesgting</p>
<p>-bash: sum: readonly variable</p>
<h2 id="_69">十四、 网络管理<a class="headerlink" href="#_69" title="Permanent link">&para;</a></h2>
<p>网卡在Linux操作系统中用 ethX,是由 0 开始的正整数，比如eth0、eth1...... ethX。而普通猫和
ADSL的接口是 pppX，比如ppp0等</p>
<h4 id="71_ifconfig">7.1 、 ifconfig<a class="headerlink" href="#71_ifconfig" title="Permanent link">&para;</a></h4>
<h5 id="1_10">1 、 关于网络接口及配置工具说明；<a class="headerlink" href="#1_10" title="Permanent link">&para;</a></h5>
<p><div class="highlight"><pre><span></span><code>在Linux操作系统中配置网络接口，一般是通过网络配置工具实现的，但最终目的还是通过网络配
</code></pre></div>
置工具来达到修改与网络相关的配置文件而起作用的。由此说来，我们配置网络可以直接修改配置文件。</p>
<p><div class="highlight"><pre><span></span><code>比如网络网络接口（网卡）的IP地址、子掩码、网关，在Slackware 中只需修改一个配置文件就
</code></pre></div>
行了 /etc/rc.d/rc.inet1 ，而在 Redhat/Fedora 等或以Redhat/Fedora 为基础的发行版中，一般要</p>
<p>涉及到好几个文件，比如包括 /etc/sysconfig/network-scripts/ifcfg-eth0在内等。</p>
<p><div class="highlight"><pre><span></span><code>了解Linux网络配置文件是极为重要的，我们通过工具修改了什么，是怎么生效的，只有了解网络
</code></pre></div>
配置文件才能搞清楚。做个不恰当的比喻：Linux 系统是一个透明的盒子，至于盒子里装的是什么都是</p>
<p>一目了然的。而闭源操作系统，我们没有机会知道这些，更不知道他是怎么实现的。</p>
<p><div class="highlight"><pre><span></span><code>对于复杂的网络模型，Linux操作系统是有极大的优势，可能在我们看看man 和help，修改修改
</code></pre></div>
配置文件，在几分钟就可以搞定。但闭源图形界面的操作系统就没有这么幸运了，反复的点鼠标.</p>
<p><div class="highlight"><pre><span></span><code>点了几十次上百次也解决不了一个问题，这是极为常见的。 由于Linux操作系统存在很多的发行
</code></pre></div>
和版本，大多发行版本都有自己的专用配置工具。主要是为了方便用户配置网络；但也有通用的配置工</p>
<p>具，比如 Linux ifconfig 、ifup、ifdown；</p>
<p><div class="highlight"><pre><span></span><code>2 关于网络硬件设备的驱动；
</code></pre></div>
<div class="highlight"><pre><span></span><code>我在以前的文档中有写过，网络硬件，比如网卡（包括有线、无线），猫包括普通猫和ADSL猫等，
</code></pre></div>
都是需要内核支持的，所以我们首先得知道自己的网络设备是不是已经被硬内核支持了。如果不支持，</p>
<p>我们得找驱动（或通过内核编译）来支持它； 请参考：</p>
<p><div class="highlight"><pre><span></span><code>3 、Linux ifconfig 配置网络接口的工具介绍；
</code></pre></div>
<div class="highlight"><pre><span></span><code>Linux ifconfig 是一个用来查看、配置、启用或禁用网络接口的工具，这个工具极为常用的。比
</code></pre></div>
如我们可以用这个工具来临时性的配置网卡的IP地址、掩码、广播地址、网关等。也可以把它写入一</p>
<p>个文件中（比如/etc/rc.d/rc.local)，这样系统引导后，会读取这个文件，为网卡设置IP地址；</p>
<p><div class="highlight"><pre><span></span><code>不过这样做目前看来没有太大的必要。主要是各个发行版本都有自己的配置工具，无论如何也能把
</code></pre></div>
主机加入到网络中； 下面我们看看Linux ifconfig 用法；</p>
<p><div class="highlight"><pre><span></span><code>3.1 Linux ifconfig 查看网络接口状态；
</code></pre></div>
<div class="highlight"><pre><span></span><code>Linux ifconfig 如果不接任何参数，就会输出当前网络接口的情况；
</code></pre></div>
1. [root@localhost ~]# Linux ifconfig
2. eth0 Link encap:Ethernet HWaddr 00:C0:9F:94:78:0E
3. inet addr:192.168.1.88 Bcast:192.168.1.255 Mask:255.255.255.0
4. inet6 addr: fe80::2c0:9fff:fe94:780e/64 Scope:Link
5. UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1
6. RX packets:850 errors:0 dropped:0 overruns:0 frame:0
7. TX packets:628 errors:0 dropped:0 overruns:0 carrier:0
8. collisions:0 txqueuelen:1000
9. RX bytes:369135 (360.4 KiB) TX bytes:75945 (74.1 KiB)
10. Interrupt:10 Base address:0x3000</p>
<p>11.</p>
<ol>
<li>lo Link encap:Local Loopback</li>
<li>inet addr:127.0.0.1 Mask:255.0.0.0</li>
<li>inet6 addr: ::1/128 Scope:Host</li>
<li>UP LOOPBACK RUNNING MTU:16436 Metric:1</li>
<li>RX packets:57 errors:0 dropped:0 overruns:0 frame:0</li>
<li>TX packets:57 errors:0 dropped:0 overruns:0 carrier:0</li>
<li>collisions:0 txqueuelen:0</li>
<li>RX bytes:8121 (7.9 KiB) TX bytes:8121 (7.9 KiB)</li>
</ol>
<p><div class="highlight"><pre><span></span><code>解说：eth0 表示第一块网卡， 其中 HWaddr 表示网卡的物理地址，我们可以看到目前这个网卡的
</code></pre></div>
物理地址(MAC地址）是 00:C0:9F:94:78:0E ； inet addr 用来表示网卡的IP地址，此网卡的 IP地</p>
<p>址是 192.168.1.88， 广播地址， Bcast:192.168.1.255，掩码地址Mask:255.255.255.0</p>
<p><div class="highlight"><pre><span></span><code>lo 是表示主机的回坏地址，这个一般是用来测试一个网络程序，但又不想让局域网或外网的用户
</code></pre></div>
能够查看，只能在此台主机上运行和查看所用的网络接口。比如我们把HTTPD服务器的指定到回坏地址，</p>
<p>在浏览器输入 127.0.0.1 就能看到你所架WEB网站了。但只是您能看得到，局域网的其它主机或用户</p>
<p>无从知道；</p>
<p><div class="highlight"><pre><span></span><code>如果我们想知道主机所有网络接口的情况，请用下面的命令； [root@localhost ~]# Linux
</code></pre></div>
ifconfig -a 如果我们想查看某个端口，比如我们想查看eth0 的状态，就可以用下面的方法；</p>
<p>[root@localhost ~]# Linux ifconfig eth0</p>
<p><div class="highlight"><pre><span></span><code>3.2 Linux ifconfig 配置网络接口；
</code></pre></div>
<div class="highlight"><pre><span></span><code>Linux ifconfig 可以用来配置网络接口的IP地址、掩码、网关、物理地址等；值得一说的是用
</code></pre></div>
Linux ifconfig 为网卡指定IP地址，这只是用来调试网络用的，并不会更改系统关于网卡的配置文件。</p>
<h5 id="ip">如果您想把网络接口的IP地址固定下来，目前有三个方法：一是通过各个发行和版本专用的工具<a class="headerlink" href="#ip" title="Permanent link">&para;</a></h5>
<p>来修改IP地址；二是直接修改网络接口的配置文件；三是修改特定的文件，加入Linux ifconfig 指</p>
<p>令来指定网卡的IP地址，比如在redhat或Fedora中，把Linux ifconfig 的语名写入</p>
<p>/etc/rc.d/rc.local文件中；</p>
<p><div class="highlight"><pre><span></span><code>Linux ifconfig 配置网络端口的方法： Linux ifconfig 工具配置网络接口的方法是通过指令的
</code></pre></div>
参数来达到目的的，我们只说最常用的参数； Linux ifconfig 网络端口 IP地址 hw <HW> MAC</p>
<p>地址 netmask 掩码地址 broadcast 广播地址 [up/down]</p>
<p><div class="highlight"><pre><span></span><code>实例一：
</code></pre></div>
<div class="highlight"><pre><span></span><code>比如我们用Linux ifconfig 来调试 eth0网卡的地址
</code></pre></div>
1. [root@localhost ~]# Linux ifconfig eth0 down
2. [root@localhost ~]# Linux ifconfig eth0 192.168.1.99 broadcast 192.168.1.255 netma</p>
<p><div class="highlight"><pre><span></span><code>sk 255.255.255.0
</code></pre></div>
3. [root@localhost ~]# Linux ifconfig eth0 up
4. [root@localhost ~]# Linux ifconfig eth0
5. eth0 Link encap:Ethernet HWaddr 00:11:00:00:11:11
6. inet addr:192.168.1.99 Bcast:192.168.1.255 Mask:255.255.255.0
7. UP BROADCAST MULTICAST MTU:1500 Metric:1
8. RX packets:0 errors:0 dropped:0 overruns:0 frame:0
9. TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
10. collisions:0 txqueuelen:1000
11. RX bytes:0 (0.0 b) TX bytes:0 (0.0 b)
12. Interrupt:11 Base address:0x3400</p>
<p><div class="highlight"><pre><span></span><code>注解： 上面的例子我们解说一下；
</code></pre></div>
<div class="highlight"><pre><span></span><code>第一行：Linux ifconfig eth0 down 表示如果eth0是激活的，就把它DOWN掉。此命令等同于 ifdown
</code></pre></div>
eth0；</p>
<p><div class="highlight"><pre><span></span><code>第二行：用Linux ifconfig 来配置 eth0的IP地址、广播地址和网络掩码；
</code></pre></div>
<div class="highlight"><pre><span></span><code>第三行：用Linux ifconfig eth0 up 来激活eth0 ； 此命令等同于 ifup eth0
</code></pre></div>
<div class="highlight"><pre><span></span><code>第四行：用 Linux ifconfig eth0 来查看 eth0的状态；
</code></pre></div>
<div class="highlight"><pre><span></span><code>当然您也可以用直接在指令IP地址、网络掩码、广播地址的同时，激活网卡；要加up参数；比如
</code></pre></div>
下面的例子； [root@localhost ~]# Linux ifconfig eth0 192.168.1.99 broadcast</p>
<p>192.168.1.255 netmask 255.255.255.0 up</p>
<h5 id="ipmac">实例二：在这个例子中，我们要学会设置网络IP地址的同时，学会设置网卡的物理地址（MAC地<a class="headerlink" href="#ipmac" title="Permanent link">&para;</a></h5>
<h5 id="_70">址）；<a class="headerlink" href="#_70" title="Permanent link">&para;</a></h5>
<p><div class="highlight"><pre><span></span><code>比如我们设置网卡eth1的IP地址、网络掩码、广播地址，物理地址并且激活它； [root@localhost
</code></pre></div>
~]# Linux ifconfig eth1 192.168.1.252 hw ether 00:11:00:00:11:11 netmask 255.255.255.0</p>
<p>broadcast 192.168.1.255 up或[root@localhost ~]# Linux ifconfig eth1 hw</p>
<p>ether 00:11:00:00:11:22[root@localhost ~]# Linux ifconfig eth1 192.168.1.252 netmask</p>
<p>255.255.255.0 broadcast 192.168.1.255 up</p>
<p><div class="highlight"><pre><span></span><code>其中 hw 后面所接的是网络接口类型， ether表示乙太网， 同时也支持 ax25 、ARCnet、netrom
</code></pre></div>
等，详情请查看 man Linux ifconfig ；</p>
<p><div class="highlight"><pre><span></span><code>3.3 如何用Linux ifconfig 来配置虚拟网络接口；
</code></pre></div>
<div class="highlight"><pre><span></span><code>有时我们为了满足不同的需要还需要配置虚拟网络接口，比如我们用不同的IP地址来架 运行多个
</code></pre></div>
HTTPD服务器，就要用到虚拟地址；这样就省却了同一个IP地址，如果开设两个的HTTPD服务器时，</p>
<p>要指定端口号。</p>
<p><div class="highlight"><pre><span></span><code>虚拟网络接口指的是为一个网络接口指定多个IP地址，虚拟接口是这样的 eth0:0 、 eth0:1、
</code></pre></div>
eth0:2 ... .. eth1N。当然您为eth1 指定多个IP地址，也就是 eth1:0、eth1:1、eth1:2 ... ...</p>
<p>以此类推；</p>
<p><div class="highlight"><pre><span></span><code>其实用Linux ifconfig 为一个网卡配置多个IP地址，就用前面我们所说的Linux ifconfig的用
</code></pre></div>
法，这个比较简单；看下面的例子； [root@localhost ~]# Linux ifconfig eth1:0 192.168.1.251 hw</p>
<p>ether 00:11:00:00:11:33 netmask 255.255.255.0 broadcast 192.168.1.255 up或</p>
<p>[root@localhost ~]# Linux ifconfig eth1 hw ether 00:11:00:00:11:33[root@localhost ~]#</p>
<p>Linux ifconfig eth1 192.168.1.251 netmask 255.255.255.0 broadcast 192.168.1.255 up</p>
<p><div class="highlight"><pre><span></span><code>注意：指定时，要为每个虚拟网卡指定不同的物理地址；
</code></pre></div>
<div class="highlight"><pre><span></span><code>在 Redhat/Fedora 或与Redhat/Fedora类似的系统，您可以把配置网络IP地址、广播地址、掩码
</code></pre></div>
地址、物理地址以及激活网络接口同时放在一个句子中，写入/etc/rc.d/rc.local中。比如下面的例</p>
<p>子；</p>
<p><div class="highlight"><pre><span></span><code>Linux ifconfig eth1:0 192.168.1.250 hw ether 00: 11:00:00:11:44 netmask 255.255.255.0
</code></pre></div>
broadcast 192.168.1.255 up</p>
<p><div class="highlight"><pre><span></span><code>Linux ifconfig eth1:1 192.168.1.249 hw ether 00:11:00:00:11:55 netmask 255.255.255.0
</code></pre></div>
broadcast 192.168.1.255 up</p>
<p><div class="highlight"><pre><span></span><code>解说：上面是为eth1的网络接口，设置了两个虚拟接口；每个接口都有自己的物理地址、IP地
</code></pre></div>
址... ...</p>
<p><div class="highlight"><pre><span></span><code>3.4 如何用Linux ifconfig 来激活和终止网络接口的连接；
</code></pre></div>
<div class="highlight"><pre><span></span><code>激活和终止网络接口的用 Linux ifconfig 命令，后面接网络接口，然后加上 down或up参数，
</code></pre></div>
就可以禁止或激活相应的网络接口了。当然也可以用专用工具ifup和ifdown 工具；</p>
<ol>
<li>[root@localhost ~]# Linux ifconfig eth0 down</li>
<li>[root@localhost ~]# Linux ifconfig eth0 up</li>
<li>[root@localhost ~]# ifup eth0</li>
<li>[root@localhost ~]# ifdown eth0</li>
</ol>
<p><div class="highlight"><pre><span></span><code>对于激活其它类型的网络接口也是如此，比如 ppp0，wlan0等；不过只是对指定IP的网卡有效。
</code></pre></div>
注意：对DHCP自动分配的IP，还得由各个发行版自带的网络工具来激活；当然得安装dhcp客户端；</p>
<p>这个您我们应该明白；比如Redhat/Fedora [root@localhost ~]# /etc/init.d/network start</p>
<p>Slackware 发行版； [root@localhost ~]# /etc/rc.d/rc.inet1</p>
<p><div class="highlight"><pre><span></span><code>4 、Debian、Slackware、Redhat/Fedora、SuSE等发行版专用网络接口配置工具；
</code></pre></div>
<div class="highlight"><pre><span></span><code>由于 Linux ifconfig 用起来比较麻烦，而且是用来测试网络之用，但这个工具并不能修改网络接
</code></pre></div>
口的相应配置文件。虽然也能通过把Linux ifconfig配置网络接口的语句写入类似/etc/rc.d/rc.local</p>
<p>文件中，但相对来说还是写入关于网络接口的配置文件中更为安全和可靠；但对于虚拟网络接口写入类</p>
<p>似/etc/rc.d/rc.local 中还是可以的；</p>
<p><div class="highlight"><pre><span></span><code>下面我们介绍一下各个发行版的网络接口配置工具；
</code></pre></div>
<div class="highlight"><pre><span></span><code>4.1 Debian 网络接口配置文件和专用配置工具；
</code></pre></div>
<div class="highlight"><pre><span></span><code>正在增加中；
</code></pre></div>
<div class="highlight"><pre><span></span><code>4.2 Redhat/Fedora 网络接口的配置文件和网络接口专用配置工具；
</code></pre></div>
<div class="highlight"><pre><span></span><code>在Redhat/Fedora 中，与乙太网卡相关的配置文件位于 /etc/sysconfig/network-scripts目录中，
</code></pre></div>
比如 ifcfg-eth0、ifcfg-eth1 .... ....</p>
<p><div class="highlight"><pre><span></span><code>4.21 Redhat/Fedora 或类似这样的系统，网卡的配置文件；
</code></pre></div>
<div class="highlight"><pre><span></span><code>&lt;/FONT?&lt; p&gt;
</code></pre></div>
<div class="highlight"><pre><span></span><code>比如在Fedora 5.0中，ifcfg-eth 0 ； 如果您用DHCP服务器来自动获取IP的，一般情况下
</code></pre></div>
ifcfg-eth0的内容是类似下面这样的；</p>
<ol>
<li>DEVICE=eth0</li>
<li>ONBOOT=yes</li>
<li>BOOTPROTO=dhcp</li>
<li>TYPE=Ethernet</li>
</ol>
<h5 id="ip_1">如果您是指定IP的，一般内容是类似下面的；<a class="headerlink" href="#ip_1" title="Permanent link">&para;</a></h5>
<ol>
<li>DEVICE=eth0 注：网络接口</li>
<li>ONBOOT=yes 注：开机引导时激活</li>
<li>BOOTPROTO=static 注：采用静态IP地址；</li>
<li>IPADDR=192 .168.1.238 注：IP地址</li>
<li>NETMASK=255.255.255.0 注：网络掩码；</li>
<li>GATEWAY=192.168.1.1 注：网关；</li>
</ol>
<p><div class="highlight"><pre><span></span><code>下面的几个选项也可以利用；
</code></pre></div>
1. HOSTNAME=linxsir03 注：指定主机名；
2. DOMAIN=localdomain 注：指定域名；
3. HWADDR=00:00:11:22:00:aa 注：</p>
<p><div class="highlight"><pre><span></span><code>指定网卡硬件地址 (MAC地址）， 也可以省略，不过这在这里来更改MAC地址一般是不能生效的。
</code></pre></div>
还是通过前面所说的Linux ifconfig的办法来更改吧；</p>
<p><div class="highlight"><pre><span></span><code>4.22 Redhat/Fedora 或类似系统， 配置网络的工具介绍 ；
</code></pre></div>
<div class="highlight"><pre><span></span><code>在Redhat早期的版本中， 有linuxconf 、redhat-config-network 、netconfig 等工具； 在
</code></pre></div>
Redhat/Fedora 最新的版本有 system-config-network-tui （文本模式的) 、system-config-network</p>
<p>（图形模式的），netconfig（文本模式的）。</p>
<p><div class="highlight"><pre><span></span><code>这些工具都会直接修改Linux系统中关于网络接口的配置文件；这是 Linux ifconfig 所不能比的；
</code></pre></div>
其中 redhat-config-network 和system-config-network工具不仅仅是配置网卡的工具，还有配置</p>
<p>ISDN和普通猫、ADSL的工具、网络硬件的添加、主机名字的配置、DNS各客户端的配置等。其实是一</p>
<p>个工具组的集成；</p>
<p><div class="highlight"><pre><span></span><code>这些工具比较简单，以root权限运行命令就能调用，比如：
</code></pre></div>
1. [root@localhost ~]# /usr/sbin/system-config-network
2. [root@localhost ~]# system-config-network</p>
<p><div class="highlight"><pre><span></span><code>如果您设置了可执行命令的环境变量，不用加路径就可以运行，但前提是您得安装这个网络管理工
</code></pre></div>
具； 不过值得一说的是netconfig 工具是一个在文本模式比较好的工具，推荐大家使用；理由是这个</p>
<p>工具在文本模式下，也有一个简单的图形界面；还有命令模式；功能强着呢；</p>
<ol>
<li>[root@localhost ~]# netconfig -d eth0 注：配置eth0</li>
<li>[root@localhost ~]# netconfig -d eth1 注：配置eth1</li>
</ol>
<div class="highlight"><pre><span></span><code>4.23 Redhat/Fedora系统中的netconfig 特别介绍；
</code></pre></div>
<p><div class="highlight"><pre><span></span><code>netconfig这个工具，在Redhat/Fedora 或类似于它们的系统中都是存在的，这个工具比较强大。
</code></pre></div>
所以特别介绍一下。但在Slackware中netconfig是TEXT模式下有一个图形模式，但不能象Linux</p>
<p>ifconfig一样用命令来操作网卡接口；</p>
<p><div class="highlight"><pre><span></span><code>netconfig 的用法如下：
</code></pre></div>
1. [root@localhost ~]# netconfig --help 注：帮助；
2. --bootproto=(dhcp|bootp|none) Boot protocol to use（
3. --gateway=STRING Network gateway（指定网关）
4. --ip=STRING IP address（指定IP地址）
5. --nameserver=STRING Nameserver（指定DNS客户端）
6. --netmask=STRING Netmask（指定网络掩码）
7. --hostname=STRING Hostname（ 指定主机名）
8. --domain=STRING Domain name（指定域名）
9. -d, --device=STRING Network device （指定网络设备）
10. --nodns No DNS lookups （没有DNS查询）
11. --hwaddr=STRING Ethernet hardware address （指定网卡的物理地址）
12. --description=STRING Description of the device （描述性文字）
13. Help options: (帮助选项）
14. -?, --help Show this help message
15. --usage Display brief usage message</p>
<p><div class="highlight"><pre><span></span><code>实例一：设置网卡的DHCP模式自动获得IP [root@localhost ~]# netconfig -d eth0
</code></pre></div>
--bootproto=dhcp</p>
<p><div class="highlight"><pre><span></span><code>实例一：手动设置网卡的IP等 [root@localhost ~]# netconfig -d eth0 --ip=192.168.1.33
</code></pre></div>
--netmask=255.255.255.0 --gateway=192.168.1.1</p>
<p><div class="highlight"><pre><span></span><code>4.3 Slackware网卡配置文件和配置工具；
</code></pre></div>
<div class="highlight"><pre><span></span><code>Slackware 有关网卡的配置文件是/etc/rc.d/rc.inet1.conf ， 这个文件包括乙太网接口的网卡
</code></pre></div>
和无线网卡的配置。Slackware 还是比较纯净的，网络配置也较简单；在Slackware中也有netconfig</p>
<p>配置工具，也是text模式运行的，人机交互界面，这个设置比较简单；</p>
<p><div class="highlight"><pre><span></span><code>Slackware 用netconfig 配置网卡完成后，其实质是修改了/etc/rc.d/rc.inet1.conf 文件。
</code></pre></div>
Slackware是源法原味的Linux系统，他的配置文件比较标准 ，所以我推荐您在生产型的系统，不妨</p>
<p>尝试一下Slackware ；</p>
<p><div class="highlight"><pre><span></span><code>配置好网卡后，我们还得运行下面的命令，才能激活网卡； [root@localhost ~]#
</code></pre></div>
/etc/rc.d/rc.inet1 下面是一个例子，比如此机器有两个网卡eth0和eth1，eth0用DHCP获得IP地</p>
<p>址，eth1指定IP地址；</p>
<ol>
<li>
<h1 id="config_information_for_eth0">Config information for eth0:<a class="headerlink" href="#config_information_for_eth0" title="Permanent link">&para;</a></h1>
</li>
<li>IPADDR[0]=""</li>
<li>NETMASK[0]=""</li>
<li>USE_DHCP[0]="yes" 注：在这里写上yes，表示用DHCP获得IP；</li>
<li>DHCP_HOSTNAME[0]="linuxsir01" 注：DNS服务器主机名，也可以用IP来指定DNS服务器；</li>
<li>
<h1 id="config_information_for_eth1_eth1">Config information for eth1: 注：网卡eth1的配置；<a class="headerlink" href="#config_information_for_eth1_eth1" title="Permanent link">&para;</a></h1>
</li>
<li>IPADDR[1]="192.168.1.33" 注：指定IP地址；</li>
<li>NETMASK[1]="255.255.255.0" 注：指定掩码；</li>
<li>USE_DHCP[1]="no" 注：不用DHCP获得IP；</li>
<li>DHCP_HOSTNAME[1]=""</li>
<li>
<h1 id="config_information_for_eth2">Config information for eth2:<a class="headerlink" href="#config_information_for_eth2" title="Permanent link">&para;</a></h1>
</li>
<li>IPADDR[2]=""</li>
<li>NETMASK[2]=""</li>
<li>USE_DHCP[2]=""</li>
<li>DHCP_HOSTNAME[2]=""</li>
<li>
<h1 id="config_information_for_eth3">Config information for eth3:<a class="headerlink" href="#config_information_for_eth3" title="Permanent link">&para;</a></h1>
</li>
<li>IPADDR[3]=""</li>
<li>NETMASK[3]=""</li>
<li>USE_DHCP[3]=""</li>
<li>DHCP_HOSTNAME[3]=""</li>
<li>
<h1 id="default_gateway_ip_address">Default gateway IP address:<a class="headerlink" href="#default_gateway_ip_address" title="Permanent link">&para;</a></h1>
</li>
<li>GATEWAY="192.168.1.1" 注：指定网关；</li>
</ol>
<p><div class="highlight"><pre><span></span><code>4.4 SuSE或OpenSuSE网卡配置文件和配置工具；
</code></pre></div>
<div class="highlight"><pre><span></span><code>正在更新之中；
</code></pre></div>
<div class="highlight"><pre><span></span><code>5 、关于拔号工具的介绍；
</code></pre></div>
<div class="highlight"><pre><span></span><code>有的弟兄可能需要ADSL猫和普通猫的拔号工具；现在我们分别介绍一下；
</code></pre></div>
<div class="highlight"><pre><span></span><code>5.1 ADSL pppoe 拔号工具rp-pppoe；
</code></pre></div>
<div class="highlight"><pre><span></span><code>如果您的ADSL不是路由的，如果是路由的，在路由路就能设置好自动拔号。只要把机器接上就能
</code></pre></div>
用了，这个咱们不说了，路由器大家都会用；但如果您的ADSL不支持路由，或您想用您当前所用的主</p>
<p>机来做路由器；这就需要一个拔号软件；</p>
<p><div class="highlight"><pre><span></span><code>目前国内大多城市都用的是pppoe协议 ，所以我们有必要介绍 pppoe 拔号软件，在Linux中，这
</code></pre></div>
个软件的名字是 rp- pppoe ； rp-pppoe 主页；</p>
<p><a href="http://www.roaringpenguin.com/penguin/open_source_rp-pppoe.php">http://www.roaringpenguin.com/penguin/open_source_rp-pppoe.php</a></p>
<div class="highlight"><pre><span></span><code>5.11 各大发行版自带的 rp-pppoe 的安装和使用；
</code></pre></div>
<p><div class="highlight"><pre><span></span><code>rp-pppoe 目前在各大发行版本都是存在的，比如Redhat/Fedora、红旗、Slackware、Debian、SuSE
</code></pre></div>
等系统，都是采用这个拔号软件，所以您大可不必为下载源码编译安装。只需要在各大发行版的安装盘</p>
<p>中就可以找得到；请用各大发行版自带的软件包管理工具来安装此软件包；</p>
<p><div class="highlight"><pre><span></span><code>如果您用的是各大发行版提供的rp- pppoe软件包 比如 RPM包的系统是用 rpm -ivh
</code></pre></div>
rp-pppoe*.rpmSlackware 系统是用 installpkg rp-pppoe*.tgz 在Redhat/Fedora 中可以通过图形配</p>
<p>置工具来完成，redhat-config-network 命令，调用配置网络，要通过XDSL来添加拔号，比较简单；</p>
<p><div class="highlight"><pre><span></span><code>所有发行版通用的方法是adsl-setup 命令来配置ADSL；
</code></pre></div>
1. [root@localhost ~]# adsl-setup 注：配置pppoe拔号，请文档下面，都差不多；
2. [root@localhost ~]# adsl-start 注：启动拔号；
3. [root@localhost ~]# adsl-stop 注：断开连接；</p>
<p><div class="highlight"><pre><span></span><code>5.12 如果是源码包安装，我们要自己来编译安装；
</code></pre></div>
<div class="highlight"><pre><span></span><code>[root@localhost ~]# tar zxvf rp- pppoe-3.8.tar.gz
</code></pre></div>
<div class="highlight"><pre><span></span><code>[root@localhost ~]# cd rp-pppoe-3.8
</code></pre></div>
<div class="highlight"><pre><span></span><code>[root@localhost rp-pppoe-3.8]# ./go
</code></pre></div>
<div class="highlight"><pre><span></span><code>Welcome to the Roaring Penguin PPPoE client setup. First, I will run
</code></pre></div>
<div class="highlight"><pre><span></span><code>some checks on your system to make sure the PPPoE client is installed
</code></pre></div>
<div class="highlight"><pre><span></span><code>properly...
</code></pre></div>
<div class="highlight"><pre><span></span><code>Looks good! Now, please enter some information:
</code></pre></div>
<div class="highlight"><pre><span></span><code>USER NAME
</code></pre></div>
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; Enter your PPPoE user name (default bxxxnxnx@sympatico.ca): 在这里添写你的拔号用户
</code></pre></div>
名；就是服务商提供的；</p>
<p><div class="highlight"><pre><span></span><code>&gt;&gt;&gt; Enter the Ethernet interface connected to the DSL modem
</code></pre></div>
<div class="highlight"><pre><span></span><code>For Solaris, this is likely to be something like /dev/hme0.
</code></pre></div>
<div class="highlight"><pre><span></span><code>For Linux, it will be ethn, where &#39;n&#39; is a number.
</code></pre></div>
<div class="highlight"><pre><span></span><code>(default eth0): eth0 如果是乙太接口的ADSL，就要在这里写上接猫的那个网络接口号。此处是
</code></pre></div>
eth0；</p>
<p><div class="highlight"><pre><span></span><code>Do you want the link to come up on demand, or stay up continuously?
</code></pre></div>
<div class="highlight"><pre><span></span><code>If you want it to come up on demand, enter the idle time in seconds
</code></pre></div></p>
<p><div class="highlight"><pre><span></span><code>after which the link should be dropped. If you want the link to
</code></pre></div>
<div class="highlight"><pre><span></span><code>stay up permanently, enter &#39;no&#39; (two letters, lower-case.)
</code></pre></div>
<div class="highlight"><pre><span></span><code>NOTE: Demand-activated links do not interact well with dynamic IP
</code></pre></div>
<div class="highlight"><pre><span></span><code>addresses. You may have some problems with demand-activated links.
</code></pre></div>
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; Enter the demand value (default no): 注：默认回车
</code></pre></div>
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; Enter the DNS information here: 202.96.134.133 注：在这里写上DNS服务器地址；可以
</code></pre></div>
和提供商要，也可以用我写的这个；</p>
<p><div class="highlight"><pre><span></span><code>Please enter the IP address of your ISP&#39;s secondary DNS server.
</code></pre></div>
<div class="highlight"><pre><span></span><code>If you just press enter, I will assume there is only one DNS server.
</code></pre></div>
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; Enter the secondary DNS server address here: 202.96.128.143 这是第二个DNS服务器地
</code></pre></div>
址；</p>
<p><div class="highlight"><pre><span></span><code>&gt;&gt;&gt; Please enter your PPPoE password:在这里输入用户的密码；
</code></pre></div>
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; Please re-enter your PPPoE password: 确认密码；
</code></pre></div>
<div class="highlight"><pre><span></span><code>The firewall choices are:
</code></pre></div>
<div class="highlight"><pre><span></span><code>0 - NONE: This script will not set any firewall rules. You are responsible
</code></pre></div>
<div class="highlight"><pre><span></span><code>for ensuring the security of your machine. You are STRONGLY
</code></pre></div>
<div class="highlight"><pre><span></span><code>recommended to use some kind of firewall rules.
</code></pre></div>
<div class="highlight"><pre><span></span><code>1 - STANDALONE: Appropriate for a basic stand-alone web-surfing workstation
</code></pre></div>
<div class="highlight"><pre><span></span><code>2 - MASQUERADE: Appropriate for a machine acting as an Internet gateway
</code></pre></div>
<div class="highlight"><pre><span></span><code>for a LAN
</code></pre></div>
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; Choose a type of firewall (0-2): 2 注：在这里写上 2 ，可以共享上网的；当然还得加一
</code></pre></div>
条防火墙规划 ；</p>
<p><div class="highlight"><pre><span></span><code>Ethernet Interface: eth0
</code></pre></div>
<div class="highlight"><pre><span></span><code>User name:dxxx
</code></pre></div>
<div class="highlight"><pre><span></span><code>Activate-on-demand: No
</code></pre></div>
<div class="highlight"><pre><span></span><code>Primary DNS: 202.96.134.133
</code></pre></div></p>
<p><div class="highlight"><pre><span></span><code>Secondary DNS: 202.96.128.143
</code></pre></div>
<div class="highlight"><pre><span></span><code>Firewalling: MASQUERADE
</code></pre></div>
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; Accept these settings and adjust configuration files (y/n)? y 注：是不是保存配置；
</code></pre></div>
<div class="highlight"><pre><span></span><code>关于共享上网，请参考：《ADSL共享上网的解决办法》
</code></pre></div>
<div class="highlight"><pre><span></span><code>5.2 普通猫的拔号工具介绍；
</code></pre></div>
<div class="highlight"><pre><span></span><code>普通猫分为串口和PCI的，请查看 《关于网络设备概述 》 普通猫的拔号工具主要有kppp和wvdial；
</code></pre></div>
在Redhat/Fedora中，用system-config-network 或redhat-config-network 也能设置ppp拔号； 在</p>
<p>KDE桌面环境下，大家一般都用kppp拔号工具，点鼠标就可以完成；</p>
<p><div class="highlight"><pre><span></span><code>wvdial工具是文本的，几乎在各大发行版都有。wvdial的配置文件是/etc/wvdial.conf 。如果您
</code></pre></div>
的猫已经驱动好了，运行一下wvdialconf命令就生成了/etc/wvdial.conf了 。当然您得查看一下它</p>
<p>的内容；</p>
<ol>
<li>[root@localhost ~]# wvdialconf</li>
<li>[root@localhost ~]# more /etc/wvdial.conf</li>
</ol>
<p><div class="highlight"><pre><span></span><code>关于wvdial工具的使用，请查看《普通 56K猫拔号上网工具 wvdial 介绍》
</code></pre></div>
<div class="highlight"><pre><span></span><code>6 、无线网卡；
</code></pre></div>
<div class="highlight"><pre><span></span><code>正在更新之中；由于我没有这样的网卡，是否有弟兄写一篇详尽一点的？在所有涉及无线网卡的文
</code></pre></div>
档中，这块都是空白。缺的就是这个。 看来我是得弄一块无线网卡了。。。。。。</p>
<p><div class="highlight"><pre><span></span><code>7 、DNS客户端配置文件/etc/resolv.conf；
</code></pre></div>
<div class="highlight"><pre><span></span><code>本来不应该把DNS客户端配置文件放在这里来说，但由于新手弟兄上网时，虽然能拔号，但不能以
</code></pre></div>
域名访问。究其原因是由于没有修改 /etc/resolv.conf 文件；</p>
<p><div class="highlight"><pre><span></span><code>/etc/resolv.conf 里面存放的是各大通信公司DNS服务器列表；下面的三个地址可以用一用；当
</code></pre></div>
然您可以打电话问你的服务商；</p>
<ol>
<li>nameserver 202.96.134.133</li>
<li>nameserver 202.96.128.143</li>
<li>nameserver 202.96.68.38</li>
</ol>
<p><div class="highlight"><pre><span></span><code>本文写了常用的乙太网接口的配置，介绍了Linux ifconfig 、netconfig 等，我感觉最重要的还
</code></pre></div>
是配置文件，新手弟兄还是仔细看看配置文件吧。当您用工具配置完成后，不妨查看一下相应配置文件</p>
<p>的变化。我认为这样的学习方式，能知其然，然后知所以然；</p>
<h4 id="710_tcpdump">7.10 、 tcpdump<a class="headerlink" href="#710_tcpdump" title="Permanent link">&para;</a></h4>
<p><div class="highlight"><pre><span></span><code>tcpdump是一个用于截取网络分组，并输出分组内容的工具。tcpdump凭借强大的功能和灵活的截
</code></pre></div>
取策略，使其成为类UNIX系统下用于网络分析和问题排查的首选工具。</p>
<p><div class="highlight"><pre><span></span><code>tcpdump提供了源代码，公开了接口，因此具备很强的可扩展性，对于网络维护和入侵者都是非常
</code></pre></div>
有用的工具。tcpdump存在于基本的Linux系统中，由于它需要将网络界面设置为混杂模式，普通用户</p>
<p>不能正常执行，但具备root权限的用户可以直接执行它来获取网络上的信息。因此系统中存在网络分</p>
<p>析工具主要不是对本机安全的威胁，而是对网络上的其他计算机的安全存在威胁。</p>
<p>7.1.1概述</p>
<p>顾名思义，tcpdump可以将网络中传送的数据包的“头”完全截获下来提供分析。它支持针对网络层、</p>
<p>协议、主机、网络或端口的过滤，并提供and、or、not等逻辑语句来帮助你去掉无用的信息。</p>
<p>引用</p>
<h1 id="tcpdump_-vv">tcpdump -vv<a class="headerlink" href="#tcpdump_-vv" title="Permanent link">&para;</a></h1>
<p>tcpdump: listening on eth0, link-type EN10MB (Ethernet), capture size 96 bytes</p>
<p>11:53:21.444591 IP (tos 0x10, ttl 64, id 19324, offset 0, flags [DF], proto 6, length: 9</p>
<p>2) asptest.localdomain.ssh &gt; 192.168.228.244.1858: P 3962132600:3962132652(52) ack 272652</p>
<p>5936 win 1266</p>
<p>asptest.localdomain.1077 &gt; 192.168.228.153.domain: [bad udp cksum 166e!] 325+ PTR? 244.2</p>
<p>28.168.192.in-addr.arpa. (46)</p>
<p>11:53:21.446929 IP (tos 0x0, ttl 64, id 42911, offset 0, flags [DF], proto 17, length: 1</p>
<p>51) 192.168.228.153.domain &gt; asptest.localdomain.1077: 325 NXDomain q: PTR? 244.228.168.</p>
<p>192.in-addr.arpa. 0/1/0 ns: 168.192.in-addr.arpa. (123)</p>
<p>11:53:21.447408 IP (tos 0x10, ttl 64, id 19328, offset 0, flags [DF], proto 6, length: 1</p>
<p>72) asptest.localdomain.ssh &gt; 192.168.228.244.1858: P 168:300(132) ack 1 win 1266</p>
<p>347 packets captured</p>
<p>1474 packets received by filter</p>
<p>745 packets dropped by kernel</p>
<p>不带参数的tcpdump会收集网络中所有的信息包头，数据量巨大，必须过滤。</p>
<p>7.1.2、命令介绍</p>
<p>命令格式为：tcpdump [-nn] [-i 接口] [-w 储存档名] [- c 次数] [-Ae]</p>
<p>[-qX] [-r 文件] [所欲捕获的数据内容]</p>
<p>参数：</p>
<p>-nn，直接以 IP 及 Port Number 显示，而非主机名与服务名称。</p>
<p>-i，后面接要「监听」的网络接口，例如 eth0, lo, ppp0 等等的接口。</p>
<p>-w，如果你要将监听所得的数据包数据储存下来，用这个参数就对了。后面接文件名。</p>
<p>-c，监听的数据包数，如果没有这个参数， tcpdump 会持续不断的监听，</p>
<p>直到用户输入 [ctrl]-c 为止。</p>
<p>-A，数据包的内容以 ASCII 显示，通常用来捉取 WWW 的网页数据包资料。</p>
<p>-e，使用资料连接层 (OSI 第二层) 的 MAC 数据包数据来显示。</p>
<p>-q，仅列出较为简短的数据包信息，每一行的内容比较精简。</p>
<p>-X，可以列出十六进制 (hex) 以及 ASCII 的数据包内容，对于监听数据包内容很有用。</p>
<p>-r，从后面接的文件将数据包数据读出来。那个「文件」是已经存在的文件，并且这个「文件」是由</p>
<p>-w 所制 作出来的。所欲捕获的数据内容：我们可以专门针对某些通信协议或者是 IP 来源进行数据包</p>
<p>捕获。</p>
<p>那就可以简化输出的结果，并取得最有用的信息。常见的表示方法有。</p>
<p>'host foo', 'host 127.0.0.1' ：针对单台主机来进行数据包捕获。</p>
<p>'net 192.168' ：针对某个网段来进行数据包的捕获。</p>
<p>'src host 127.0.0.1' 'dst net 192.168'：同时加上来源(src)或目标(dst)限制。</p>
<p>'tcp port 21'：还可以针对通信协议检测，如tcp、udp、arp、ether 等。</p>
<p>除了这三种类型的关键字之外，其他重要的关键字如下：gateway, broadcast,less,</p>
<p>greater,还有三种逻辑运算，取非运算是 'not ' '! ', 与运算是'and','&amp;&amp;';或运算 是'o</p>
<p>r' ,'||'；</p>
<p>范例一：以 IP 与 Port Number 捉下 eth0 这个网卡上的数据包，持续 3 秒</p>
<p>[root@linux ~]# tcpdump -i eth0 -nn</p>
<p>tcpdump: verbose output suppressed, use -v or -vv for full protocol decode</p>
<p>listening on eth0, link-type EN10MB (Ethernet), capture size 96 bytes</p>
<p>01:33:40.41 IP 192.168.1.100.22 &gt; 192.168.1.11.1190: P 116:232(116) ack 1 win</p>
<p>9648</p>
<p>01:33:40.41 IP 192.168.1.100.22 &gt; 192.168.1.11.1190: P 232:364(132) ack 1 win</p>
<p>9648</p>
<p>&lt;==按下 [ctrl]-c 之后结束</p>
<p>6680 packets captured &lt;==捉取下来的数据包数量</p>
<p>14250 packets received by filter &lt;==由过滤所得的总数据包数量</p>
<p>7512 packets dropped by kernel &lt;==被核心所丢弃的数据包</p>
<p>至于那个在范例一所产生的输出中，我们可以大概区分为几个字段，现以范例一当中那行特殊字体行来</p>
<p>说明一下：</p>
<p>· 01:33:40.41：这个是此数据包被捕获的时间，“时:分:秒”的单位。</p>
<p>· IP：通过的通信协议是IP。</p>
<p>· 192.168.1.100.22&gt;：传送端是192.168.1.100这个IP，而传送的Port Number为 22 ，那个大于（&gt;）</p>
<p>的符号指的是数据包的传输方向。</p>
<p>· 192.168.1.11.1190：接收端的IP是192.168.1.11，且该主机开启port 1190来接收。</p>
<p>· P 116:232(116)：这个数据包带有PUSH的数据传输标志，且传输的数据为整体数据的116~232 Byt</p>
<p>e，所以这个数据包带有116 Bytes的数据量。</p>
<p>· ack 1 win 9648：ACK与Window size的相关资料。</p>
<p>最简单的说法，就是该数据包是由192.168.1.100传到192.168.1.11，通过的port是由 22 到 1190 ，</p>
<p>且带有116 Bytes的数据量，使用的是PUSH的标记，而不是SYN之类的主动联机标志。</p>
<p>接下来，在一个网络状态很忙的主机上面，你想要取得某台主机对你联机的数据包数据时，使用tcpdu</p>
<p>mp配合管线命令与正则表达式也可以，不过，毕竟不好捕获。我们可以通过tcpdump的表达式功能，</p>
<p>就能够轻易地将所需要的数据独立的取出来。在上面的范例一当中，我们仅针对eth0做监听，所以整</p>
<p>个eth0接口上面的数据都会被显示到屏幕上，但这样不好分析，可以简化吗？例如，只取出port 21</p>
<p>的联机数据包，可以这样做：</p>
<p>[root@linux ~]# tcpdump -i eth0 -nn port 21</p>
<p>tcpdump: verbose output suppressed, use -v or -vv for full protocol decode</p>
<p>listening on eth0, link-type EN10MB (Ethernet), capture size 96 bytes</p>
<p>01:54:37.96 IP 192.168.1.11.1240 &gt; 192.168.1.100.21:. ack 1 win 65535</p>
<p>01:54:37.96 IP 192.168.1.100.21 &gt; 192.168.1.11.1240:P 1:21(20) ack 1 win 5840</p>
<p>01:54:38.12 IP 192.168.1.11.1240 &gt; 192.168.1.100.21:. ack 21 win 65515</p>
<p>01:54:42.79 IP 192.168.1.11.1240 &gt; 192.168.1.100.21:P 1:17(16) ack 21 win 65515</p>
<p>01:54:42.79 IP 192.168.1.100.21 &gt; 192.168.1.11.1240:. ack 17 win 5840</p>
<p>01:54:42.79 IP 192.168.1.100.21 &gt; 192.168.1.11.1240: P 21:55(34) ack 17 win 5840</p>
<p>看！这样就仅取出port 21的信息，如果仔细看的话，你会发现数据包的传递都是双向的，Client端</p>
<p>发出请求而Server端则予以响应，所以，当然是有去有回了。而我们也就可以经过这个数据包的流向</p>
<p>来了解到数据包运动的过程了。例如：</p>
<p>· 我们先在一个终端机窗口输入“tcpdump-i lo-nn”的监听。</p>
<p>· 再另开一个终端机窗口来对本机（127.0.0.1）登录“ssh localhost”，那么输出的结果会是如何？</p>
<p>[root@linux ~]# tcpdump -i lo -nn</p>
<p>1 tcpdump: verbose output suppressed, use -v or -vv for full protocol decode</p>
<p>2 listening on lo, link-type EN10MB (Ethernet), capture size 96 bytes</p>
<p>3 11:02:54.253777 IP 127.0.0.1.32936 &gt;</p>
<p>127.0.0.1.22: S 933696132:933696132(0)</p>
<p>win 32767</p>
<p>4 11:02:54.253831 IP 127.0.0.1.22 &gt; 127.0.0.1.32936:</p>
<p>S 920046702:920046702(0)</p>
<p>ack 933696133 win 32767</p>
<p>5 11:02:54.253871 IP 127.0.0.1.32936 &gt; 127.0.0.1.22:. ack 1 win 8192</p>
<p>6 11:02:54.272124 IP 127.0.0.1.22 &gt; 127.0.0.1.32936:</p>
<p>P 1:23(22) ack 1 win 8192</p>
<p>7 11:02:54.272375 IP 127.0.0.1.32936 &gt; 127.0.0.1.22:. ack 23 win 8192</p>
<p>代码显示的头两行是tcpdump的基本说明，然后：</p>
<p>· 第 3 行显示的是来自Client端带有SYN主动联机的数据包。</p>
<p>· 第 4 行显示的是来自Server端，除了响应Client端之外（ACK），还带有SYN主动联机的标志。</p>
<p>· 第 5 行则显示Client端响应Server确定联机建立（ACK）。</p>
<p>· 第 6 行以后则开始进入数据传输的步骤。</p>
<p>从第3~5行的流程来看，熟不熟悉啊？没错。那就是 3 次握手的基础流程，有趣吧。不过tcpdump之所</p>
<p>以被称为黑客软件之一远不止上面介绍的功能。上面介绍的功能可以用来作为我们主机的数据包联机与</p>
<p>传输的流程分析，这将有助于我们了解到数据包的运作，同时了解到主机的防火墙设置规则是否有需要</p>
<p>修订的地方。</p>
<p>还有更神奇的用法。当我们使用tcpdump在Router上面监听明文的传输数据时，例如FTP传输协议，</p>
<p>你觉得会发生什么问题呢？我们先在主机端执行“tcpdump -i lo port 21 -nn –X”，然后再以FTP</p>
<p>登录本机，并输入账号与密码，结果你就可以发现如下的状况：</p>
<p>[root@linux ~]# tcpdump -i lo -nn -X 'port 21'</p>
<p>0x0000: 4500 0048 2a28 4000 4006 1286 7f00 0001 E..H*(@.@.......</p>
<p>0x0010: 7f00 0001 0015 80ab 8355 2149 835c d825 .........U!I..%</p>
<p>0x0020: 8018 2000 fe3c 0000 0101 080a 0e2e 0b67 .....&lt;.........g</p>
<p>0x0030: 0e2e 0b61 3232 3020 2876 7346 5450 6420 ...a220.(vsFTPd.</p>
<p>0x0040: 322e 302e 3129 0d0a 2.0.1)..</p>
<p>0x0000: 4510 0041 d34b 4000 4006 6959 7f00 0001 E..A.K@.@.iY....</p>
<p>0x0010: 7f00 0001 80ab 0015 835c d825 8355 215d ..........%.U!]</p>
<p>0x0020: 8018 2000 fe35 0000 0101 080a 0e2e 1b37 .....5.........7</p>
<p>0x0030: 0e2e 0b67 5553 4552 2064 6d74 7361 690d ...gUSER.dmtsai.</p>
<p>0x0040: 0a.</p>
<p>0x0000: 4510 004a d34f 4000 4006 694c 7f00 0001 E..J.O@.@.iL....</p>
<p>0x0010: 7f00 0001 80ab 0015 835c d832 8355 217f ..........2.U!.</p>
<p>0x0020: 8018 2000 fe3e 0000 0101 080a 0e2e 3227 .....&gt;........2'</p>
<p>0x0030: 0e2e 1b38 5041 5353 206d 7970 6173 7377 ...8PASS.mypassw</p>
<p>0x0040: 6f72 6469 7379 6f75 0d0a ordisyou..</p>
<p>上面的输出结果已经被简化过了，你需要自行在你的输出结果中搜索相关的字符串才行。从上面输出结</p>
<p>果的特殊字体中，我们可以发现该FTP软件使用的是 vsFTPd，并且用户输入dmtsai这个账号名称，且</p>
<p>密码是mypasswordisyou。如果使用的是明文方式来传输你的网络数据呢？</p>
<p>另外你得了解，为了让网络接口可以让tcpdump监听，所以执行tcpdump时网络接口会启动在“混杂模</p>
<p>式（promiscuous）”，所以你会在 /var/log/messages里面看到很多的警告信息，通知你说你的网卡被</p>
<p>设置成为混杂模式。别担心，那是正常的。至于更多的应用，请参考man tcpdump了。</p>
<p>例题：如何使用tcpdump监听来自eth0适配卡且通信协议为port 22，目标来源为192.168.1.100的</p>
<p>数据包资料？</p>
<p>答：tcpdump -i eth0 -nn port 22 and src host 192.168.1.100</p>
<p>例题：如何使用tcpdump抓取访问eth0适配卡且访问端口为tcp 9080？</p>
<p>答:tcpdump -i eth0 dst 172.168.70.35 and tcp port 9080</p>
<p>例题：如何使用tcpdump抓取与主机192.168.43.23或着与主机192.168.43.24通信报文，并且显示在</p>
<p>控制台上</p>
<p>答：tcpdump -X -s 1024 -i eth0 host <span class="arithmatex"><span class="MathJax_Preview">192.168.43.23 or 192.168.43.24</span><script type="math/tex">192.168.43.23 or 192.168.43.24</script></span> and host 172.16.7</p>
<p>0.35</p>
<h5 id="_71">注：必须指定网卡<a class="headerlink" href="#_71" title="Permanent link">&para;</a></h5>
<p>7.1.3、tcpdump的表达式介绍</p>
<p>表达式是一个正则表达式，tcpdump利用它作为过滤报文的条件，如果一个报文满足表 达式的条件，</p>
<p>则这个报文将会被捕获。如果没有给出任何条件，则网络上所有的信息包 将会被截获。</p>
<p>在表达式中一般如下几种类型的关键字：</p>
<p>引用</p>
<p>第一种是关于类型的关键字，主要包括host，net，port，例如 host 210.27.48.2， 指明 210.27.48.</p>
<p>2 是一台主机，net 202.0.0.0指明202.0.0.0是一个网络地址，port 23 指明端口号是 23 。如果没有</p>
<p>指定类型，缺省的类型是host。</p>
<p>第二种是确定传输方向的关键字，主要包括src，dst，dst or src，dst and src， 这些关键字指明</p>
<p>了传输的方向。举例说明，src 210.27.48.2 ，指明ip包中源地址是 210.27.48.2 ， dst net 202.</p>
<p>0.0.0 指明目的网络地址是202.0.0.0。如果没有指明 方向关键字，则缺省是src or dst关键字。</p>
<p>第三种是协议的关键字，主要包括fddi，ip，arp，rarp，tcp，udp等类型。Fddi指明是在FDDI (分</p>
<p>布式光纤数据接口网络)上的特定的网络协议，实际上它是”ether”的别名，fddi和ether 具有类似</p>
<p>的源地址和目的地址，所以可以将fddi协议包当作ether的包进行处理和分析。 其他的几个关键字就</p>
<p>是指明了监听的包的协议内容。如果没有指定任何协议，则tcpdump 将会 监听所有协议的信息包。</p>
<p>除了这三种类型的关键字之外，其他重要的关键字如下：gateway， broadcast，less， greater，</p>
<p>还有三种逻辑运算，取非运算是 ‘not ' '! ‘， 与运算是’and’，’&amp;&amp;';或运算是’or’ ，’&#124;</p>
<p>&#124;’； 这些关键字可以组合起来构成强大的组合条件来满足人们的需要。</p>
<p>四、输出结果介绍</p>
<p>下面我们介绍几种典型的tcpdump命令的输出信息</p>
<p>(1) 数据链路层头信息</p>
<p>使用命令：</p>
<h1 id="tcpdump_--e_host_ice">tcpdump --e host ICE<a class="headerlink" href="#tcpdump_--e_host_ice" title="Permanent link">&para;</a></h1>
<p>ICE 是一台装有linux的主机。它的MAC地址是 0 ： 90 ： 27 ： 58 ：AF：1A H219是一台装有Solaris的</p>
<p>SUN工作站。它的MAC地址是 8 ： 0 ： 20 ： 79 ：5B： 46 ； 上一条命令的输出结果如下所示：</p>
<p>引用</p>
<p>21:50:12.847509 eth0 &lt; 8:0:20:79:5b:46 0:90:27:58:af:1a ip 60: h219.33357 &gt; ICE. telne t</p>
<p>0:0(0) ack 22535 win 8760 (DF)</p>
<p>21 ： 50 ： 12 是显示的时间， 847509 是ID号，eth0 &lt;表示从网络接口eth0接收该分组， eth0 &gt;表示</p>
<p>从网络接口设备发送分组， 8:0:20:79:5b:46是主机H219的MAC地址， 它表明是从源地址H219发来</p>
<p>的分组. 0:90:27:58:af:1a是主机ICE的MAC地址， 表示该分组的目的地址是ICE。 ip 是表明该分</p>
<p>组是IP分组， 60 是分组的长度， h219.33357 &gt; ICE. telnet 表明该分组是从主机H219的 33357 端</p>
<p>口发往主机ICE的 TELNET(23)端口。 ack 22535 表明对序列号是 222535 的包进行响应。 win 8760</p>
<p>表明发 送窗口的大小是 8760 。</p>
<div class="highlight"><pre><span></span><code>(2) ARP包的tcpdump输出信息
使用命令：
#tcpdump arp
</code></pre></div>
<h5 id="_72">得到的输出结果是：<a class="headerlink" href="#_72" title="Permanent link">&para;</a></h5>
<h5 id="_73">引用<a class="headerlink" href="#_73" title="Permanent link">&para;</a></h5>
<p>22:32:42.802509 eth0 &gt; arp who-has route tell ICE (0:90:27:58:af:1a)</p>
<p>22:32:42.802902 eth0 &lt; arp reply route is-at 0:90:27:12:10:66 (0:90:27:58:af:1a)</p>
<p>22:32:42是时间戳， 802509 是ID号， eth0 &gt;表明从主机发出该分组，arp表明是ARP请求包， who</p>
<p>-has route tell ICE表明是主机ICE请求主机route的MAC地址。 0:90:27:58:af:1a是主机 ICE的</p>
<p>MAC地址。</p>
<p>(3) TCP包的输出信息</p>
<p>用tcpdump捕获的TCP包的一般输出信息是：</p>
<p>引用</p>
<p>src &gt; dst: flags data-seqno ack window urgent options</p>
<p>src &gt; dst:表明从源地址到目的地址， flags是TCP报文中的标志信息，S 是SYN标志， F (FIN)，</p>
<p>P (PUSH) ， R (RST) "." (没有标记); data-seqno是报文中的数据 的顺序号， ack是下次期望的顺</p>
<p>序号， window是接收缓存的窗口大小， urgent表明 报文中是否有紧急指针。 Options是选项。</p>
<p>(4) UDP包的输出信息</p>
<p>用tcpdump捕获的UDP包的一般输出信息是：</p>
<p>引用</p>
<p>route.port1 &gt; ICE.port2: udp lenth</p>
<p>UDP十分简单，上面的输出行表明从主机route的port1端口发出的一个UDP报文 到主机ICE的port</p>
<p>2 端口，类型是UDP， 包的长度是lenth。</p>
<p>五、举例</p>
<p>(1) 想要截获所有210.27.48.1 的主机收到的和发出的所有的分组：</p>
<h1 id="tcpdump_host_21027481">tcpdump host 210.27.48.1<a class="headerlink" href="#tcpdump_host_21027481" title="Permanent link">&para;</a></h1>
<p>(2) 想要截获主机210.27.48.1 和主机210.27.48.2或210.27.48.3的通信，使用命令（注意：括号</p>
<p>前的反斜杠是必须的）：</p>
<h1 id="tcpdump_host_21027481_and_21027482_or_21027483_21027482_or_21027483">tcpdump host 210.27.48.1 and <span class="arithmatex"><span class="MathJax_Preview">210.27.48.2 or 210.27.48.3 </span><script type="math/tex">210.27.48.2 or 210.27.48.3 </script></span><a class="headerlink" href="#tcpdump_host_21027481_and_21027482_or_21027483_21027482_or_21027483" title="Permanent link">&para;</a></h1>
<p>(3) 如果想要获取主机210.27.48.1除了和主机210.27.48.2之外所有主机通信的ip包，使用命令：</p>
<h1 id="tcpdump_ip_host_21027481_and_21027482">tcpdump ip host 210.27.48.1 and! 210.27.48.2<a class="headerlink" href="#tcpdump_ip_host_21027481_and_21027482" title="Permanent link">&para;</a></h1>
<p>(4) 如果想要获取主机192.168.228.246接收或发出的ssh包，并且不转换主机名使用如下命令：</p>
<h1 id="tcpdump_-nn_-_n_src_host_192168228246_and_port_22_and_tcp">tcpdump -nn - n src host 192.168.228.246 and port 22 and tcp<a class="headerlink" href="#tcpdump_-nn_-_n_src_host_192168228246_and_port_22_and_tcp" title="Permanent link">&para;</a></h1>
<p>(5) 获取主机192.168.228.246接收或发出的ssh包，并把mac地址也一同显示：</p>
<h1 id="tcpdump_-e_src_host_192168228246_and_port_22_and_tcp_-n_-nn">tcpdump -e src host 192.168.228.246 and port 22 and tcp -n -nn<a class="headerlink" href="#tcpdump_-e_src_host_192168228246_and_port_22_and_tcp_-n_-nn" title="Permanent link">&para;</a></h1>
<p>(6) 过滤的是源主机为192.168.0.1与目的网络为192.168.0.0的报头：</p>
<p>tcpdump src host 192.168.0.1 and dst net 192.168.0.0/24</p>
<p>(7) 过滤源主机物理地址为XXX的报头：</p>
<p>tcpdump ether src 00:50:04:BA:9B and dst......</p>
<p>（为什么ether src后面没有host或者net？物理地址当然不可能有网络喽）。</p>
<p>(8) 过滤源主机192.168.0.1和目的端口不是telnet的报头，并导入到tes.t.txt文件中：</p>
<p>Tcpdump src host 192.168.0.1 and dst port not telnet -l &gt; test.txt</p>
<p>ip icmp arp rarp 和 tcp、udp、icmp这些选项等都要放到第一个参数的位置，用来过滤数据报的类</p>
<p>型。</p>
<h2 id="_74">十五、 配置文件<a class="headerlink" href="#_74" title="Permanent link">&para;</a></h2>
<h4 id="1_11">1 、 配置文件介绍：<a class="headerlink" href="#1_11" title="Permanent link">&para;</a></h4>
<p>每个 Linux 程序都是一个可执行文件，它含有操作码列表，CPU 将执行这些操作码来完成特定的操作。
例如，ls 命令是由 /bin/ls 文件提供的，该文件含有机器指令的列表，在屏幕上显示当前目录中文件
的列表时需要使用这些机器指令。几乎每个程序的行为都可以通过修改其配置文件来按照您的偏好或需
要去定制。
Linux 中有没有一个标准的配置文件格式？
一句话，没有。不熟悉 Linux 的用户（一定）会感到沮丧，因为每个配置文件看起来都象是一个要迎
接的新挑战。在 Linux 中，每个 程序员都可以自由选择他或她喜欢的配置文件格式。可以选择的格式
很多，从 /etc/shells 文件（它包含被一个换行符分开的 shell 的列表），到 Apache 的复杂的
/etc/httpd.conf 文件。
什么是系统配置文件？
内核本身也可以看成是一个“程序”。为什么内核需要配置文件？内核需要了解系统中用户和组的列表，
进而管理文件权限（即根据权限判定特定用户（UNIX_USERS）是否可以打开某个文件）。注意，这些文
件不是明确地由程序读取的，而是由系统库所提供的一个函数读取，并被内核使用。例如，程序需要某
个用户的（加密过的）密码时不应该打开 /etc/passwd 文件。相反，程序应该调用系统库的 getpw() 函
数。这种函数也被称为系统调用。打开 /etc/passwd 文件和之后查找那个被请求的用户的密码都是由
内核（通过系统库）决定的。
除非另行指定，Red Hat Linux 系统中大多数配置文件都在 /etc 目录中。配置文件可以大致分为下面
几类：</p>
<h4 id="2_4">2 、配置文件分类：<a class="headerlink" href="#2_4" title="Permanent link">&para;</a></h4>
<h5 id="_75">访问文件<a class="headerlink" href="#_75" title="Permanent link">&para;</a></h5>
<p><div class="highlight"><pre><span></span><code>/etc/host.conf 告诉网络域名服务器如何查找主机名。（通常是 /etc/hosts，
然后就是名称服务器；可通过 netconf 对其进行更改）
</code></pre></div>
<div class="highlight"><pre><span></span><code>/etc/hosts
</code></pre></div></p>
<h5 id="ip_2">包含（本地网络中）已知主机的一个列表。如果系统的 IP 不<a class="headerlink" href="#ip_2" title="Permanent link">&para;</a></h5>
<h5 id="_76">是动态生成，就可以使用它。对于简单的主机名解析（点分表<a class="headerlink" href="#_76" title="Permanent link">&para;</a></h5>
<h5 id="dns_nis">示法），在请求 DNS 或 NIS 网络名称服务器之前，<a class="headerlink" href="#dns_nis" title="Permanent link">&para;</a></h5>
<div class="highlight"><pre><span></span><code>/etc/hosts.conf 通常会告诉解析程序先查看这里。
/etc/hosts.allow 请参阅 hosts_access 的联机帮助页。至少由 tcpd 读取。
/etc/hosts.deny 请参阅 hosts_access 的联机帮助页。至少由 tcpd 读取。
</code></pre></div>
<h5 id="_77">引导和登录／注销<a class="headerlink" href="#_77" title="Permanent link">&para;</a></h5>
<p><div class="highlight"><pre><span></span><code>/etc/issue &amp;
/etc/issue.net
</code></pre></div>
<div class="highlight"><pre><span></span><code>这些文件由 mingetty（和类似的程序）读取，用来向从终端（issue）或
通过 telnet 会 话（issue.net）连接的用户显示一个“welcome”字符串。
它们包括几行声明 Red Hat 版本号、名称和内核 ID 的信息。它们由
</code></pre></div></p>
<p><div class="highlight"><pre><span></span><code>rc.local 使用。
/etc/redhat-release 包括一行声明 Red Hat 版本号和名称的信息。由 rc.local 使用。
</code></pre></div>
<div class="highlight"><pre><span></span><code>/etc/rc.d/rc
</code></pre></div>
<div class="highlight"><pre><span></span><code>通常在所有运行级别运行，级别作为参数传送。例如，要以图形（Graphics）
模式（X- Server）引导机器，请在命令行运行下面的命令： init 5 。运
行级别 5 表示以图形模式引导系统。
/etc/rc.d/rc.local 非正式的。可以从 rc、rc.sysinit 或 /etc/inittab 调用。
/etc/rc.d/rc.sysinit 通常是所有运行级别的第一个脚本。
</code></pre></div>
<div class="highlight"><pre><span></span><code>/etc/rc.d/rc/rcX.d
</code></pre></div>
<div class="highlight"><pre><span></span><code>从 rc 运行的脚本（ X 表示 1 到 5 之间的任意数字）。这些目录是特
定“运行级别”的目录。当系统启动时，它会识别要启动的运行级别，然
后调用该运行级别的特定目录中存在的所有启动脚本。例如，系统启动时
通常会在引导消息之后显示“entering run-level 3”的消息；这意味着
/etc/rc.d/rc3.d/ 目录中的所有初始化脚本都将被调用。
</code></pre></div></p>
<h5 id="_78">文件系统<a class="headerlink" href="#_78" title="Permanent link">&para;</a></h5>
<h5 id="_79">内核提供了一个接口，用来显示一些它的数据结构，这些数据结构对于决定诸如使用的中断、初始化<a class="headerlink" href="#_79" title="Permanent link">&para;</a></h5>
<h5 id="_80">的设备和内存统计信息之类的系统参数可能很有用。这个接口是作为一个独立但虚拟的文件系统提供<a class="headerlink" href="#_80" title="Permanent link">&para;</a></h5>
<p>的，称为 /proc 文件系统。很多系统实用程序都使用这个文件系统中存在的值来显示系统统计信息。
例如，/proc/modules 文件列举系统中当前加载的模块。lsmod 命令读取此信息，然后将其以人们可
以看懂的格式显示出来。下面表格中指定的 mtab 文件以同样的方式读取包含当前安装的文件系统的
/proc/mount 文件。</p>
<p><div class="highlight"><pre><span></span><code>/etc/mtab
</code></pre></div>
<div class="highlight"><pre><span></span><code>这将随着 /proc/mount 文件的改变而不断改变。换句话说，文件系统被安装和
卸载时，改变会立即反映到此文件中。
1.文件格式
/etc/mtab的格式和/etc/fstab是一样的.但这个文件不能算是用户配置文件,
他是由系统维护的.和/etc/fstab的区别在于, fstab是系统启动时需挂载的文
件系统列表,而mtab是系统当前已挂载的文件系统列表,它由系统维护,在用户
执行了mount或者umount命令后自动更新.用户不应该对此文件作任何修改.
2.安全性
/etc/mtab的默认权限仍然是 644
3.相关命令
mount
umount
smbmount
</code></pre></div>
<div class="highlight"><pre><span></span><code>/etc/fstab
</code></pre></div></p>
<h5 id="1_12">1.文件格式<a class="headerlink" href="#1_12" title="Permanent link">&para;</a></h5>
<div class="highlight"><pre><span></span><code>/etc/fstab记载了系统启动时自动挂载的文件系统。一行为一条记录。每条记
录有 6 个字段，字段间用空格或者tab键分开。这六个字段分别是：设备名称，
挂载点（除交换分区为swap外，都必须是一个存在的目录名），文件系统类型，
mount选项，是否需要dump（ 1 表示需要， 0 表示不需要），在 reboot期间fsck
检查的顺序（激活文件系统设定为 1 ，其余文件系统设定为 2 ，若设定为 0 表示
该文件系统不需要被检查）。
在linux和windows共存时，也许想开机自动挂载windows分区，那么就可以
在这个文件里加上相应的记录。
</code></pre></div>
<h5 id="_81">某些时候对硬盘分区作了调整以后，这里也需要做一些相应的修改。否则会出<a class="headerlink" href="#_81" title="Permanent link">&para;</a></h5>
<h5 id="_82">现一些问题。<a class="headerlink" href="#_82" title="Permanent link">&para;</a></h5>
<p>可用的mount选项：
async
对该文件系统的所有I/O操作都异步执行
ro
该文件系统是只读的
rw
该文件系统是可读可写的
atime
更新每次存取inode的存取时间
auto
可以使用 -a 选项mount
defaults
使用预设的选项：rw,suid,dev,exec,auto,nouser,async
dev
解释在文件系统上的字符或区块设备
exec
允许执行二进制文件
noatime
不要在这个文件系统上更新存取时间
noauto
这个文件系统不能使用 -a 选项来mount
nodev
不要解释在文件系统上的字符或区块设备
noexec
不允许在mounted文件系统上执行任何的二进制文件。这个选项对于具有包含
非它自己的二进制结构的文件系统服务器而言非常有用
nosuid
不允许setuid和setgid位发生作用。（这似乎很安全，但是在安装suidperl
后，同样不安全）。
nouser
限制一般非root用户mount文件系统
remount
尝试重新mount已经mounted的文件系统。这通常是用来改变文件系统的mount
标志，特别是让只读的文件系统变成可擦写的
suid
允许setuid和setgid位发生作用
sync
文件系统的所有I/O同步执行
user
允许一般非root用户mount文件系统。这个选项会应用noexec,nosuid,nodev
这三个选项（除非在命令行上有指定覆盖这些设定的选项）。
3.安全性</p>
<p><div class="highlight"><pre><span></span><code>/etc/fstab的默认权限是644,所有者和所有组均为root
2.相关命令
mount
df
列举计算机当前“可以安装”的文件系统。这非常重要，因为计算机引导时将
运行 mount -a 命令，该命令负责安装 fstab 的倒数第二列中带有“1”标记
的每一个文件系统。
/etc/mtools.conf DOS 类型的文件系统上所有操作（创建目录、复制、格式化等等）的配置。
</code></pre></div>
系统管理</p>
<div class="highlight"><pre><span></span><code>/etc/group
</code></pre></div>
<h5 id="1_13">1.文件格式<a class="headerlink" href="#1_13" title="Permanent link">&para;</a></h5>
<p><div class="highlight"><pre><span></span><code>/etc/group存储了系统中所有用户的基本信息.它的格式和/etc/passwd的格
式基本类似,这里就说简单一点,
/etc/group也是由一条条的记录组成.每条记录分 4 个字段.分别是组名,组口
令,组ID和该组包含用户列表.其中组口令不再使用（现在只是保留为 x）.最
后一个域是一个用逗号分隔的用户名列表,这个组的成员就是在这里列出的所
有用户.
2.安全性
/etc/group的默认权限是644,所有者和所有组均为root.注意经常检察.
3.相关命令
groupadd
groupdel
groupmod
groups
包含有效的组名称和指定组中包括的用户。单一用户如果执行多个任务，可以
存在于多个组中。例如，如果一个“ 用户”是 “project 1”工程组的成员，同
时也是管理员，那么在 group 文件中他的条目看起来就会是这样的： user: * :
group-id : project1
</code></pre></div>
<div class="highlight"><pre><span></span><code>/etc/nologin
</code></pre></div>
<div class="highlight"><pre><span></span><code>这是一个普通的文本文件.你可以在里面写上你喜欢的任何东西./etc/nologin
的作用在于,如果它存在,那么系统将拒绝任何非root用户的登录请求,并对其
它登录 用户显示此文件的内容
此文件常由系统在停机前自动生成.有时系统管理员也会手工生成它,用以禁止
其它用户登录,方便进行一些管理工作.
</code></pre></div>
<div class="highlight"><pre><span></span><code>etc/passwd
</code></pre></div></p>
<h5 id="1_14">1.文件格式<a class="headerlink" href="#1_14" title="Permanent link">&para;</a></h5>
<div class="highlight"><pre><span></span><code>/etc/passwd存储了系统中所有用户的基本信息.可以说这是系统中最重要的一
个配置文件.对它作任何修改一定要小心谨慎.同时要经常检察这个文件,包括
它的内容和权限设置.
使用vi编辑程序打开此文件,可以看到这个文件由许多行记录组成.每一行记
录对应着一个用户.我们以第一行为例.第一行一般是root用户的记录,尽管这
不是必需的.实际上用户记录出现的顺序并没有任何的意义.
在我的系统中,/etc/passwd的第一行看起来是这样的:
root:x:0:0:root:/root:/bin/bash
每一条记录都由 7 个字段组成,每个字段之间用冒号隔开.第一个字段是用户
名,示例中是root.第二个字段是用户口令,示例中是一个字符x,但这并不表示
</code></pre></div>
<p><div class="highlight"><pre><span></span><code>root的口令是单个字符x,而是说用户口令被加密了,并且加密口令也没有放在
本文件中,而是放到了/etc/shadow(参考 /etc/shadow).假如删除这个x,那么
root的口令就清空了.第三个字段是用户的用户ID,即uid.第四个字段是用户
的组ID,即gid. 这里要注意,系统分辨两个用户是看他们的uid是否相同而不
是看他们的用户名是否相同.用户名不同但uid相同的两个用户实际上是同一
个用户.对组来说也有类似的规则.所以这两个字段大家一定要注意.第五个字
段是用户全称,没有什么实际用途,相当于注释,这里是root.第六个字段是用户
的主目录 (home),即登录系统后默认所处目录,这里是/root.最后一个字段是
用户的登录shell,可以是系统拥有的任何一个shell的完整路径,这里是
/bin/bash.注意,这个字段可以有一个特殊的值,即/sbin/nologin.如果把一个
用户的登录shell设置为 /sbin/nologin的话,系统将禁止此用户的本地登录.
请参阅“man passwd”。它包含一些用户帐号信息，包括密码（如果未被 shadow
程序加密过）。
2.安全性
/etc/passwd的默认权限为644,所有者和所有组均为root.切记,在任何情况下
都不要更改它.
3.相关命令
passwd
useradd
userdel
adduser
usermod
users
</code></pre></div>
/etc/rpmrc
rpm 命令配置。所有的 rpm 命令行选项都可以在这个文件中一起设置，这样，
当任何 rpm 命令在该系统中运行时，所有的选项都会全局适用。</p>
<p>/etc/securetty</p>
<p><div class="highlight"><pre><span></span><code>包含设备名称，由 tty 行组成（每行一个名称，不包括前面的 /dev/），root
用户在这里被允许登录。
1.文件格式
这是一个设备文件的列表.文件名取相对于/dev的相对路径.如,/dev/tty1记
为tty1
root只有从这个列表中列出的设备上才可以登录系统.
例如:
代码:
$cat /etc/securretty
tty1
tty2
tty3
这里root被限定只能从/dev/tty1, /dev/tty2, /dev/tty3这三个设备上登录
系统
如果/etc/securretty不存在的话,那么root将可以从任何设备登录系统.
2.安全性
/etc/securetty的默认权限是600,所有者和所有组都是root
</code></pre></div>
/etc/shadow 包含加密后的用户帐号密码信息，还可以包括密码时效信息。包括的字段有：</p>
<h5 id="_83">• 登录名<a class="headerlink" href="#_83" title="Permanent link">&para;</a></h5>
<h5 id="_84">• 加密后的密码<a class="headerlink" href="#_84" title="Permanent link">&para;</a></h5>
<h5 id="1970_1_1">• 从 1970 年 1 月 1 日到密码最后一次被更改的天数<a class="headerlink" href="#1970_1_1" title="Permanent link">&para;</a></h5>
<h5 id="_85">• 距密码可以更改之前的天数<a class="headerlink" href="#_85" title="Permanent link">&para;</a></h5>
<h5 id="_86">• 距密码必须更改之前的天数<a class="headerlink" href="#_86" title="Permanent link">&para;</a></h5>
<h5 id="_87">• 密码到期前用户被警告的天数<a class="headerlink" href="#_87" title="Permanent link">&para;</a></h5>
<h5 id="_88">• 密码到期后帐户被禁用的天数<a class="headerlink" href="#_88" title="Permanent link">&para;</a></h5>
<h5 id="1970_1_2">• 从 1970 年 1 月 1 日到帐号被禁用的天数<a class="headerlink" href="#1970_1_2" title="Permanent link">&para;</a></h5>
<h5 id="1_15">1.文件格式<a class="headerlink" href="#1_15" title="Permanent link">&para;</a></h5>
<p>/etc/shadow文件保存的是用户名,密码,用户账号设置相关信息。</p>
<p>例：</p>
<p>root:<span class="arithmatex"><span class="MathJax_Preview">1</span><script type="math/tex">1</script></span>6UviCNvh$WTR0zPMek41KmzD0Z1DdV1:12264:3:4:5:6:12267:</p>
<p>第一段: root----- 用户注册名</p>
<p>第二段: <span class="arithmatex"><span class="MathJax_Preview">1</span><script type="math/tex">1</script></span>6UviCNvh$WTR0zPMek41KmzD0Z1DdV1 ----加密口令</p>
<p>第三段: 12264-----上次更动密码的日期,以 1970 年 1 月 1 日为1,1天加 1</p>
<p>第四段: 3---------密码将被允许修改之前的天数（ 0 表示“可在任何时间修
改”）</p>
<p>第五段: 4---------系统将强制用户修改为新密码之前的天数（ 1 表示“永远
都不能修改”）</p>
<p>第六段: 5---------密码过期之前，用户将被警告过期的天数（-1 表示 “没有
警告”）</p>
<p>第七段: 6---------密码过期之后，系统自动禁用帐户的天数（-1 表示 “永远
不会禁用”）</p>
<p>第八段: 12267-----该帐户被禁用的天数（-1 表示“该帐户被启用”）.以 1970
年 1 月 1 日为1,1月 2 日为 2</p>
<p>第九段 ------ 保留供将来使用</p>
<p>注:第 2 段中为*表示帐号不可登录,如密码前为 !! 或只有 !! 表示帐号被锁</p>
<p>2.安全性</p>
<p><div class="highlight"><pre><span></span><code>/etc/shadow的默认所有者和所有组均为root.
</code></pre></div>
<div class="highlight"><pre><span></span><code>建议运行# chattr +i /etc/shadow来保护文件使其不被意外地删除或重写
</code></pre></div>
<div class="highlight"><pre><span></span><code>3.相关命令
</code></pre></div>
<div class="highlight"><pre><span></span><code>passwd
</code></pre></div>
<div class="highlight"><pre><span></span><code>useradd
</code></pre></div>
<div class="highlight"><pre><span></span><code>userdel
</code></pre></div>
<div class="highlight"><pre><span></span><code>usermod
</code></pre></div>
/ect/gshadow</p>
<h5 id="1_16">1.文件格式<a class="headerlink" href="#1_16" title="Permanent link">&para;</a></h5>
<p><div class="highlight"><pre><span></span><code>/ect/gshadow文件保存的是用户和组群设置的信息
例:
root:!!::root,wa1
第一段：组名
第四段：该组包含用户列表
2.安全性
/etc/gshadow的默认所有者和所有组均为root.
建议运行# chattr +i /etc/shadow来保护文件使其不被意外地删除或重写
3.相关命令
groupadd
groupdel
groupmod
groups
</code></pre></div>
/etc/sysctl.conf</p>
<h5 id="1_17">1.文件格式<a class="headerlink" href="#1_17" title="Permanent link">&para;</a></h5>
<div class="highlight"><pre><span></span><code>/etc/sysctl.conf是sysctl程序的配置文件.sysctl可以在系统运行时更改内
核参数./etc/sysctl.conf中的配置将在系统起动时执行.
以 # 和 ; 开始的行是注释,将和空白行一起被忽略.
配置项的格式为:
token = value
token是一个键名,value是对应的键值.token和value前后的空格将被忽略
token不能是随意的字符串.他和/proc/sys下的文件有一一对应的关系:
假设foo是/proc/sys下的一个文件.删除foo的绝对路径前的 &quot;/proc/sys&quot; 这
一部分,然后把剩下部分中的 &quot;/&quot; 替换成 &quot;.&quot;,得到的字符串就是foo所对应
的键名.例如:
/proc/sys/net/ipv4/ip_forward对应的键 名为net.ipv4.ip_forward
应用举例:
Redhat Linux 9默认是禁止ip转发的,而我们在做ip伪装时需要起用ip转发.
通常的做法是在iptables的规则之前加上一句:
echo 1&gt;/proc/sys/net/ipv4/ip_forward
实际上我们也可以在/etc/sysctl.conf中写上:
</code></pre></div>
<p><div class="highlight"><pre><span></span><code>net.ipv4.ip_forward = 1
这样系统就默认起用ip转发了.当然他不会立即生效.因为/etc/sysctl.conf
是在系统起动时读入的.想要立即生效的话,请使用sysctl命令.
2.安全性
/etc/sysctl.conf的默认权限是644,所有者和所有组均为root
3.See also
sysctl(8)
sysctl.conf(5)
proc(5)
procinfo(8)
</code></pre></div>
<div class="highlight"><pre><span></span><code>/etc/shells 包含系统可用的可能的“shell”的列表。
/etc/motd 每日消息；在管理员希望向 Linux 服务器的所有用户传达某个消息时使用。
</code></pre></div></p>
<h5 id="_89">联网<a class="headerlink" href="#_89" title="Permanent link">&para;</a></h5>
<p><div class="highlight"><pre><span></span><code>/etc/gated.conf gated 的配置。只能被 gated 守护进程所使用。
/etc/gated.version 包含 gated 守护进程的版本号。
/etc/gateway 由 routed 守护进程可选地使用。
</code></pre></div>
<div class="highlight"><pre><span></span><code>/etc/networks
</code></pre></div></p>
<h5 id="_90">列举从机器所连接的网络可以访问的网络名和网络地址。<a class="headerlink" href="#_90" title="Permanent link">&para;</a></h5>
<h5 id="_91">通过路由命令使用。允许使用网络名称。<a class="headerlink" href="#_91" title="Permanent link">&para;</a></h5>
<div class="highlight"><pre><span></span><code>/etc/protocols
</code></pre></div>
<h5 id="nag">列举当前可用的协议。请参阅 NAG（网络管理员指南，<a class="headerlink" href="#nag" title="Permanent link">&para;</a></h5>
<p><div class="highlight"><pre><span></span><code>Network Administrators Guide）和联机帮助页。 C 接口
是 getprotoent。绝不能更改。
</code></pre></div>
<div class="highlight"><pre><span></span><code>/etc/resolv.conf
</code></pre></div></p>
<h5 id="ip_3">在程序请求“解析”一个 IP 地址时告诉内核应该查询哪<a class="headerlink" href="#ip_3" title="Permanent link">&para;</a></h5>
<h5 id="_92">个名称服务器。<a class="headerlink" href="#_92" title="Permanent link">&para;</a></h5>
<h5 id="1_18">1.文件格式<a class="headerlink" href="#1_18" title="Permanent link">&para;</a></h5>
<div class="highlight"><pre><span></span><code>/etc/resolv.conf是系统的DNS解析器配置文件，最常见
的用途是用来指定系统所使用的DNS服务器地址，您可以
最多指定MAXNS个 DNS服务器，MAXNS是一个常量，在
/usr/include/resolv.h中定义，一般为 3 。每 个DNS服务
器地址应该以点分十进制格式写在单独的行上，前面加上
关键字nameserver。例如：
nameserver 173.26.100.99
nameserver 202.118.224.101
这里我们指定了两个DNS服务器，ip地址分别为
173.26.100.99和202.118.224.101。当系统需要进行DNS
解析时，优先使用列在前面的DNS Server，如果解析失败
则转而使用下一个DNS Server。
2.安全性
/etc/resolv.conf的默认权限为 0644
/etc/host.conf 1.文件格式
</code></pre></div>
<p><div class="highlight"><pre><span></span><code>/etc/host.conf也是一个DNS解析器配置文件，但它最常
见的用途是用来指定解析器使用的方法。一般来说，DNS
解析可以使用两种方法，一是查询DNS服务器，二是使用
本地hosts主机表。/etc/host.conf可以用来指定优先使
用哪一种方法。可以使用order关键字来指定他们的优先
级.order后可跟一种或多种DNS查询方法，之间用逗号隔
开，其优先级依次降低。可用的DNS查询方法有：
hosts,bind,nis，分别表示使用本地hosts主机表，DNS
服务器，NIS服务器来进行DNS查询。最常见的配置是：
order bind,hosts
2.安全性
/etc/host.conf的默认权限为 0644
</code></pre></div>
<div class="highlight"><pre><span></span><code>/etc/rpc
</code></pre></div></p>
<h5 id="rpc_nfs">包含 RPC 指令／规则，这些指令／规则可以在 NFS 调用、<a class="headerlink" href="#rpc_nfs" title="Permanent link">&para;</a></h5>
<h5 id="_93">远程文件系统安装等中使用。<a class="headerlink" href="#_93" title="Permanent link">&para;</a></h5>
<p><div class="highlight"><pre><span></span><code>/etc/exports 要导出的文件系统（NFS）和对它的权限。
</code></pre></div>
<div class="highlight"><pre><span></span><code>/etc/services
将网络服务名转换为端口号／协议。由 inetd、telnet、
tcpdump 和一些其它程序读取。有一些 C 访问例程。
</code></pre></div>
<div class="highlight"><pre><span></span><code>/etc/inetd.conf
</code></pre></div>
<div class="highlight"><pre><span></span><code>inetd 的配置文件。请参阅 inetd 联机帮助页。包含每个
网络服务的条目，inetd 必须为这些网络服务控制守护进
程或其它服务。注意，服务将会运行，但在 /etc/services
中将它们注释掉了，这样即使这些服务在运行也将不可用。
格式为：&lt;service_name&gt; &lt;sock_type&gt; &lt;proto&gt; &lt;flags&gt;
&lt;user&gt; &lt;server_path&gt; &lt;args&gt;
/etc/sendmail.cf 邮件程序 sendmail 的配置文件。比较隐晦，很难理解。
/etc/sysconfig/network 指出 NETWORKING=yes 或 no。至少由 rc.sysinit 读取。
/etc/sysconfig/network-scripts/if* Red Hat 网络配置脚本。
</code></pre></div></p>
<h5 id="_94">系统命令<a class="headerlink" href="#_94" title="Permanent link">&para;</a></h5>
<p>系统命令要独占地控制系统，并让一切正常工作。所有如 login（完成控制台用户身份验证阶段）或
bash（提供用户和计算机之间交互）之类的程序都是系统命令。因此，和它们有关的文件也特别重要。
这一类别中有下列令用户和管理员感兴趣的文件。</p>
<div class="highlight"><pre><span></span><code>/etc/lilo.conf
</code></pre></div>
<h5 id="lilo">包含系统的缺省引导命令行参数，还有启动时使用的不同映象。您在 LILO<a class="headerlink" href="#lilo" title="Permanent link">&para;</a></h5>
<p><div class="highlight"><pre><span></span><code>引导提示的时候按 Tab 键就可以看到这个列表。
/etc/logrotate.conf 维护 /var/log 目录中的日志文件。
</code></pre></div>
<div class="highlight"><pre><span></span><code>/etc/identd.conf
</code></pre></div>
<div class="highlight"><pre><span></span><code>identd 是一个服务器，它按照 RFC 1413 文档中指定的方式实现 TCP/IP
提议的标准 IDENT 用户身份识别协议。identd 的操作原理是查找特定
TCP/IP 连接并返回拥有此连接的进程的用户名。作为选择，它也可以返回
其它信息，而不是用户名。请参阅 identd 联机帮助页。
/etc/ld.so.conf “动态链接程序”（Dynamic Linker）的配置。
</code></pre></div>
<div class="highlight"><pre><span></span><code>/etc/inittab
</code></pre></div></p>
<h5 id="unix_unix">按年代来讲，这是 UNIX 中第一个配置文件。在一台 UNIX 机器打开之后启<a class="headerlink" href="#unix_unix" title="Permanent link">&para;</a></h5>
<div class="highlight"><pre><span></span><code>动的第一个程序是 init，它知道该启动什么，这是由于 inittab 的存在。
</code></pre></div>
<p>在运行级别改变时，init 读取 inittab，然后控制主进程的启动。
1.文件格式
init进程将查看此文件来启动子进程,完成系统引导./etc/inittab描述了
一个进程是在系统引导时起动还是在系统引导完成后的某个情形下起动.他
也是由一行行的记录组成的.而以 # 开头的行是注释,将被忽略.
记录的格式是:
id:runlevels:action:process
id域是一个由 1 到 4 个字符组成的字符串,这个字符串必需是唯一的,即不
能有两条记录拥有相同的id域.id域是一个标志域,由它区分各条记录.注
意,对于gettys或者其他的login进程来说,id域必须是对应tty的tty后
缀,例如,对于tty1来说,id域应该是1.查看你的 /etc/inittab,会发现类
似下面这样的记录:
.........
1:2345:respawn:/sbin/mingetty tty1
2:2345:respawn:/sbin/mingetty tty2
3:2345:respawn:/sbin/mingetty tty3
.............
runlevels域是一个运行级的列表,可用的运行级有:
0 ---- 停机
1 ---- 单用户模式
2 ---- 不带NFS的多用户模式
3 ---- 完整的多用户模式
4 ---- 没有使用
5 ---- X11
6 ---- 重起系统
S ---- 单用户
s ---- 同S
action域是一个预定义的动作,可用的action有:
respawn
进程终止后立刻重新开始(如getty进程)
wait
进程在进入指定的运行级后起动一次,然后init将等待它的终止
once
进程在进入指定的运行级后起动一次
boot
进程在系统引导时起动,runlevels域将被忽略
bootwait
进程在系统引导时起动,然后init将等待它的终止,runlevels域将被忽略
off
这个action不做任何事
ondemand
有一个特殊的运行级叫做ondemand runlevel,包括a,b和c.如果一个进程
被标记了ondemand runlevel,那么当要求切换到这个ondemand runlevel
时将会起动这个进程.但实际上的runlevel不会改变</p>
<p>initdefault
标记了initdefault这个action的记录项的runlevel域指定了系统引导完
成后进入的运行级
sysinit
在系统引导时起动这个进程.而且在所有的boot和bootwait项之前起
动.process域将被忽略
powerwait
在电力中断时起动这个进程.通常会由一个与连接到计算机的UPS系统对话
的进程通知init电力切断.init在继续之前将等待这个进程结束
powerfail
同powerwait类似,但是init不会等待这个进程结束
powerokwait
一旦init被通知电力已经恢复,将起动这个进程
powerfailnow
当init被告知UPS的电力亦将耗尽时起动这个进程
ctrlaltdel
当init接到SIGINT信号时起动这个进程.一般是按下了ctrl+alt+del这个
组合键
kbrequest
当一个特殊的键盘组合键被按下时起动这个进程
process域指定了将运行的进程,可以有参数.如果这个域以 + 开头,表明
init将为这个进程更新utmp/wtmp记录.
范例:
id:3:initdefault:
系统引导完成后进入运行级 3
si::sysinit:/etc/rc.d/rc.sysinit
系统引导时运行/etc/rc.d/rc.sysinit
l0:0:wait:/etc/rc.d/rc 0
系统进入运行级 0 时执行/etc/rc.d/rc 0,这里 0 是参数
ca::ctrlaltdel:/sbin/shutdown -t3 -r now
捕获到ctrl+alt+del时运行/sbin/shutdown -t3 - r now.如果想禁用
ctrl+alt+del这个组合键,直接删除或注释掉这行
pf::powerfail:/sbin/shutdown -f - h +2 "Power Failure; System
Shutting Down"
电力中断时执行/sbin/shutdown -f - h +2 "Power Failure; System
Shutting Down"
1:2345:respawn:/sbin/mingetty tty1
进入运行级2,3,4或 5 时执行respawn:/sbin/mingetty tty1.注意指定的
action是respawn,这也就是为什么我们在终端下logout后会立刻又出现一
个login提示符
x:5:respawn:/etc/X11/prefdm -nodaemon
进入运行级 5 时执行/etc/X11/prefdm -nodaemon,指定的action是respawm
2.安全性
/etc/inittab的权限是644,所有者和所有组均为root</p>
<h5 id="3_3">3.相关命令<a class="headerlink" href="#3_3" title="Permanent link">&para;</a></h5>
<p><div class="highlight"><pre><span></span><code>init
telinit
更多内容请
man init
man inittab
</code></pre></div>
<div class="highlight"><pre><span></span><code>/etc/termcap 一个数据库，包含所有可能的终端类型以及这些终端的性能。
</code></pre></div></p>
<h5 id="_95">守护进程<a class="headerlink" href="#_95" title="Permanent link">&para;</a></h5>
<h5 id="_96">守护进程是一种运行在非交互模式下的程序。一般来说，守护进程任务是和联网区域有关的：它们等<a class="headerlink" href="#_96" title="Permanent link">&para;</a></h5>
<p>待连接，以便通过连接提供服务。Linux 可以使用从 Web 服务器到 ftp 服务器的很多守护进程。</p>
<p><div class="highlight"><pre><span></span><code>/etc/syslog.conf
</code></pre></div>
<div class="highlight"><pre><span></span><code>syslogd 是一种守护进程，它负责记录（写到磁盘）从其它程序发送到系统
的消息。这个服务尤其常被某些守护进程所使用，这些守护进程不会有另外
的方法来发出可能有问题存在的信号或向用户发送消息。
1.文件格式
/etc/syslog.conf是syslog守护程序的配置文件.syslog守护程序为记录
来自运行于系统之上的程序的消息提供了一种成熟的客户机 -服务器机制。
syslog 接收来自守护程序或程序的消息，根据优先级和类型将该消息分类，
然后根据由管理员可配置的规则将它写入日志。结果是一个健壮而统一的管
理日志的方法。
这个文件由一条条的规则组成.每条规则应该写在一行内.但是如果某行以
反斜线 \ 结尾的话,他的下个物理行将被认为与此行同属于一行.空白行和
以 # 开始的行将被忽略.
每条规则都是下面这种形式:
facility.priority[;facility.priority .....] action
facility和priority之间用一个英文句点分隔.他们的整体称为selector.
每条规则可以有多个selector,selector之间用分号隔开. 而selector和
action之间则用空格或者tab隔开.
facility 指定 syslog 功能，主要包括以下这些：
auth 由 pam_pwdb 报告的认证活动。
authpriv 包括特权信息如用户名在内的认证活动
cron 与 cron 和 at 有关的信息。
daemon 与 inetd 守护进程有关的信息。
kern 内核信息，首先通过 klogd 传递。
lpr 与打印服务有关的信息。
mail 与电子邮件有关的信息
mark syslog 内部功能用于生成时间戳
news 来自新闻服务器的信息
syslog 由 syslog 生成的信息
user 由用户程序生成的信息
uucp 由 uucp 生成的信息
local0----local7 与自定义程序使用，例如使用 local5 做为 ssh 功能
</code></pre></div></p>
<ul>
<li>通配符代表除了 ma rk 以外的所有功能
priority指定消息的优先级. 与每个功能对应的优先级是按一定顺序排列
的，emerg 是最高级，其次是 alert，依次类推。缺省时，在
/etc/syslog.conf 记录中指定的级别为该级别和更高级别。如果希望使用
确定的级别可以使用两个运算符号！(不等)和=。
user.=info
表示告知 syslog 接受所有在 info 级别上的 user 功能信息。
可用的 syslog 优先级如下:
emerg 或 panic 该系统不可用
alert 需要立即被修改的条件
crit 阻止某些工具或子系统功能实现的错误条件
err 阻止工具或某些子系统部分功能实现的错误条件
warning 预警信息
notice 具有重要性的普通条件
info 提供信息的消息
debug 不包含函数条件或问题的其他信息
none 没有重要级，通常用于排错</li>
<li>所有级别，除了none
action字段所表示的活动具有许多灵活性，特别是，可以使用名称管道的作
用是可以使 syslogd 生成后处理信息。
syslog 主要支持以下action
file
指定文件的绝对路径,如: /var/log/messages. log信息将写到此文件中
terminal 或 printer
完全的串行或并行设备标志符,如/dev/console. log信息将送到此设备
@host
远程的日志服务器. log信息将送到此日志服务器
username
发送信息给指定用户
named pipe
指定使用 mkfifo 命令来创建的 FIFO 文件的绝对路径。
如果对此文件作了改动, 想要使改动生效，您需要向 syslog 守护程序通知
所做的更改。向它发送 SIGHUP 是个正确的办法，您可以用 killall 命令
轻松地做到这一点：</li>
</ul>
<h1 id="killall_-hup_syslogd">killall -HUP syslogd<a class="headerlink" href="#killall_-hup_syslogd" title="Permanent link">&para;</a></h1>
<p>2.安全性
您应该清楚如果 syslogd 写的日志文件还不存在的话，程序将创建它们。
无论您当前的 umask 如何设置，该文件将被创建为可被所有用户读取。如
果您关心安全性，那么您应该用 chmod 命令将该文件设置为仅 root 用户
可读写。此外，可以用适当的许可权配置 logrotate 程序（在下面描述）
以创建新的日志文件。syslog 守护程序始终会保留现有日志文件的当前属
性，因此一旦创建了文件，您就不需要担心它。
3.相关命令
logrotate</p>
<p><div class="highlight"><pre><span></span><code>klogd
syslogd
dmesg
</code></pre></div>
<div class="highlight"><pre><span></span><code>/etc/httpd.conf
</code></pre></div>
<div class="highlight"><pre><span></span><code>Web 服务器 Apache 的配置文件。这个文件一般不在 /etc 中。它可能在
/usr/local/httpd/conf/ 或 /etc/httpd/conf/ 中，但是要确定它的位置，
您还需要检查特定的 Apache 安装信息。
/etc/conf.modules
or
/etc/modules.conf
</code></pre></div>
<div class="highlight"><pre><span></span><code>kerneld 的配置文件。有意思的是，kerneld 并不是“作为守护进程的”内
核。它其实是一种在需要时负责“快速”加载附加内核模块的守护进程。
</code></pre></div>
用户程序
在 Linux（和一般的 UNIX）中，有无数的“用户”程序。最常见的一种用户程序配置文件是
/etc/lynx.cfg。这是著名的文本浏览器 lynx 的配置文件。通过这个文件，您可以定义代理服务器、
要使用的字符集等等。下面的代码样本展示了 lynx.cfg 文件的一部分，修改这部分代码可以改变
Linux 系统的代理服务器设置。缺省情况下，这些设置适用于在各自的 shell 中运行 lynx 的所有
用户，除非某个用户通过指定 --cfg = "mylynx.cfg" 重设了缺省的配置文件。
/etc/lynx.cfg 中的代理服务器设置</p>
<div class="highlight"><pre><span></span><code>.h1 proxy
.h2 HTTP_PROXY
.h2 HTTPS_PROXY
.h2 FTP_PROXY
.h2 GOPHER_PROXY
.h2 NEWS_PROXY
.h2 NNTP_PROXY
# Lynx version 2.2 and beyond supports the use of proxy servers that can act as
# firewall gateways and caching servers. They are preferable to the older
# gateway servers. Each protocol used by Lynx can be mapped separately using
# PROTOCOL_proxy environment variables (see Lynx Users Guide). If you have
# not set them externally, you can set them at run time via this configuration file.
# They will not override external settings. The no_proxy variable can be used
# to inhibit proxying to selected regions of the Web (see below). Note that on
# VMS these proxy variables are set as process logicals rather than symbols, to
# preserve lowercasing, and will outlive the Lynx image.
#
.ex 15
http_proxy:http://proxy3.in.ibm.com:80/
ftp_proxy:http://proxy3.in.ibm.com:80/
#http_proxy:http://penguin.in.ibm.com:8080
#ftp_proxy:http://penguin.in.ibm.com:8080/
.h2 NO_PROXY
# The no_proxy variable can be a comma-separated list of strings defining
# no-proxy zones in the DNS domain name space. If a tail substring of the
# domain-path for a host matches one of these strings, transactions with that
</code></pre></div>
<div class="highlight"><pre><span></span><code># node will not be proxied.
.ex
no_proxy:demiurge.in.ibm.com, demiurge
</code></pre></div>
<h5 id="_97">更改配置文件<a class="headerlink" href="#_97" title="Permanent link">&para;</a></h5>
<h5 id="_98">在更改配置文件时，如果程序不是由系统管理员或内核控制的，就要确保重新启动过使用该配置的程<a class="headerlink" href="#_98" title="Permanent link">&para;</a></h5>
<h5 id="_99">序。普通用户通常没有启动或停止系统程序和／或守护进程的权限。<a class="headerlink" href="#_99" title="Permanent link">&para;</a></h5>
<h5 id="_100">内核<a class="headerlink" href="#_100" title="Permanent link">&para;</a></h5>
<p>更改内核中的配置文件会立即影响到系统。例如，更改 passwd 文件以增加用户将立即使该用户变为
可用。而且任何 Linux 系统的 /proc/sys 目录中都有一些内核可调参数。只有超级用户可以得到对
所有这些文件的写访问权力；其它用户只有只读访问权力。此目录中文件的分类的方式和 Linux 内
核源代码的分类方式一样。此目录中的每个文件都代表一个内核数据结构，这些数据结构可以被动态
地修改，从而改变系统性能。
注意：在更改其中任何文件的任何值之前，您应该确保自己全面了解该文件，以避免对系统造成不可
修复的损害。
/proc/sys/kernel/ 目录中的文件</p>
<p><div class="highlight"><pre><span></span><code>文件名 描述
threads-max 内核可运行的最大任务数。
</code></pre></div>
<div class="highlight"><pre><span></span><code>ctrl-alt-del
</code></pre></div></p>
<h5 id="1_19">如果值为 1 ，那么顺序按下这几个键将“彻底地”重新引<a class="headerlink" href="#1_19" title="Permanent link">&para;</a></h5>
<h5 id="_101">导系统。<a class="headerlink" href="#_101" title="Permanent link">&para;</a></h5>
<p><div class="highlight"><pre><span></span><code>sysrq 如果值为 1 ，Alt-SysRq 则为激活状态。
osrelease 显示操作系统的发行版版本号
ostype 显示操作系统的类型。
hostname 系统的主机名。
domainname 网络域，系统是该网络域的一部分。
</code></pre></div>
modprobe
指定 modprobe 是否应该在启动时自动运行并加载必需
的模块。
守护进程和系统程序
守护进程是永远运行在后台的程序，它默默地执行自己的任务。常见的守护进程有 in.ftpd（ftp 服
务器守护进程）、in.telnetd（telnet 服务器守护进程）和 syslogd（系统日志记录守护进程）。
有些守护进程在运行时会严密监视配置文件，在配置文件改变时就会自动重新加载它。但是大多数守
护进程并不会自动重新加载配置文件。我们需要以某种方式“告诉”这些守护进程配置文件已经被发
生了改变并应该重新加载。可以通过使用服务命令重新启动服务来达到这个目的（在 Red Hat Linux
系统上）。
例如，如果我们更改了网络配置，就需要发出：
service network restart 。
注意：这些服务最常见的是 /etc/rc.d/init.d/* 目录中存在的脚本，在系统被引导时由 init 启动。
所以，您也可以执行如下操作来重新启动服务：
/etc/rc.d/init.d/<script-for-the- service> start | stop | status
start、stop 和 status 是这些脚本接受的输入值，用来执行操作。
用户程序</p>
<h5 id="_102">用户或系统程序在每次启动时都会读取其配置文件。尽管如此，请记住，有些系统程序在计算机打开<a class="headerlink" href="#_102" title="Permanent link">&para;</a></h5>
<p>时情况不一样，它们的行为依赖于在 /etc/ 中的配置文件中读到的内容。所以，用户程序第一次启
动时将从 /etc/ 目录中存在的文件读取缺省配置。然后，用户可以通过使用 rc 和 .（点）文件来
定制程序，正如下面一节所示。
用户配置文件：.（点）文件和 rc 文件
我们已经看到怎样容易地配置程序。但是如果有的人不喜欢在 /etc/ 中配置程序的方式该怎么办呢？
“普通”用户不能简单地进入 /etc 然后更改配置文件；从文件系统的角度来看，配置文件的所有者
是 root 用户！这就是大多数用户程序都定义两个配置文件的原因：第一个是“系统”级别的，位于
/etc/；另一个属于用户“专用”，可以在他或她的主目录中找到。
例如，我在我的系统中安装了非常有用的 wget 实用程序。/etc/ 中有一个 /etc/wgetrc 文件。在
我的主目录中，有一个名为 .wgetrc 的文件，它描述了我定制的配置（只有在我，也就是用户运行
wget 命令时，才会加载这个配置文件）。其它用户在他们自己的主目录（/home/other）中也可以
有 .wgetrc 文件；当然，只有这些用户运行 wget 命令时，才会读取这个文件。换句话说，/etc/wgetrc
文件为 wget 提供了“缺省”值，而 /home/xxx/.wgetrc 文件列举了某个用户的“定制项”。重要
的是这只是“一般规则”，并非所有情况都如此。例如，一个象 pine 一样的程序，在 /etc/ 中并
没有任何文件，它只在用户主目录中有一个定制配置文件，名为 .pinerc。其它程序可能只有 /etc/
中的缺省配置文件，而且可能不允许用户“定制”这些配置文件（/etc 目录中只有少数 config. 文
件是这种情况）。
通常使用的 rc 和 .（点）文件
文件名 描述</p>
<p><div class="highlight"><pre><span></span><code>~/.bash_login
</code></pre></div>
<div class="highlight"><pre><span></span><code>请参考“man bash”。如果
~/.bash_profile 不存在，bash 则将
~/.bash_login 作为
~/.bash_profile 处理。
</code></pre></div>
<div class="highlight"><pre><span></span><code>~/.bash_logout
请参考“man bash”。在退出时由
bash 登录 shell 引用。
</code></pre></div>
<div class="highlight"><pre><span></span><code>~/.bash_profile 由 bash 登录 shell 引用^
/etc/profile 之后引用。
~/.bash_history 先前执行的命令的列表。
</code></pre></div>
<div class="highlight"><pre><span></span><code>~/.bashrc
</code></pre></div>
<div class="highlight"><pre><span></span><code>请参考“man bash”。由 bash 非登
录交互式 shell 引用（没有其它文
件）。除非设置了 BASH_ENV 或 ENV，
非交互式 shell 不引用任何文件。
~/.emacs 启动时由 emac 读取。
</code></pre></div>
<div class="highlight"><pre><span></span><code>~/.forward
</code></pre></div></p>
<h5 id="_103">如果这里包含一个电子邮件地址，那<a class="headerlink" href="#_103" title="Permanent link">&para;</a></h5>
<h5 id="_104">么所有发往 ~ 的所有者的邮件都会<a class="headerlink" href="#_104" title="Permanent link">&para;</a></h5>
<h5 id="_105">被转发到这个电子邮件地址。<a class="headerlink" href="#_105" title="Permanent link">&para;</a></h5>
<p><div class="highlight"><pre><span></span><code>~/.fvwmrc ~/.fvwm2rc
fvwm 和 fvwm2（基本的 X Window 管
理器）的配置文件。
</code></pre></div>
<div class="highlight"><pre><span></span><code>~/.hushlogin
</code></pre></div>
<div class="highlight"><pre><span></span><code>请参考“man login”。引起“无提
示”登录（没有邮件通知、上次登录
信息或者 MOD 信息）。
</code></pre></div></p>
<p>~/.mail.rc 邮件程序的用户初始化文件。</p>
<p>~/.ncftp/</p>
<p><div class="highlight"><pre><span></span><code>ncftp 程序的目录；包含书签、日志、
宏、首选项和跟踪信息。请参阅 man
ncftp。ncftp 的目的是为因特网标准
文件传输协议（Internet standard
File Transfer Protocol）提供一个
强大而灵活的接口。它旨在替换系统
所使用的标准的 ftp 程序。
</code></pre></div>
~/.profile</p>
<p><div class="highlight"><pre><span></span><code>请参考“man bash”。如果
~/.bash_profile 和 ~/.bash_login
文件不存在，bash 则将 ~/.profile
作为 ~/.bash_profile 处理，并被其
它继承 Bourn 的 shell 使用。
</code></pre></div>
~/.pinerc Pine 配置</p>
<p>~/.muttrc Mutt 配置</p>
<p>~/.exrc</p>
<p><div class="highlight"><pre><span></span><code>这个文件可以控制 vi 的配置。
示例：set ai sm ruler
在此文件中写入上面一行会让 vi 设
置自动缩进、匹配括号、显示行号和
行-列这几个选项。
</code></pre></div>
~/.vimrc
缺省的“Vim” 配置文件。和 .exrc
一样。</p>
<p>~/.gtkrc GNOME 工具包（GNOME Toolkit）。</p>
<p>~/.kderc KDE 配置。</p>
<p>~/.netrc ftp 缺省登录名和密码。</p>
<p>~/.rhosts</p>
<p><div class="highlight"><pre><span></span><code>由 r- 工具（如 rsh、rlogin 等等）
使用。因为冒充主机很容易，所以安
全性非常低。
</code></pre></div>
1. 必须由用户（~/ 的所有者）或超
    级用户拥有。
2. 列出一些主机，用户可以从这些主
    机访问该帐号。
3. 如果是符号链接则被忽略。</p>
<p>~/.rpmrc
请参阅“man rpm”。如 果 /etc/rpmrc
不存在则由 rpm 读取。</p>
<p>~/.signature</p>
<h5 id="_106">消息文本，将自动附加在从此帐号发<a class="headerlink" href="#_106" title="Permanent link">&para;</a></h5>
<h5 id="_107">出的邮件末尾。<a class="headerlink" href="#_107" title="Permanent link">&para;</a></h5>
<p>~/.twmrc
twm（ The Window Manager）的配置
文件。</p>
<p><div class="highlight"><pre><span></span><code>~/.xinitrc
</code></pre></div>
<div class="highlight"><pre><span></span><code>启动时由 X 读取（而不是由 xinit
脚本读取）。通常会启动一些程序。
示例：exec /usr/sbin/startkde
如果该文件中存在上面这行内容，那
么在从这个帐号发出 startx 命令
时，这一行就会启动“KDE 视窗管理
器”（KDE Window Manager）。
</code></pre></div>
<div class="highlight"><pre><span></span><code>~/.xmodmaprc
</code></pre></div>
<div class="highlight"><pre><span></span><code>此文件被传送到 xmodmap 程序，而且
可以被命名为任何文件（例如
~/.Xmodmap 和 ~/.keymap.km）。
</code></pre></div>
<div class="highlight"><pre><span></span><code>~/.xserverrc
</code></pre></div>
<div class="highlight"><pre><span></span><code>如果 xinit 可以找到要执行的 X，
xinit 就会将该文件作为 X 服务器
运行。
~/News/Sent-Message-IDs gnus 的缺省邮件历史文件。
</code></pre></div>
<div class="highlight"><pre><span></span><code>~/.Xauthority
由 xdm 程序读和写，以处理权限。请
参阅 X、xdm 和 xauth 联机帮助页。
</code></pre></div>
<div class="highlight"><pre><span></span><code>~/.Xdefaults,
~/.Xdefaults-hostname
</code></pre></div>
<div class="highlight"><pre><span></span><code>在主机 hostname 的启动过程中由 X
应用程序读取。如果找不到
-hostname 文件，则查找 .Xdefaults
文件。
</code></pre></div>
<div class="highlight"><pre><span></span><code>~/.Xmodmap
指向 .xmodmaprc；Red Hat 有使用这
个名称的 .xinitrc 文件。
</code></pre></div>
<div class="highlight"><pre><span></span><code>~/.Xresources
</code></pre></div>
<div class="highlight"><pre><span></span><code>通常是传送到 xrdb 以加载 X 资源
数据库的文件的名称，旨在避免应用
程序需要读取一个很长
的 .Xdefaults 文件这样的情况。（有
些情况曾经使用了 ~/.Xres。）
~/mbox 用户的旧邮件。
</code></pre></div></p>
<h4 id="3_4">3 、重要的配置文件列表：<a class="headerlink" href="#3_4" title="Permanent link">&para;</a></h4>
<h5 id="_108">启动引导程序配置文件<a class="headerlink" href="#_108" title="Permanent link">&para;</a></h5>
<div class="highlight"><pre><span></span><code>LILO /etc/lilo.conf
GRUB /boot/grub/menu.lst
系统启动文件核脚本
主启动控制文件 /etc/inittab
SysV启动脚本的位置 /etc/init.d、/etc/rc.d/init.d或/etc/rc.d
SysV启动脚本链接的位置 /etc/init.d/rc?.d、/etc/rc.d/rc?.d或/etc/rc?.d
本地启动脚本 /etc/rc.d/rc.local、/etc/init.d/boot.local或/etc/rc.boot里的文件
网络配置文件
建立网络接口的脚本 /sbin/ifup
保存网络配置数据文件的目录 /etc/network、/etc/sysconfig/network和
/etc/sysconfig/network-scripts
</code></pre></div>
<p>保存解析DNS服务的文件 /etc/resolv.conf
DHCP客户端的配置文件 /etc/dhclient.conf
超级服务程序配置文件和目录
inetd配置文件 /etc/inetd.conf
TCP Wrappers配置文件 /etc/hosts.allow和/etc/hosts.deny
xinetd配置文件 /etc/xinetd.conf和/etc/xinetd.d目录里的文件
硬件配置
内核模块配置文件 /etc/modules.conf
硬件访问文件
Linux设备文件 /dev目录里
保存硬件和驱动程序数据的文件 /proc目录里
扫描仪配置文件
SANE主配置 /etc/sane.d/dll.conf
特定扫描仪的配置文件 /etc/sane.d目录里以扫描仪型号命名的文件
打印机配置文件
BSD LPD核LPRng的本地打印机主配置文件 /etc/printcap
CUPS本地打印机主配置和远程访问受权文件 /etc/cups/cupsd.conf
BSD LPD远程访问受权文件 /etc/hosts.lpd
LPRng远程访问受权文件 /etc/lpd.perms
文件系统
文件系统表 /etc/fstab
软驱装配点 /floppy、/mnt/floppy或/media/floppy
光驱装配点 /cdrom、/mnt/cdrom或/media/cdrom
shell配置文件
bash系统非登录配置文件 /etc/bashrc、/etc/bash.bashrc或/etc/bash.bashrc.local
bash系统登录文件 /etc/profile和/etc/profile.d里的文件
bash用户非登录配置文件 ~/.bashrc
bash用户登录配置文件 ~/.profile
XFree86配置文件核目录
XFree86主配置文件 /etc/XF86config、/etc/X11/XF86Config或/etc/X11/XF86Config-4
字体服务程序配置文件 /etc/X11/fs/config
Xft 1.x配置文件 /etcX11/XftConfig
Xft 2.0配置文件 /etc/fonts/fonts.conf
字体目录 /usr/X11R6/lib/X11/fonts和/usr/share/fonts
Web服务程序配置文件
Apache主配置文件 /etc/apache、/etc/httpd或/httpd/conf里的httpd.conf或httpd2.conf文
件
MIME类型文件 与Apache主配置文件在同一目录里的mime.types或apache-mime.types
文件服务程序配置文件
ProFTPd配置文件 /etc/proftpd.conf
vsftpd配置文件 /etc/vsftpd.conf
NFS服务程序的输出定义文件 /etc/exports
NFS客户端装配的NFS输出 /etc/fstab
Samba配置文件 /etc/samba/smb.conf</p>
<div class="highlight"><pre><span></span><code>Samba用户配置文件 /etc/samba/smbpasswd
邮件服务程序配置文件
sendmail主配置文件 /etc/mail/sendmail.cf
sendmail源配置文件 /etc/mail/sendmail.mc或/usr/share/sendmail/cf/cf/linux.smtp.mc或
其他文件
Postfix主配置文件 /etc/postfix/main.cf
Exim主配置文件 /etc/exim/exim.cf
Procmail配置文件 /etc/procmailrc或~/.procmailrc
Fetchmail配置文件 ~/.fetchmailrc
远程登录配置文件
SSH服务程序配置文件 /etc/ssh/sshd_config
SSH客户端配置文件 /etc/ssh/ssh_config
XDM配置文件 /etc/X11/xdm目录下
GDM配置文件 /etc/X11/gdm目录下
VNC服务程序配置文件 /usr/X11R6/bin/vncserver启动脚本和~/.vnc目录里的文件
其他服务程序配置文件
DHCP服务程序配置文件 /etc/dhcpd.conf
BIND服务程序配置文件 /etc/named.conf和/var/named/
NTP服务程序配置文件 /etc/ntp.conf
</code></pre></div>
<h2 id="_109">十六、 计划任务<a class="headerlink" href="#_109" title="Permanent link">&para;</a></h2>
<h5 id="_110">在很多时候为了自动化管理系统，我们都会用到计划任务，比如关机，管理，备份之类的操作，我<a class="headerlink" href="#_110" title="Permanent link">&para;</a></h5>
<h5 id="_111">们都可以使用计划任务来完成，这样可以是管理员的工作量大大降低，而且可靠度更好。<a class="headerlink" href="#_111" title="Permanent link">&para;</a></h5>
<p>linux系统支持一些能够自动执行任务的服务，我们称为计划任务。
LINUX有如下三种计划任务：
at：指定一个时间执行一个任务 （适用一个或多个任务，执行一次后就不用）
cron：根据一个时间表自动执行任务 （使用一个或多个任务，周期性执行）
系统级别的计划任务及其扩展anacron：在一个指定时间间隔错过后自动执行任务</p>
<h4 id="1_at_atd">1 、 at: 安排一个任务在未来执行，需要一个 atd 的系统后台进程<a class="headerlink" href="#1_at_atd" title="Permanent link">&para;</a></h4>
<p>检查 <strong>atd</strong> 进程是否启动
[root@centos61 桌面]# service atd status
atd (pid 2274) 正在运行...
[root@centos61 桌面]# chkconfig |grep atd
atd 0:关闭 1:关闭 2:关闭 3:启用 4:启用 5:启用 6:关闭
如果未启动，可以使用如下命令：
[root@centos61 桌面]# service atd start
正在启动 atd： [确定]
[root@centos61 桌面]# chkconfig atd on
常用指令: at:安排延时任务
具体使用方法:
例1:</p>
<h1 id="at_now2_minutes">at now+2 minutes 回车<a class="headerlink" href="#at_now2_minutes" title="Permanent link">&para;</a></h1>
<blockquote>
<p>输入要执行的命令</p>
<p>ctrl+d 结束输入
[root@test ~]# at now+2 minutes
at&gt; wall Aixi
at&gt; <EOT>
job 2 at 2010-06-18 16:36
<EOT>是ctrl+d中断输入，这个命令意思是发送一个广播内容是Hello Aixi.具体时间可以改,单位可
以改,可以用hours,months,years,weeks等.
例 2 我们还可以跟具体时间
[root@test ~]# at 16:39 dec 10
at&gt; Hello Aixi
at&gt; <EOT> ctrl+d结束输入
job 3 at 2010-12-10 16:39
意思是在今年的 12 月 10 日16:39运行这个命令.如果不加月和日,默认就是今天.
Atq:查询当前的等待任务
用atq来查询，已经运行的任务，就消失了。这就是at计划任务的重点，只运行一次</p>
</blockquote>
<p>atrm：删除等待任务
启动计划任务后，如果不想启动设定好的计划任务可以使用atrm命令删除。
格式：atrm 任务号
命令后面跟计划任务编号，如果不跟，就会删除这个用户所有的计划任务。
例 3
atrm 10 //删除计划任务 10
atq //查看计划任务是否删除</p>
<p>at将要运行的命令以文本形式写入/var/spool/at/目录内，等待atd服务的取用和执行。
还可以进入到/var/spool/at目录里把计划任务删除，计划任务的文件都保存在该目录里，可以用rm -f
文件名来删除(以文件的形式删除计划任务，因为计划任务是以文件形式保存在该目录中)
例4:</p>
<h1 id="cd_varspoolat_varspoolat">cd /var/spool/at //进入到/var/spool/at目录中<a class="headerlink" href="#cd_varspoolat_varspoolat" title="Permanent link">&para;</a></h1>
<p>ls //显示目录中所有文件
rm -f a0000b0138b19c //删除计划任务</p>
<p>在通常情况下，超级用户都可以使用这个命令。对于其他用户来说，能否可以使用就取决于两个文
件:/etc/at.allow和/etc/at.deny。
at 命令是可以基于用户来控制的，我们可以明确指定哪些用户可以使用at计划任务，哪些用户不可以
使用at计划任务。
at的控制文件
/etc/at.allow
/etc/at.deny
系统默认是有at.deny文件，如果某个用户名在这个文件里，他就不能使用at计划任务。如果有
at.allow文件，allow文件先行，检查了allow明确允许，就不会检查deny。</p>
<p>如果你要让哪个用户不能使用计划任务，就直接把他的用户名写进去就可以了，一排只能写一个。</p>
<h4 id="2_cron_httpwwwlinuxsirorgmainqnode209">2 、 cron 服务 ( 参考网址： <a href="http://www.linuxsir.org/main/?q=node/209">http://www.linuxsir.org/main/?q=node/209</a>)<a class="headerlink" href="#2_cron_httpwwwlinuxsirorgmainqnode209" title="Permanent link">&para;</a></h4>
<p>相对与at，cron的优点就是能够周期性的执行某个命令,at却只能执行一次，cron的后台进程名字
是crond ,cron也是system V的服务，所以我们可以service crond start|stop 来启动和关闭此服
务,也可以使用chkconfig或者ntsysv来选择cron服务的默认开启，这些命令在以前我们都讲过的
命令：</p>
<h1 id="crontab_-e_cron">crontab -e 编辑当前用户的cron表<a class="headerlink" href="#crontab_-e_cron" title="Permanent link">&para;</a></h1>
<h1 id="crontab_-l_cron">crontab -l 查看当前用户的cron表<a class="headerlink" href="#crontab_-l_cron" title="Permanent link">&para;</a></h1>
<h1 id="crontab_-r_cron">crontab -r 删除当前用户的cron进程<a class="headerlink" href="#crontab_-r_cron" title="Permanent link">&para;</a></h1>
<h1 id="crontab_-u_cron">crontab -u 用户名 以某用户的身份来控制cron表<a class="headerlink" href="#crontab_-u_cron" title="Permanent link">&para;</a></h1>
<p>还有个重要的知识点，就是当用户的计划任务建立后是存放在var/spool/cron这个目录
当使用crontab -e编辑当前用户的cron表后，会出现一个vi文件，cron的格式是这样的。分成两
列，左边是时间，右边是运行的命令。时间是由 5 个部分组成。
例：
* * * * * wall hello everyone
5 个星号分别代表：minute hour day-of- month month-of-year day-of- week ，而wall hello
everyone 这是命令内容。上面的意识是每分每小时每天每月每周广播hello everyone。具体时间大
家可以自己定义。如果要每两分钟发送就用*/2代替第一个*。也可以是用具体时间来表示。
我们使用crontab -e编辑当前用户的cron表
这里的 5 个星号就代表的时间和日期：
第一个*星号代表个小时的第几分钟：minute 范围是从0-59
第二个*星号代表每天的第几个小时：hour 范围是从0-23
第三个*星号代表每月的第几个日：day -of -month 范围从1-31
第四个*星号代表没年的第几个月：month-of-year 范围从1-12
第五个*星号代表每周的星期几：day-of-week 范围从0-6，其中 0 表示星期日
用户名：也就是执行程序要通过哪个用户来执行，这个一般可以省略；
命令：执行的命令和参数。
时程表的格式如下 :
f1 f2 f3 f4 f5 program
其中 f1 是表示分钟，f2 表示小时，f3 表示一个月份中的第几日，f4 表示月份，f5 表示一个星期
中的第几天。program 表 示要执行的程序。
当 f1 为 * 时表示每分钟都要执行 program，f2 为 * 时表示每小时都要执行程序，其余以此类推
当 f1 为 a -b 时表示从第 a 分钟到第 b 分钟这段时间内要执行，f2 为 a -b 时表示从第 a 到第 b
小时都要执行，其余以此类推
当 f1 为 */n 时表示每 n 分钟个时间间隔执行一次，f2 为 */n 表示每 n 小时个时间间隔执行一
次，其余以此类推
当 f1 为 a, b, c,... 时表示第 a, b, c,... 分钟要执行，f2 为 a, b, c,... 时表示第 a, b, c...
个小时要执行，其余以此类推
使用者也可以将所有的设定先存放在档案 file 中，用 cr ontab file 的方式来设定时程表。
例 1 ：如果我要表示 9 月 10 日 25 分执行ls var/spool/cron任务怎么表示？
25 * 10 9 * ls var/spool/cron
由于我没表示小时，所以就只能里面为每小时
例 2 ：我要在每周日，每分钟执行wall Hello redking.blog.51cto.com这个命令，时间怎么表示？
*/1 * * * 0 wall Hello redking.blog.51cto.com
*/ 表示每多少分钟执行一次</p>
<p>例 3 ： 每晚的21:30重启apache。
30 21 * * * /usr/local/etc/rc.d/lighttpd restart
例 4 ：每月 1 、 10 、 22 日的4 : 45重启apache
45 4 1,10,22 * * /usr/local/etc/rc.d/lighttpd restart
例 5 ：每周六、周日的1 : 10重启apache
10 1 * * 6,0 /usr/local/etc/rc.d/lighttpd restart
例 6 ：在每天18 : 00至23 : 00之间每隔 30 分钟重启apache
0,30 18-23 * * * /usr/local/etc/rc.d/lighttpd restart
例 7 ：每一小时重启apache
* */1 * * * /usr/local/etc/rc.d/lighttpd restart
例 8 ：晚上 11 点到早上 7 点之间，每隔一小时重启apache
* 23-7/1 * * * /usr/local/etc/rc.d/lighttpd restart
例 9 ：每月的 4 号与每周一到周三的 11 点重启apache
0 11 4 * mon-wed /usr/local/etc/rc.d/lighttpd restart
例 10 ：一月一号的 4 点重启apache
0 4 1 jan * /usr/local/etc/rc.d/lighttpd restart
例 11 ：在 12 月内, 每天的早上 6 点到 12 点中，每隔 3 个小时执行一次 /usr/bin/backup
0 6-12/3 * 12 * /usr/bin/backup
例 12 ：每月每天的午夜 0 点 20 分, 2 点 20 分, 4 点 20 分....执行 echo "haha"
20 0-23/2 * * * echo "haha"</p>
<h4 id="3_anacrontab">3 、系统级别的计划任务及其扩展 anacrontab<a class="headerlink" href="#3_anacrontab" title="Permanent link">&para;</a></h4>
<h5 id="_112">这个是系统设置好了，清理系统垃圾或者是自动执行某些脚本的系统任务，一般我们做了解就行了，<a class="headerlink" href="#_112" title="Permanent link">&para;</a></h5>
<p>不要更改配置文件是/etc/conrtab</p>
<p>SHELL：就是运行计划任务的解释器，默认是bash
PATH：执行命令的环境变量
MAILTO：计划任务的出发者用户
HOME：家目录为/
run-parts是一个脚本，在/usr/bin/run-parts，作用是执行一个目录下的所有脚本/程序。
run-parts /etc/cron.hourly执行目录/etc/cron.hourly/之下的所有脚本/程序.
run-parts下面就是运行的命令
vim /etc/crontab 与crontab -e写入的定时运行的区别?
vim /etc/crontab：是系统级别定义的crontab，/etc/crontab的所有者和组都是root
crontab -e ：是用户自定义的crontab，是所有的用户都可以写入的</p>
<p><div class="highlight"><pre><span></span><code>两种方法记录的位置不一样，一个在/etc/ 另一个在/var/ 里面。都被cron服务调用
如果系统在以上说的时间没有开机怎么办？那么这个脚本不就是不能执行了？设计者早就想到了这个
问题，所以就有了cron服务的扩展,目的就是为了防止非 24 小时开机的计算机遗漏的守护任务,anacr
ontab就是系统计划任务的扩展文件：在一个指定时间间隔错过后自动执行任务
格式是这样的：
period delay job -identifier command
period — 命令执行的频率（天数）
delay — 延迟时间（分钟）
job-identifier — 任务的描述，用在 anacron 的消息中，并作为作业时间戳文件的名称，只能包括
非空白的字符（除斜线外）。
command — 要执行的命令
</code></pre></div>
<div class="highlight"><pre><span></span><code>第一行的意思是：每天开机 65 分钟后就检查cron.daily文件是否被执行了，如果今天没有被执行就执
行他
第二行的意思是：每隔 7 天开机后 70 分钟检查cron.weekly文件是否被执行了,如果一周内没有被执行
就执行他
第三行的意思也差不多
下面说说关于cron服务的控制，和at差不多，就是/etc/cron.deny这个配置文件来控制，里面写入
要禁止使用cron用户的名字，一行一个就OK了
</code></pre></div></p>
<h2 id="vivim">十七、 VI/VIM编辑器<a class="headerlink" href="#vivim" title="Permanent link">&para;</a></h2>
<h5 id="_113">常用快捷键：<a class="headerlink" href="#_113" title="Permanent link">&para;</a></h5>
<p>Ctrl+f 向下翻页
Ctrl+b 向上翻页
G 移动到文件最后一行
gg 移动到文件第一行
N+回车 N为数字，向下移到到N行
/关键字 向下寻找关键字
?关键字 向上寻找关键字</p>
<h1 id="_114">从光标向后查找光标所在 关键词<a class="headerlink" href="#_114" title="Permanent link">&para;</a></h1>
<ul>
<li>从光标向前查找光标所在 关键词
n 向下重复上一次查找操作
N 与n相反，反向重复上一次查找操作</li>
</ul>
<p>:n1,n2s/关键字1/关键字2/g 从第n1与n2行之间寻找关键字 1 ，并将关键字 1 替换为关键字 2
:1,<span class="arithmatex"><span class="MathJax_Preview">s/关键字1/关键字2/g 从第 1 行到最后一行寻找关键字 1 ，并将关键字 1 替换为关键字 2
:1,</span><script type="math/tex">s/关键字1/关键字2/g 从第 1 行到最后一行寻找关键字 1 ，并将关键字 1 替换为关键字 2
:1,</script></span>s/关键字1/关键字2/gc 从第 1 行到最后一行寻找关键字 1 ，将关键字 1 替换为关键字 2 前会提示用
户确认是否替换
dd 删除整行
ndd n为数字，删除光标所在向下n行。
yy 复制光标所在行
nyy n为数字，复制光标所在向下n行
p,P 小p将复制的数据在光标下一行粘贴，大P将复制的数据在光标上一行粘贴
u 撤消前一个操作
Ctrl+r 重做上一个操作</p>
<p>. 将会重复上一个命令
i：在当前字符的左边插入
I：在当前行首插入
a：在当前字符的右边插入
A：在当前行尾插入
o：在当前行下面插入一个新行
O：在当前行上面插入一个新行
:w 保存数据
:wq 保存退出
:q! 不保存退出
:w文件名 相当于另存为</p>
<h2 id="_115">十八、 压缩打包<a class="headerlink" href="#_115" title="Permanent link">&para;</a></h2>
<p>linux下的压缩 命令有tar、gzip、gunzip、bzip2、bunzip2、 compress、uncompress、zip、unzip、rar、
unrar等等 ，压缩后的扩展名有.tar、.gz、. t a r. g z、. tgz、.bz2、.tar.bz2、.Z、.tar.Z、.zip、.rar 10种。
对应关系如下：
1 、<em>.tar 用 tar –xvf 解压
2 、</em>.gz 用 gzip -d或者gunzip 解压
3 、<em>. t a r. g z和</em>.tgz 用 tar –xzf 解压
4 、<em>.bz2 用 bzip2 -d或者用bunzip2 解压
5 、</em>.tar.bz2用tar –xjf 解压
6 、<em>.Z 用 uncompress 解压
7 、</em>.tar.Z 用tar –xZf 解压
8 、<em>.rar 用 unrar e解压
9 、</em>.zip 用 unzip 解压
在介绍压缩文件之前呢，首先要弄清两个概念：打包和压缩。打包是指将一大堆文件或目录什么的变成
一个总的文件，压缩则是将一个大的文件通过一些压 缩算法变成一个小文件。为什么要区分这两个概念呢?
其实这源于Linux中的很多压缩程序只能针对一个文件进行压缩，这样当你想要压缩一大堆文件时，你就得
先借助另它的工具将这一大堆文件先打成一个包，然后再就原来的压缩程序进行压缩。</p>
<h4 id="gzipzcat">Gzip/zcat<a class="headerlink" href="#gzipzcat" title="Permanent link">&para;</a></h4>
<h4 id="bzip2bzcat">Bzip2/bzcat<a class="headerlink" href="#bzip2bzcat" title="Permanent link">&para;</a></h4>
<h4 id="tar">Tar<a class="headerlink" href="#tar" title="Permanent link">&para;</a></h4>
<p>Linux下最常用的打包程序就是tar了，使用tar程序打出来的包我们常称为tar包，tar包文件的命令通
常都是以.tar结尾的。生成tar包后，就可以用其它的程序来进行压缩了，所以首先就来讲讲tar命令的基本
用法：
tar命令的选项有很多(用man tar可以查看到)，但常用的就那么几个选项，下面来举例说明一下：
<strong># tar -cf all.tar *.jpg</strong> 这条命令是将所有.jpg的文件打成一个名为all.tar的包。-c是表示产生新的包，-f指
定包的文件名。
<strong># tar -rf all.tar *.gif</strong> 这条命令是将所有.gif的文件增加到all.tar的包里面去。-r是表示增加文件的意思。
<strong># tar -uf all.tar logo.gif</strong> 这条命令是更新原来tar包all.tar中logo.gif文件，-u是表示更新文件的意思。
<strong># tar -tf all.tar</strong> 这条命令是列出all.tar包中所有文件，-t是列出文件的意思
<strong># tar -xf all.tar</strong> 这条命令是解出all.tar包中所有文件，-t是解开的意思
以上就是tar的最基本的用法。为了方便用户在打包解包的同时可以压缩或解压文件，tar提供了一种特
殊的功能。这就是tar可以在打包或解包的同时调用其它的压缩程序，比如调用gzip、bzip2等。
<strong>1) tar</strong> 调用 <strong>gzip</strong>
gzip是GNU组织开发的一个压缩程序，.gz结尾的文件就是gzip压缩的结果。与gzip相对的解压程序是
gunzip。tar中使用-z这个参数来调用gzip。下面来举例说明一下：
<strong># tar -czf all.tar.gz *.jpg</strong> 这条命令是将所有.jpg的文件打成一个tar包，并且将其用gzip压缩，生成一个
gzip压缩过的包，包名为all.tar.gz
<strong># tar -xzf all.tar.gz</strong> 这条命令是将上面产生的包解开。
<strong>2) tar</strong> 调用 <strong>bzip2</strong>
bzip2是一个压缩能力更强的压缩程序，.bz2结尾的文件就是bzip2压缩的结果。与bzip2相对的解压程
序是bunzip2。tar中使用-j这个参数来调用gzip。下面来举例说明一下：
<strong># tar -cjf all.tar.bz2 *.jpg</strong> 这条命令是将所有.jpg的文件打成一个tar包，并且将其用bzip2压缩，生成一个
bzip2压缩过的包，包名为all.tar.bz2
<strong># tar -xjf all.tar.bz2</strong> 这条命令是将上面产生的包解开。
下面对于tar系列的压缩文件作一个小结：
1)对于.tar结尾的文件
tar -xf all.tar
2)对于.gz结尾的文件
gzip -d all.gz
gunzip all.gz
3)对于.tgz或. t a r. g z结尾的文件
tar -xzf all.tar.gz
tar -xzf all.tgz
4)对于.bz2结尾的文件
bzip2 -d all.bz2
bunzip2 all.bz2
5)对于tar.bz2结尾的文件
tar -xjf all.tar.bz2
6)对于.Z结尾的文件</p>
<p>uncompress all.Z
7)对于.tar.Z结尾的文件
tar -xZf all.tar.z</p>
<h4 id="cpio">Cpio<a class="headerlink" href="#cpio" title="Permanent link">&para;</a></h4>
<p>Unzip：解压zip
Gnuzip：解压bz2</p>
<h2 id="_116">十九、 性能优化<a class="headerlink" href="#_116" title="Permanent link">&para;</a></h2>
<h5 id="1_20">1 、 设置文件夹打开方式<a class="headerlink" href="#1_20" title="Permanent link">&para;</a></h5>
<h5 id="2_5">2 、 设置屏幕保护时间<a class="headerlink" href="#2_5" title="Permanent link">&para;</a></h5>
<h5 id="3_5">3 、 解除上网限制<a class="headerlink" href="#3_5" title="Permanent link">&para;</a></h5>
<h5 id="4_4">4 、<a class="headerlink" href="#4_4" title="Permanent link">&para;</a></h5>
<h2 id="_117">二十、 常见问题<a class="headerlink" href="#_117" title="Permanent link">&para;</a></h2>
<h4 id="_118">部分网站无法访问问题的解决<a class="headerlink" href="#_118" title="Permanent link">&para;</a></h4>
<p>CentOS 5内核对TCP的读缓冲区大小有缺省设置，缺省为：net.ipv4.tcp_rmem = 4096 87380 4194304
解决办法就是将最后一个数字改小一点，具体操作就是在文件/etc/sysctl.conf中添加一行：
net.ipv4.tcp_rmem = 4096 87380 174760
然后保存
重新启动网络service network restart,就OK了，如果还是部分网站上不去，可以检查/etc/sysctl.conf文件是
否和下面相同
net.ipv4.ip_local_port_range = 1024 65536
net.core.rmem_max= 174760
net.core.wmem_max=16777216
net.ipv4.tcp_rmem=4096 87380 174760
net.ipv4.tcp_wmem=4096 65536 16777216
net.ipv4.tcp_fin_timeout = 15
net.ipv4.tcp_keepalive_time = 600
net.ipv4.tcp_tw_recycle = 1
net.core.netdev_max_backlog = 30000
net.ipv4.tcp_no_metrics_save=1
net.core.somaxconn = 262144
net.ipv4.tcp_syncookies = 1
net.ipv4.tcp_max_orphans = 8000
net.ipv4.tcp_max_syn_backlog = 8000
net.ipv4.tcp_synack_retries = 2
net.ipv4.tcp_syn_retries = 2
net.ipv4.tcp_wmem=4096 65536 16777216 ：为自动调优定义每个 socket 使用的内存。第一个值 4096
是为socket 的发送缓冲区分配的最少字节数。第二个值 65536 是默认值（该值会被 wmem_default 覆 盖 ），
缓冲区在系统负载不重的情况下可以增长到这个值。第三个值 16777216 是发送缓冲区空间的最大字节数（该
值会被wmem_max 覆盖）</p>
<p>net.ipv4.tcp_rmem=4096 87380 174760：与 tcp_wmem 类似，不过它表示的是为自动调优所使用的接收
缓冲区的值。
net.core.rmem_max = 25165824 #定义最大的TCP/IP栈的接收窗口大小
net.core.rmem_default = 25165824 #定义默认的TCP/IP栈的接收窗口大小
net.core.wmem_max = 25165824 #定义最大的TCP/IP栈的发送窗口大小
net.core.wmem_default = 65536 #定义默认的TCP/IP栈的发送窗口大小
net.ipv4.tcp_sack =1 #启用有选择的应答（Selective Acknowledgment），这可以通过有
选择地应答乱序接收到的报文来提高性能（这样可以让发送者只发送丢失的报文段）；（对于广域网通信来说）
这个选项应该启用，但是这会增加对 CPU 的占用。
net.ipv4.tcp_window_scaling = 1 #启用RFC1323定义，支持超过64K窗口
net.ipv4.tcp_fack =1 #启用转发应答（Forward Acknowledgment），这可以进行有选择
应答（SACK）从而减少拥塞情况的发生；这个选项也应该启用。
net.ipv4.tcp_mem 24576 32768 49152 确定 TCP 栈应该如何反映内存使用；每个值的单位都是内存页
（通常是 4KB）。第一个值是内存使用的下限。第二个值是内存压力模式开始对缓冲区使用应用压力的上限。
第三个值是内存上限。在这个层次上可以将报文丢弃，从而减少对内存的使用。对于较大的 BDP 可以增大
这些值（但是要记住，其单位是内存页，而不是字节）。</p>
<h4 id="centos5">Centos5 无法连接无线网络<a class="headerlink" href="#centos5" title="Permanent link">&para;</a></h4>
<p>系统－&gt;管理-&gt;服务器设置-&gt;服务，将NetworkManager选项勾选，点击重启服务。然后就可以看到右上
角已经有了网络连接。</p>
<h4 id="linux_windows_rdesktop">Linux 远程管理 Windows 程序 Rdesktop 详解<a class="headerlink" href="#linux_windows_rdesktop" title="Permanent link">&para;</a></h4>
<h1 id="rpm_q_rdesktop">rpm –q rdesktop //查找是否已经安装<a class="headerlink" href="#rpm_q_rdesktop" title="Permanent link">&para;</a></h1>
<h1 id="yum_install_rdesktop_yum">yum install rdesktop //使用yum安装<a class="headerlink" href="#yum_install_rdesktop_yum" title="Permanent link">&para;</a></h1>
<p>rdesktop 使用简单，windows也不和装什么服务端，是要把远程桌面共享打开就行了
具体使用方法要先打开终端，然后输入以下命令：
<strong>rdesktop -u yournape -p password -g 1024*720 192.168.0.2</strong>
rdesktop为使用远程桌面连接的命令；
-u 用户名，yourname处为目标客户端的用户名；
-p 客户端用户的密码；
-g 指定使用屏幕大小-g 800*600+0+0这 个‘ ＋ 0 ’就是，就是你这个窗口的在你linux上出现的位置；
192.168.0.1 目标客户端的IP地址
实例：
<strong>[root@Centos5 ~]# rdesktop -u aixi -p d337448 -r clipboard:PRIMARYCLIPBOARD -r disk:centos=/root -r
sound:local -z -a 16 10.26.11.72</strong>
$rdesktop 192.168.1.1 //打开了一个 8 位色彩的，
$rdesktop -a 16 192.168.1.1 //这个是 16 位色彩的了，看起来好多了
$rdesktop -u administrator -p ****** -a 16 192.168.1.1 //都直接登陆了
$rdesktop -u administrator -p ****** -a 16 -r sound:local 192.168.1.1
加上-r sound:local可以把声 音也搞过来，-r 的作用挺多的可以重定向许多东西，看一下帮助就会收获不
少了。
-r comport:COM1=/dev/ttyS0 // 将串口 /dev/ttyS0 重定向为 COM1
-r comport:COM1=/dev/ttyS0,COM2=/dev/ttyS1 // 多个串口重定向
-r disk:floppy=/mnt/floppy // 将 /mnt/floppy 重定向为远程共享磁盘 'floppy'
-r disk:floppy=/mnt/floppy,cdrom=/mnt/cdrom,root=/,c=/mnt/c // 多个磁盘重定向</p>
<p>-r clientname= // 为重定向的磁盘设置显示的客户端名称
-r lptport:LPT1=/dev/lp0 // 将并口 /dev/lp0 重定向为 LPT1
-r lptport:LPT1=/dev/lp0,LPT2=/dev/lp1 // 多个并口重定向
-r printer:mydeskjet // 打印机重定向
-r printer:mydeskjet="HP LaserJet IIIP" // 打印机重定向
-r sound:[local|off|remote] // 声音重定向
-r clipboard:PRIMARYCLIPBOARD : 这个一定要加上，要不然不能在主机Solaris和服务器Windows直接复
制粘贴文字了。贴中文也没有问题。
-r disk:sunway=/home/jianjian : 指定主机Solaris上的一个目录(/home/jianjian)映射到远程Windows上的
硬盘(盘符为sunway)，传送文件就不用再靠Samba或者FTP了。
-f ：全屏， 退出全屏：ctrl＋alt＋enter再次Ctrl+Alt+Enter即可再次进入全屏
-D：不显示标题栏，配合 -g 能更好地使用屏幕空间了；
-K： 这个选项说明保持窗口管理器的按键组合绑定；
-z：启动网络数据的压缩，减少带宽，局域网没什么作用；
提示：如果你的本地中文文件名在远程机器上显示为乱码的话，可能是你没有安装编码转化库，或者你
安装的编码转化库不能正确运行。</p>
<h4 id="linux_windows">Linux 远程访问 Windows 共享目录<a class="headerlink" href="#linux_windows" title="Permanent link">&para;</a></h4>
<h1 id="mount_o_username_password_19216801c_tmpsamba">mount –o username=用户名 –password=密码 //192.168.0.1/C$ /tmp/samba/<a class="headerlink" href="#mount_o_username_password_19216801c_tmpsamba" title="Permanent link">&para;</a></h1>
<p>[root@Centos5 ~]# mount -o username=aixi,password=d337448 //10.26.11.72/d$ /root/aixi/
说明：IP地址192.168.0.1为中文名文件所在的主机，文件位于C盘，该主机的用户名及密码为linux，
/tmp/samba/为本地主机挂载目录。在浏览完成后，使用以下命令卸载。</p>
<h1 id="umount_tmpsamba">umount /tmp/samba/<a class="headerlink" href="#umount_tmpsamba" title="Permanent link">&para;</a></h1>
<h4 id="_119">升级或安装程序后无法进入图形界面<a class="headerlink" href="#_119" title="Permanent link">&para;</a></h4>
<h5 id="_120">报错如下：<a class="headerlink" href="#_120" title="Permanent link">&para;</a></h5>
<div class="highlight"><pre><span></span><code>Failed to start the X server (your graphical interface). lt is likely that it is not set up correctly.
Would you like to view the X server output to diagnose the problem?
解决办法：
#cat /var/log/Xorg.0.log | grep EE 查看报错日志
#sh NVDIA 重新安装显卡驱动
参考如下网址：
http://www.linuxquestions.org/questions/linux-hardware-18/failed-to-start-the-x-server-your-graphical-user-
interface-605516/
</code></pre></div>
<h4 id="linux_4">Linux 自动登陆的设置方法<a class="headerlink" href="#linux_4" title="Permanent link">&para;</a></h4>
<h4 id="_121">方法一：<a class="headerlink" href="#_121" title="Permanent link">&para;</a></h4>
<h5 id="1_gdm">1 、设置GDM<a class="headerlink" href="#1_gdm" title="Permanent link">&para;</a></h5>
<div class="highlight"><pre><span></span><code>GDM是GNOME显示管理器，通过设置其配置文件/etc/gdm/custom.conf可以设置帐号自动登陆。
设置方法如下：
在/etc/gdm/custom.conf文件中添加以下内容
[daemon]
AutomaticLogin=username
AutomaticLoginEnable=True
</code></pre></div>
<div class="highlight"><pre><span></span><code>其中，username是要自动登陆的用户名。
说明：username不能是root，也就说无法实现root的自动登陆。
2 、设置prefdm
其中，/etc/inittab文件的最后一行，该行命令的作用是启动X Windows，而/etc/X11/prefdm就是具体实
现启动X Windows的脚本。
在/etc/X11/prefdm中添加启动X Windows的命令，并退出。
/usr/bin/startx
exit 1
说明：
(1)这两行代码一定要在
[ -n &quot;$preferred&quot; ] &amp;&amp; exec $preferred &quot;$@&quot; &gt;/dev/null 2&gt;&amp;1 &lt;/dev/null
代码之前。
(2)该方法自动以root登陆，是因为运行到/etc/X11/prefdm时，是root身份。
3 、在rc.local中启动X Windows
在/etc/rc.local中添加启动X Windows的命令
/usr/bin/startx
说明：该方法自动以root登陆，是因为运行到/etc/rc.local时，是root身份。
以上做完以上的操作就可以实现Xwindow的自动登录
</code></pre></div>
<h4 id="_122">方法二：<a class="headerlink" href="#_122" title="Permanent link">&para;</a></h4>
<h5 id="_123">首先配置自动登录命令行界面<a class="headerlink" href="#_123" title="Permanent link">&para;</a></h5>
<div class="highlight"><pre><span></span><code>修改/etc/inittab 将1:2345:respawn:/sbin/mingetty tty1更改为1:2345:respawn:/sbin/mingetty tty2
--autologin aixi
再将/etc/inittab 修改为启动到字符界面：id:3:initdefault
#init q 使配置生效
这样就可以开机自动启动到命令行界面，如果想自动启动到图形界面，其实在此基础上修改如下：
在/etc/rc.local中添加启动X Windows的命令
/usr/bin/startx
这样就可以自动启动到命令行，命令行又自动运行startx启动图形界面。这是最简单的一种方式。以上
在Centos5.7版本中测试通过。
</code></pre></div>





                
              </article>
            </div>
          
          
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
    <div class="md-copyright__highlight">
      BurningMyself<a href='https://beian.miit.gov.cn/' target='_blank'>  蜀ICP备15033200号-1</a>
    </div>
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
        <div class="md-social">
  
    
    
    
    
      
      
    
    <a href="https://github.com/burningmyself" target="_blank" rel="noopener" title="github.com" class="md-social__link">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.3.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg>
    </a>
  
    
    
    
    
      
      
    
    <a href="https://gitee.com/burningmyself" target="_blank" rel="noopener" title="gitee.com" class="md-social__link">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 488 512"><!--! Font Awesome Free 6.3.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M488 261.8C488 403.3 391.1 504 248 504 110.8 504 0 393.2 0 256S110.8 8 248 8c66.8 0 123 24.5 166.3 64.9l-67.5 64.9C258.5 52.6 94.3 116.6 94.3 256c0 86.5 69.1 156.6 153.7 156.6 98.2 0 135-70.4 140.8-106.9H248v-85.3h236.1c2.3 12.7 3.9 24.9 3.9 41.4z"/></svg>
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    <script id="__config" type="application/json">{"base": "../..", "features": [], "search": "../../assets/javascripts/workers/search.208ed371.min.js", "translations": {"clipboard.copied": "\u5df2\u590d\u5236", "clipboard.copy": "\u590d\u5236", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.term.missing": "\u7f3a\u5c11", "select.version": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}}</script>
    
    
      <script src="../../assets/javascripts/bundle.2a6f1dda.min.js"></script>
      
        <script src="../../js/extra.js"></script>
      
        <script src="../../js/baidu-tongji.js"></script>
      
        <script src="https://www.googletagmanager.com/gtag/js?id=UA-155084439-1"></script>
      
        <script src="https://www.googletagmanager.com/gtag/js?id=UA-155132293-1"></script>
      
        <script src="../../js/google.js"></script>
      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML"></script>
      
    
  </body>
</html>